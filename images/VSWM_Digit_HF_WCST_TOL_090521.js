/************************************** 
 * Vswm_Digit_Hf_Wcst_Tol_090521 Test *
 **************************************/

 import { PsychoJS } from './lib/core-2020.2.js';
 import * as core from './lib/core-2020.2.js';
 import { TrialHandler } from './lib/data-2020.2.js';
 import { Scheduler } from './lib/util-2020.2.js';
 import * as visual from './lib/visual-2020.2.js';
 import * as sound from './lib/sound-2020.2.js';
 import * as util from './lib/util-2020.2.js';
 //some handy aliases as in the psychopy scripts;
 const { abs, sin, cos, PI: pi, sqrt } = Math;
 const { round } = util;
 
 // init psychoJS:
 const psychoJS = new PsychoJS({
   debug: true
 });
 
 // open window:
 psychoJS.openWindow({
   fullscr: true,
   color: new util.Color([(- 1), (- 1), (- 1)]),
   units: 'height',
   waitBlanking: true
 });
 
 // store info about the experiment session:
 let expName = 'VSWM_Digit_HF_WCST_TOL_090521';  // from the Builder filename that created this script
 let expInfo = {'Enter participant ID': ''};
 
 // Start code blocks for 'Before Experiment'
 var stroop_schedule = ['Stroop_Stim_Schedule_1.xlsx','Stroop_Stim_Schedule_4.xlsx','Stroop_Stim_Schedule_5.xlsx', 'Stroop_Stim_Schedule_8.xlsx','Stroop_Stim_Schedule_11.xlsx'];
 var x1 = '';
 var x2 = '';
 var x3 = '';
 
 var myBrowser;
 var sUsrAg;
 var nIdx;
 var beginning_exp = '';
 var timer = '';
 var timer_exp = '';
 var beginning_exp = '';
 var beginning_exp2 = '';
 
 function getBrowserId () {
     var browsers = ["MSIE", "Firefox", "Safari", "Chrome", "Opera"];
     sUsrAg = window.navigator.userAgent,
     nIdx = browsers.length - 1;
     for (nIdx; nIdx > -1 && sUsrAg.indexOf(browsers [nIdx]) === -1; nIdx--);
 
   return browsers[nIdx];
 }
 
 myBrowser = getBrowserId();
 var practice_correct = 0;
 var timer_practice_wcst = '';
 var beginning_practice_wcst = '';
 var timer_wcst = '';
 var beginning_wcst = '';
 // schedule the experiment:
 psychoJS.schedule(psychoJS.gui.DlgFromDict({
   dictionary: expInfo,
   title: expName
 }));
 
 const flowScheduler = new Scheduler(psychoJS);
 const dialogCancelScheduler = new Scheduler(psychoJS);
 psychoJS.scheduleCondition(function() { return (psychoJS.gui.dialogComponent.button === 'OK'); }, flowScheduler, dialogCancelScheduler);
 
 // flowScheduler gets run if the participants presses OK
 flowScheduler.add(updateInfo); // add timeStamp
 flowScheduler.add(experimentInit);
 flowScheduler.add(WelcomeRoutineBegin());
 flowScheduler.add(WelcomeRoutineEachFrame());
 flowScheduler.add(WelcomeRoutineEnd());
 flowScheduler.add(overal_ef_assessment_instructionsRoutineBegin());
 flowScheduler.add(overal_ef_assessment_instructionsRoutineEachFrame());
 flowScheduler.add(overal_ef_assessment_instructionsRoutineEnd());
 flowScheduler.add(IntroductionRoutineBegin());
 flowScheduler.add(IntroductionRoutineEachFrame());
 flowScheduler.add(IntroductionRoutineEnd());
 flowScheduler.add(Circles_Example_1RoutineBegin());
 flowScheduler.add(Circles_Example_1RoutineEachFrame());
 flowScheduler.add(Circles_Example_1RoutineEnd());
 flowScheduler.add(Circles_Example_2RoutineBegin());
 flowScheduler.add(Circles_Example_2RoutineEachFrame());
 flowScheduler.add(Circles_Example_2RoutineEnd());
 flowScheduler.add(Circles_Example_3RoutineBegin());
 flowScheduler.add(Circles_Example_3RoutineEachFrame());
 flowScheduler.add(Circles_Example_3RoutineEnd());
 flowScheduler.add(Circle_Example_4RoutineBegin());
 flowScheduler.add(Circle_Example_4RoutineEachFrame());
 flowScheduler.add(Circle_Example_4RoutineEnd());
 flowScheduler.add(Initial_CirclesRoutineBegin());
 flowScheduler.add(Initial_CirclesRoutineEachFrame());
 flowScheduler.add(Initial_CirclesRoutineEnd());
 flowScheduler.add(Circle_Example_5ARoutineBegin());
 flowScheduler.add(Circle_Example_5ARoutineEachFrame());
 flowScheduler.add(Circle_Example_5ARoutineEnd());
 flowScheduler.add(Circle_Example_6RoutineBegin());
 flowScheduler.add(Circle_Example_6RoutineEachFrame());
 flowScheduler.add(Circle_Example_6RoutineEnd());
 flowScheduler.add(Circle_Example_7RoutineBegin());
 flowScheduler.add(Circle_Example_7RoutineEachFrame());
 flowScheduler.add(Circle_Example_7RoutineEnd());
 flowScheduler.add(Start_PracticeRoutineBegin());
 flowScheduler.add(Start_PracticeRoutineEachFrame());
 flowScheduler.add(Start_PracticeRoutineEnd());
 const Meta_LoopLoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(Meta_LoopLoopBegin, Meta_LoopLoopScheduler);
 flowScheduler.add(Meta_LoopLoopScheduler);
 flowScheduler.add(Meta_LoopLoopEnd);
 flowScheduler.add(Get_ExperimenterRoutineBegin());
 flowScheduler.add(Get_ExperimenterRoutineEachFrame());
 flowScheduler.add(Get_ExperimenterRoutineEnd());
 flowScheduler.add(InstructionsRoutineBegin());
 flowScheduler.add(InstructionsRoutineEachFrame());
 flowScheduler.add(InstructionsRoutineEnd());
 flowScheduler.add(get_readyRoutineBegin());
 flowScheduler.add(get_readyRoutineEachFrame());
 flowScheduler.add(get_readyRoutineEnd());
 const trials_2LoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(trials_2LoopBegin, trials_2LoopScheduler);
 flowScheduler.add(trials_2LoopScheduler);
 flowScheduler.add(trials_2LoopEnd);
 flowScheduler.add(real_trialsRoutineBegin());
 flowScheduler.add(real_trialsRoutineEachFrame());
 flowScheduler.add(real_trialsRoutineEnd());
 const blocksLoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(blocksLoopBegin, blocksLoopScheduler);
 flowScheduler.add(blocksLoopScheduler);
 flowScheduler.add(blocksLoopEnd);
 flowScheduler.add(EndRoutineBegin());
 flowScheduler.add(EndRoutineEachFrame());
 flowScheduler.add(EndRoutineEnd());
 flowScheduler.add(Welcome_2RoutineBegin());
 flowScheduler.add(Welcome_2RoutineEachFrame());
 flowScheduler.add(Welcome_2RoutineEnd());
 flowScheduler.add(IntroA_2RoutineBegin());
 flowScheduler.add(IntroA_2RoutineEachFrame());
 flowScheduler.add(IntroA_2RoutineEnd());
 flowScheduler.add(IntroB_2RoutineBegin());
 flowScheduler.add(IntroB_2RoutineEachFrame());
 flowScheduler.add(IntroB_2RoutineEnd());
 flowScheduler.add(Example1RoutineBegin());
 flowScheduler.add(Example1RoutineEachFrame());
 flowScheduler.add(Example1RoutineEnd());
 flowScheduler.add(Example2RoutineBegin());
 flowScheduler.add(Example2RoutineEachFrame());
 flowScheduler.add(Example2RoutineEnd());
 flowScheduler.add(Quick_ReminderRoutineBegin());
 flowScheduler.add(Quick_ReminderRoutineEachFrame());
 flowScheduler.add(Quick_ReminderRoutineEnd());
 flowScheduler.add(Practice_congruentRoutineBegin());
 flowScheduler.add(Practice_congruentRoutineEachFrame());
 flowScheduler.add(Practice_congruentRoutineEnd());
 const practice_congruent_1LoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(practice_congruent_1LoopBegin, practice_congruent_1LoopScheduler);
 flowScheduler.add(practice_congruent_1LoopScheduler);
 flowScheduler.add(practice_congruent_1LoopEnd);
 flowScheduler.add(congruent_reminderRoutineBegin());
 flowScheduler.add(congruent_reminderRoutineEachFrame());
 flowScheduler.add(congruent_reminderRoutineEnd());
 const practice_congruent_2LoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(practice_congruent_2LoopBegin, practice_congruent_2LoopScheduler);
 flowScheduler.add(practice_congruent_2LoopScheduler);
 flowScheduler.add(practice_congruent_2LoopEnd);
 flowScheduler.add(ReadyRoutineBegin());
 flowScheduler.add(ReadyRoutineEachFrame());
 flowScheduler.add(ReadyRoutineEnd());
 const trial_heartsLoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(trial_heartsLoopBegin, trial_heartsLoopScheduler);
 flowScheduler.add(trial_heartsLoopScheduler);
 flowScheduler.add(trial_heartsLoopEnd);
 flowScheduler.add(IntroA_3RoutineBegin());
 flowScheduler.add(IntroA_3RoutineEachFrame());
 flowScheduler.add(IntroA_3RoutineEnd());
 flowScheduler.add(IntroB_3RoutineBegin());
 flowScheduler.add(IntroB_3RoutineEachFrame());
 flowScheduler.add(IntroB_3RoutineEnd());
 flowScheduler.add(Example3RoutineBegin());
 flowScheduler.add(Example3RoutineEachFrame());
 flowScheduler.add(Example3RoutineEnd());
 flowScheduler.add(Example4RoutineBegin());
 flowScheduler.add(Example4RoutineEachFrame());
 flowScheduler.add(Example4RoutineEnd());
 flowScheduler.add(Quick_Reminder_IncongruentRoutineBegin());
 flowScheduler.add(Quick_Reminder_IncongruentRoutineEachFrame());
 flowScheduler.add(Quick_Reminder_IncongruentRoutineEnd());
 flowScheduler.add(Practice_IncongruentRoutineBegin());
 flowScheduler.add(Practice_IncongruentRoutineEachFrame());
 flowScheduler.add(Practice_IncongruentRoutineEnd());
 const practice_incongruent_1LoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(practice_incongruent_1LoopBegin, practice_incongruent_1LoopScheduler);
 flowScheduler.add(practice_incongruent_1LoopScheduler);
 flowScheduler.add(practice_incongruent_1LoopEnd);
 flowScheduler.add(incongruent_reminderRoutineBegin());
 flowScheduler.add(incongruent_reminderRoutineEachFrame());
 flowScheduler.add(incongruent_reminderRoutineEnd());
 const practice_incongruent_2LoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(practice_incongruent_2LoopBegin, practice_incongruent_2LoopScheduler);
 flowScheduler.add(practice_incongruent_2LoopScheduler);
 flowScheduler.add(practice_incongruent_2LoopEnd);
 flowScheduler.add(Ready2RoutineBegin());
 flowScheduler.add(Ready2RoutineEachFrame());
 flowScheduler.add(Ready2RoutineEnd());
 const trial_flowersLoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(trial_flowersLoopBegin, trial_flowersLoopScheduler);
 flowScheduler.add(trial_flowersLoopScheduler);
 flowScheduler.add(trial_flowersLoopEnd);
 flowScheduler.add(IntroA_4RoutineBegin());
 flowScheduler.add(IntroA_4RoutineEachFrame());
 flowScheduler.add(IntroA_4RoutineEnd());
 flowScheduler.add(IntroB_5RoutineBegin());
 flowScheduler.add(IntroB_5RoutineEachFrame());
 flowScheduler.add(IntroB_5RoutineEnd());
 flowScheduler.add(IntroC_11RoutineBegin());
 flowScheduler.add(IntroC_11RoutineEachFrame());
 flowScheduler.add(IntroC_11RoutineEnd());
 flowScheduler.add(IntroC_2RoutineBegin());
 flowScheduler.add(IntroC_2RoutineEachFrame());
 flowScheduler.add(IntroC_2RoutineEnd());
 flowScheduler.add(Quick_Reminder_MixedRoutineBegin());
 flowScheduler.add(Quick_Reminder_MixedRoutineEachFrame());
 flowScheduler.add(Quick_Reminder_MixedRoutineEnd());
 flowScheduler.add(Practice_mixedRoutineBegin());
 flowScheduler.add(Practice_mixedRoutineEachFrame());
 flowScheduler.add(Practice_mixedRoutineEnd());
 const practice_mixed_1LoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(practice_mixed_1LoopBegin, practice_mixed_1LoopScheduler);
 flowScheduler.add(practice_mixed_1LoopScheduler);
 flowScheduler.add(practice_mixed_1LoopEnd);
 flowScheduler.add(reminder_mixedRoutineBegin());
 flowScheduler.add(reminder_mixedRoutineEachFrame());
 flowScheduler.add(reminder_mixedRoutineEnd());
 const practice_mixed_2LoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(practice_mixed_2LoopBegin, practice_mixed_2LoopScheduler);
 flowScheduler.add(practice_mixed_2LoopScheduler);
 flowScheduler.add(practice_mixed_2LoopEnd);
 flowScheduler.add(Ready3RoutineBegin());
 flowScheduler.add(Ready3RoutineEachFrame());
 flowScheduler.add(Ready3RoutineEnd());
 flowScheduler.add(mixed_firstRoutineBegin());
 flowScheduler.add(mixed_firstRoutineEachFrame());
 flowScheduler.add(mixed_firstRoutineEnd());
 const trial_mixedLoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(trial_mixedLoopBegin, trial_mixedLoopScheduler);
 flowScheduler.add(trial_mixedLoopScheduler);
 flowScheduler.add(trial_mixedLoopEnd);
 flowScheduler.add(Thank_YouRoutineBegin());
 flowScheduler.add(Thank_YouRoutineEachFrame());
 flowScheduler.add(Thank_YouRoutineEnd());
 flowScheduler.add(welcomeRoutineBegin());
 flowScheduler.add(welcomeRoutineEachFrame());
 flowScheduler.add(welcomeRoutineEnd());
 flowScheduler.add(Instructions_3RoutineBegin());
 flowScheduler.add(Instructions_3RoutineEachFrame());
 flowScheduler.add(Instructions_3RoutineEnd());
 flowScheduler.add(ExampleRoutineBegin());
 flowScheduler.add(ExampleRoutineEachFrame());
 flowScheduler.add(ExampleRoutineEnd());
 flowScheduler.add(lets_practiceRoutineBegin());
 flowScheduler.add(lets_practiceRoutineEachFrame());
 flowScheduler.add(lets_practiceRoutineEnd());
 const trials_practice_loopLoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(trials_practice_loopLoopBegin, trials_practice_loopLoopScheduler);
 flowScheduler.add(trials_practice_loopLoopScheduler);
 flowScheduler.add(trials_practice_loopLoopEnd);
 flowScheduler.add(readyRoutineBegin());
 flowScheduler.add(readyRoutineEachFrame());
 flowScheduler.add(readyRoutineEnd());
 const blocks_2LoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(blocks_2LoopBegin, blocks_2LoopScheduler);
 flowScheduler.add(blocks_2LoopScheduler);
 flowScheduler.add(blocks_2LoopEnd);
 flowScheduler.add(tol_welcomeRoutineBegin());
 flowScheduler.add(tol_welcomeRoutineEachFrame());
 flowScheduler.add(tol_welcomeRoutineEnd());
 flowScheduler.add(tol_explanationRoutineBegin());
 flowScheduler.add(tol_explanationRoutineEachFrame());
 flowScheduler.add(tol_explanationRoutineEnd());
 flowScheduler.add(tol_instructionsRoutineBegin());
 flowScheduler.add(tol_instructionsRoutineEachFrame());
 flowScheduler.add(tol_instructionsRoutineEnd());
 flowScheduler.add(tol_exampleRoutineBegin());
 flowScheduler.add(tol_exampleRoutineEachFrame());
 flowScheduler.add(tol_exampleRoutineEnd());
 flowScheduler.add(tol_prepracticeRoutineBegin());
 flowScheduler.add(tol_prepracticeRoutineEachFrame());
 flowScheduler.add(tol_prepracticeRoutineEnd());
 const task_trialsLoopScheduler = new Scheduler(psychoJS);
 flowScheduler.add(task_trialsLoopBegin, task_trialsLoopScheduler);
 flowScheduler.add(task_trialsLoopScheduler);
 flowScheduler.add(task_trialsLoopEnd);
 flowScheduler.add(End_2RoutineBegin());
 flowScheduler.add(End_2RoutineEachFrame());
 flowScheduler.add(End_2RoutineEnd());
 flowScheduler.add(quitPsychoJS, '', true);
 
 // quit if user presses Cancel in dialog box:
 dialogCancelScheduler.add(quitPsychoJS, '', false);
 
 psychoJS.start({
   expName: expName,
   expInfo: expInfo,
   });
 
 psychoJS.experimentLogger.setLevel(core.Logger.ServerLevel.DEBUG);
 
 
 var frameDur;
 function updateInfo() {
   expInfo['date'] = util.MonotonicClock.getDateStr();  // add a simple timestamp
   expInfo['expName'] = expName;
   expInfo['psychopyVersion'] = '2020.2.8';
   expInfo['OS'] = window.navigator.platform;
 
   // store frame rate of monitor if we can measure it successfully
   expInfo['frameRate'] = psychoJS.window.getActualFrameRate();
   if (typeof expInfo['frameRate'] !== 'undefined')
     frameDur = 1.0 / Math.round(expInfo['frameRate']);
   else
     frameDur = 1.0 / 60.0; // couldn't get a reliable measure so guess
 
   // add info from the URL:
   util.addInfoFromUrl(expInfo);
   psychoJS.setRedirectUrls('https://run.pavlovia.org/skuchynka/mlm-exp-final/html', '');
 
   return Scheduler.Event.NEXT;
 }
 
 
 var WelcomeClock;
 var text_12;
 var text_13;
 var key_resp_8;
 var x3;
 var x2;
 var x1;
 var end_experiment;
 var timer;
 var timer_exp;
 var beginning_exp;
 var beginning_exp2;
 var overal_ef_assessment_instructionsClock;
 var text_130;
 var text_131;
 var key_resp_57;
 var image_29;
 var IntroductionClock;
 var text_14;
 var text_16;
 var key_resp_9;
 var Circles_Example_1Clock;
 var init_circle;
 var init_circle_17;
 var init_circle_18;
 var init_circle_19;
 var init_circle_20;
 var init_circle_21;
 var init_circle_22;
 var init_circle_23;
 var init_circle_24;
 var init_circle_25;
 var init_circle_26;
 var init_circle_27;
 var init_circle_28;
 var init_circle_29;
 var init_circle_30;
 var init_circle_31;
 var For_example;
 var Circles_Example_2Clock;
 var init_circle_32;
 var init_circle_33;
 var init_circle_34;
 var C4_circle_lights_up;
 var init_circle_36;
 var init_circle_37;
 var init_circle_38;
 var init_circle_39;
 var init_circle_40;
 var init_circle_41;
 var init_circle_42;
 var init_circle_43;
 var init_circle_44;
 var init_circle_45;
 var init_circle_46;
 var init_circle_47;
 var For_example_2;
 var Circles_Example_3Clock;
 var init_circle_35;
 var init_circle_48;
 var init_circle_49;
 var init_circle_63;
 var init_circle_50;
 var circle_6_lights_up;
 var init_circle_52;
 var init_circle_53;
 var init_circle_54;
 var init_circle_55;
 var init_circle_56;
 var init_circle_57;
 var init_circle_58;
 var init_circle_59;
 var init_circle_60;
 var init_circle_61;
 var b_For_example_4;
 var Circle_Example_4Clock;
 var init_circle_51;
 var init_circle_62;
 var init_circle_64;
 var init_circle_65;
 var init_circle_66;
 var init_circle_80;
 var init_circle_67;
 var init_circle_68;
 var init_circle_69;
 var init_circle_70;
 var init_circle_71;
 var init_circle_72;
 var init_circle_73;
 var init_circle_74;
 var circle_15_lights_up;
 var init_circle_76;
 var For_example_5;
 var Initial_CirclesClock;
 var init_circle_1;
 var init_circle_2;
 var init_circle_3;
 var init_circle_4;
 var init_circle_5;
 var init_circle_6;
 var init_circle_7;
 var init_circle_8;
 var init_circle_9;
 var init_circle_10;
 var init_circle_11;
 var init_circle_12;
 var init_circle_13;
 var init_circle_14;
 var init_circle_15;
 var init_circle_16;
 var Circle_Example_5AClock;
 var first_response_C1_example;
 var first_response_C2_example;
 var first_response_C3_example;
 var first_response_C4_example;
 var first_response_C5_example;
 var first_response_C6_example;
 var first_response_C7_example;
 var first_response_C8_example;
 var first_response_C9_example;
 var first_response_C10_example;
 var first_response_C11_example;
 var first_response_C12_example;
 var first_response_C13_example;
 var first_response_C14_example;
 var first_response_C15_example;
 var first_response_C16_example;
 var first_mouse_response_example;
 var polygon;
 var triangle;
 var push_these_circles;
 var Circle_Example_6Clock;
 var second_response_C1_example;
 var second_response_C2_example;
 var second_response_C3_example;
 var second_response_C4_example;
 var second_response_C5_example;
 var second_response_C6_example;
 var second_response_C7_example;
 var second_response_C8_example;
 var second_response_C9_example;
 var second_response_C10_example;
 var second_response_C11_example;
 var second_response_C12_example;
 var second_response_C13_example;
 var second_response_C14_example;
 var second_response_C15_example;
 var second_response_C16_example;
 var second_mouse_response_example;
 var polygon_2;
 var triangle_2;
 var push_these_circles_2;
 var Circle_Example_7Clock;
 var third_response_C1_example;
 var third_response_C2_example;
 var third_response_C3_example;
 var third_response_C4_example;
 var third_response_C5_example;
 var third_response_C6_example;
 var third_response_C7_example;
 var third_response_C8_example;
 var third_response_C9_example;
 var third_response_C10_example;
 var third_response_C11_example;
 var third_response_C12_example;
 var third_response_C13_example;
 var third_response_C14_example;
 var third_response_C15_example;
 var third_response_C16_example;
 var third_mouse_response_example;
 var polygon_3;
 var triangle_3;
 var push_these_circles_3;
 var Start_PracticeClock;
 var practice_text;
 var spacebar_text;
 var mouse;
 var Update_loopClock;
 var circle_loop;
 var Check_practice_overClock;
 var text_3;
 var mouse_2;
 var mouse_click_text;
 var check_first_round_practiceClock;
 var First_Circle_PresentationClock;
 var first_circle_pres_C1;
 var first_circle_pres_C2;
 var first_circle_pres_C3;
 var first_circle_pres_C4;
 var first_circle_pres_C5;
 var first_circle_pres_C6;
 var first_circle_pres_C7;
 var first_circle_pres_C8;
 var first_circle_pres_C9;
 var first_circle_pres_C10;
 var first_circle_pres_C11;
 var first_circle_pres_C12;
 var first_circle_pres_C13;
 var first_circle_pres_C14;
 var first_circle_pres_C15;
 var first_circle_pres_C16;
 var Second_Circle_PresentationClock;
 var second_circle_pres_C1;
 var second_circle_pres_C2;
 var second_circle_pres_C3;
 var second_circle_pres_C4;
 var second_circle_pres_C5;
 var second_circle_pres_C6;
 var second_circle_pres_C7;
 var second_circle_pres_C8;
 var second_circle_pres_C9;
 var second_circle_pres_C10;
 var second_circle_pres_C11;
 var second_circle_pres_C12;
 var second_circle_pres_C13;
 var second_circle_pres_C14;
 var second_circle_pres_C15;
 var second_circle_pres_C16;
 var Third_Circle_PresentationClock;
 var third_circle_pres_C1;
 var third_circle_pres_C2;
 var third_circle_pres_C3;
 var third_circle_pres_C4;
 var third_circle_pres_C5;
 var third_circle_pres_C6;
 var third_circle_pres_C7;
 var third_circle_pres_C8;
 var third_circle_pres_C9;
 var third_circle_pres_C10;
 var third_circle_pres_C11;
 var third_circle_pres_C12;
 var third_circle_pres_C13;
 var third_circle_pres_C14;
 var third_circle_pres_C15;
 var third_circle_pres_C16;
 var Fourth_Circle_PresentationClock;
 var fourth_circle_pres_C1;
 var fourth_circle_pres_C2;
 var fourth_circle_pres_C3;
 var fourth_circle_pres_C4;
 var fourth_circle_pres_C5;
 var fourth_circle_pres_C6;
 var fourth_circle_pres_C7;
 var fourth_circle_pres_C8;
 var fourth_circle_pres_C9;
 var fourth_circle_pres_C10;
 var fourth_circle_pres_C11;
 var fourth_circle_pres_C12;
 var fourth_circle_pres_C13;
 var fourth_circle_pres_C14;
 var fourth_circle_pres_C15;
 var fourth_circle_pres_C16;
 var Fifth_Circle_PresentationClock;
 var fifth_circle_pres_C1;
 var fifth_circle_pres_C2;
 var fifth_circle_pres_C3;
 var fifth_circle_pres_C4;
 var fifth_circle_pres_C5;
 var fifth_circle_pres_C6;
 var fifth_circle_pres_C7;
 var fifth_circle_pres_C8;
 var fifth_circle_pres_C9;
 var fifth_circle_pres_C10;
 var fifth_circle_pres_C11;
 var fifth_circle_pres_C12;
 var fifth_circle_pres_C13;
 var fifth_circle_pres_C14;
 var fifth_circle_pres_C15;
 var fifth_circle_pres_C16;
 var Sixth_Circle_PresentationClock;
 var sixth_circle_pres_C1;
 var sixth_circle_pres_C2;
 var sixth_circle_pres_C3;
 var sixth_circle_pres_C4;
 var sixth_circle_pres_C5;
 var sixth_circle_pres_C6;
 var sixth_circle_pres_C7;
 var sixth_circle_pres_C8;
 var sixth_circle_pres_C9;
 var sixth_circle_pres_C10;
 var sixth_circle_pres_C11;
 var sixth_circle_pres_C12;
 var sixth_circle_pres_C13;
 var sixth_circle_pres_C14;
 var sixth_circle_pres_C15;
 var sixth_circle_pres_C16;
 var Seventh_Circle_PresentationClock;
 var seventh_circle_pres_C1;
 var seventh_circle_pres_C2;
 var seventh_circle_pres_C3;
 var seventh_circle_pres_C4;
 var seventh_circle_pres_C5;
 var seventh_circle_pres_C6;
 var seventh_circle_pres_C7;
 var seventh_circle_pres_C8;
 var seventh_circle_pres_C9;
 var seventh_circle_pres_C10;
 var seventh_circle_pres_C11;
 var seventh_circle_pres_C12;
 var seventh_circle_pres_C13;
 var seventh_circle_pres_C14;
 var seventh_circle_pres_C15;
 var seventh_circle_pres_C16;
 var Eighth_Circle_PresentationClock;
 var eighth_circle_pres_C1;
 var eighth_circle_pres_C2;
 var eighth_circle_pres_C3;
 var eighth_circle_pres_C4;
 var eighth_circle_pres_C5;
 var eighth_circle_pres_C6;
 var eighth_circle_pres_C7;
 var eighth_circle_pres_C8;
 var eighth_circle_pres_C9;
 var eighth_circle_pres_C10;
 var eighth_circle_pres_C11;
 var eighth_circle_pres_C12;
 var eighth_circle_pres_C13;
 var eighth_circle_pres_C14;
 var eighth_circle_pres_C15;
 var eighth_circle_pres_C16;
 var Wait_for_First_responseClock;
 var first_response_C1;
 var first_response_C2;
 var first_response_C3;
 var first_response_C4;
 var first_response_C5;
 var first_response_C6;
 var first_response_C7;
 var first_response_C8;
 var first_response_C9;
 var first_response_C10;
 var first_response_C11;
 var first_response_C12;
 var first_response_C13;
 var first_response_C14;
 var first_response_C15;
 var first_response_C16;
 var first_mouse_response;
 var Wait_for_Second_responseClock;
 var second_response_C1;
 var second_response_C2;
 var second_response_C3;
 var second_response_C4;
 var second_response_C5;
 var second_response_C6;
 var second_response_C7;
 var second_response_C8;
 var second_response_C9;
 var second_response_C10;
 var second_response_C11;
 var second_response_C12;
 var second_response_C13;
 var second_response_C14;
 var second_response_C15;
 var second_response_C16;
 var second_mouse_response;
 var Wait_for_Third_ResponseClock;
 var third_response_C1;
 var third_response_C2;
 var third_response_C3;
 var third_response_C4;
 var third_response_C5;
 var third_response_C6;
 var third_response_C7;
 var third_response_C8;
 var third_response_C9;
 var third_response_C10;
 var third_response_C11;
 var third_response_C12;
 var third_response_C13;
 var third_response_C14;
 var third_response_C15;
 var third_response_C16;
 var third_mouse_response;
 var Wait_for_Fourth_ResponseClock;
 var fourth_response_C1;
 var fourth_response_C2;
 var fourth_response_C3;
 var fourth_response_C4;
 var fourth_response_C5;
 var fourth_response_C6;
 var fourth_response_C7;
 var fourth_response_C8;
 var fourth_response_C9;
 var fourth_response_C10;
 var fourth_response_C11;
 var fourth_response_C12;
 var fourth_response_C13;
 var fourth_response_C14;
 var fourth_response_C15;
 var fourth_response_C16;
 var fourth_mouse_response;
 var Wait_for_Fifth_ResponseClock;
 var fifth_response_C1;
 var fifth_response_C2;
 var fifth_response_C3;
 var fifth_response_C4;
 var fifth_response_C5;
 var fifth_response_C6;
 var fifth_response_C7;
 var fifth_response_C8;
 var fifth_response_C9;
 var fifth_response_C10;
 var fifth_response_C11;
 var fifth_response_C12;
 var fifth_response_C13;
 var fifth_response_C14;
 var fifth_response_C15;
 var fifth_response_C16;
 var fifth_mouse_response;
 var Wait_For_Sixth_ResponseClock;
 var sixth_response_C1;
 var sixth_response_C2;
 var sixth_response_C3;
 var sixth_response_C4;
 var sixth_response_C5;
 var sixth_response_C6;
 var sixth_response_C7;
 var sixth_response_C8;
 var sixth_response_C9;
 var sixth_response_C10;
 var sixth_response_C11;
 var sixth_response_C12;
 var sixth_response_C13;
 var sixth_response_C14;
 var sixth_response_C15;
 var sixth_response_C16;
 var sixth_mouse_response;
 var Wait_For_Seventh_ResponseClock;
 var seventh_response_C1;
 var seventh_response_C2;
 var seventh_response_C3;
 var seventh_response_C4;
 var seventh_response_C5;
 var seventh_response_C6;
 var seventh_response_C7;
 var seventh_response_C8;
 var seventh_response_C9;
 var seventh_response_C10;
 var seventh_response_C11;
 var seventh_response_C12;
 var seventh_response_C13;
 var seventh_response_C14;
 var seventh_response_C15;
 var seventh_response_C16;
 var seventh_mouse_response;
 var Wait_For_Eighth_ResponseClock;
 var eighth_response_C1;
 var eighth_response_C2;
 var eighth_response_C3;
 var eighth_response_C4;
 var eighth_response_C5;
 var eighth_response_C6;
 var eighth_response_C7;
 var eighth_response_C8;
 var eighth_response_C9;
 var eighth_response_C10;
 var eighth_response_C11;
 var eighth_response_C12;
 var eighth_response_C13;
 var eighth_response_C14;
 var eighth_response_C15;
 var eighth_response_C16;
 var eighth_mouse_response;
 var Check_outcomeClock;
 var corr;
 var Blank_ScreenClock;
 var text;
 var feedbackClock;
 var text_4;
 var msg;
 var Repeat_InstructionsClock;
 var repeat_inst;
 var key_resp;
 var text_5;
 var check_end_experimentClock;
 var Get_ExperimenterClock;
 var text_11;
 var b_text_15;
 var InstructionsClock;
 var instructions;
 var key_resp_2;
 var trial_counter;
 var condition_counter;
 var get_readyClock;
 var text_6;
 var key_resp_3;
 var text_7;
 var code_metaClock;
 var Presentation_practiceClock;
 var fixation_2;
 var pres_text_2;
 var Recall_practiceClock;
 var recall_text_2;
 var key_resp_4;
 var allResponses_p;
 var current_resp;
 var pts_response_2;
 var feedback_practiceClock;
 var text_8;
 var code_endClock;
 var repeat_instructionsClock;
 var text_9;
 var key_resp_6;
 var text_10;
 var real_trialsClock;
 var get_ready_real_trial;
 var press_space;
 var key_resp_5;
 var PresentationClock;
 var fixation;
 var pres_text;
 var RecallClock;
 var recall_text;
 var key_resp_7;
 var allResponses;
 var pts_response;
 var FeedbackClock;
 var EndClock;
 var thank_you;
 var before_closing;
 var Welcome_2Clock;
 var white_background_10;
 var text_15;
 var text_17;
 var key_resp_10;
 var IntroA_2Clock;
 var white_background_25;
 var image_11;
 var text_40;
 var text_46;
 var key_resp_27;
 var IntroB_2Clock;
 var white_background_21;
 var text_52;
 var text_53;
 var key_resp_28;
 var Example1Clock;
 var white_background_14;
 var text_18;
 var image_3;
 var key_resp_11;
 var text_60;
 var Example2Clock;
 var white_background_12;
 var text_19;
 var image_4;
 var key_resp_12;
 var text_61;
 var Quick_ReminderClock;
 var white_background_19;
 var text_71;
 var key_resp_32;
 var text_72;
 var Practice_congruentClock;
 var white_background_7;
 var text_20;
 var text_21;
 var key_resp_13;
 var Practice_trial_congruentClock;
 var white_background_17;
 var text_22;
 var text_64;
 var image_5;
 var text_28;
 var key_resp_14;
 var feedback_hf_congruent_1Clock;
 var white_background_33;
 var text_108;
 var congruent_reminderClock;
 var white_background_41;
 var text_102;
 var text_103;
 var key_resp_37;
 var eachResp;
 var Practice_trial_congruent_2Clock;
 var white_background_32;
 var text_93;
 var text_94;
 var image_13;
 var text_95;
 var key_resp_21;
 var feedback_hf_congruent_2Clock;
 var white_background_34;
 var text_114;
 var ReadyClock;
 var white_background_30;
 var text_29;
 var key_resp_15;
 var text_30;
 var HeartsClock;
 var white_background_6;
 var text_23;
 var text_65;
 var hearts;
 var text_31;
 var heart_resp;
 var IntroA_3Clock;
 var white_background_26;
 var text_32;
 var key_resp_16;
 var text_33;
 var image_12;
 var IntroB_3Clock;
 var white_background_20;
 var text_47;
 var text_34;
 var key_resp_17;
 var Example3Clock;
 var white_background_13;
 var text_35;
 var image_6;
 var key_resp_18;
 var text_62;
 var Example4Clock;
 var white_background_11;
 var text_36;
 var image_7;
 var key_resp_19;
 var text_63;
 var Quick_Reminder_IncongruentClock;
 var white_background_28;
 var text_75;
 var key_resp_34;
 var text_76;
 var Practice_IncongruentClock;
 var white_background_8;
 var text_37;
 var text_38;
 var key_resp_20;
 var Practice_trial_incongruentClock;
 var white_background_22;
 var text_39;
 var text_66;
 var image_8;
 var text_48;
 var key_resp_22;
 var feedback_hf_incongruent_1Clock;
 var white_background_38;
 var text_113;
 var incongruent_reminderClock;
 var white_background_42;
 var text_104;
 var text_105;
 var key_resp_38;
 var Practice_trial_incongruent_2Clock;
 var white_background_35;
 var text_96;
 var text_97;
 var image_14;
 var text_98;
 var key_resp_23;
 var feedback_hf_incongruent_2Clock;
 var white_background_37;
 var text_112;
 var Ready2Clock;
 var white_background_3;
 var text_49;
 var text_50;
 var key_resp_24;
 var FlowersClock;
 var white_background_16;
 var text_51;
 var text_67;
 var image;
 var text_54;
 var key_resp_25;
 var IntroA_4Clock;
 var white_background_27;
 var text_55;
 var key_resp_26;
 var text_56;
 var IntroB_5Clock;
 var white_background_18;
 var text_57;
 var text_58;
 var key_resp_29;
 var IntroC_11Clock;
 var white_background_23;
 var text_69;
 var text_70;
 var key_resp_31;
 var IntroC_2Clock;
 var white_background_24;
 var text_73;
 var text_74;
 var key_resp_30;
 var Quick_Reminder_MixedClock;
 var white_background_29;
 var text_77;
 var key_resp_33;
 var text_78;
 var Practice_mixedClock;
 var white_background_2;
 var text_79;
 var key_resp_35;
 var text_80;
 var Practice_trial_mixedClock;
 var white_background_15;
 var text_81;
 var text_82;
 var image_9;
 var text_83;
 var key_resp_36;
 var feedback_hf_mixed_1Clock;
 var white_background_39;
 var text_110;
 var reminder_mixedClock;
 var white_background_43;
 var text_106;
 var text_107;
 var key_resp_39;
 var Practice_trial_mixed_2Clock;
 var white_background_36;
 var text_99;
 var text_100;
 var image_15;
 var text_101;
 var key_resp_40;
 var feedback_hf_mixed_2Clock;
 var white_background_40;
 var text_109;
 var Ready3Clock;
 var white_background_4;
 var text_84;
 var key_resp_41;
 var text_85;
 var mixed_firstClock;
 var white_background_9;
 var text_86;
 var text_87;
 var image_10;
 var text_88;
 var key_resp_42;
 var MixedClock;
 var white_background_5;
 var text_89;
 var text_90;
 var image_2;
 var text_91;
 var key_resp_43;
 var Thank_YouClock;
 var white_background_31;
 var text_92;
 var text_111;
 var welcomeClock;
 var text_122;
 var text_123;
 var key_resp_52;
 var Instructions_3Clock;
 var instructions_2;
 var key_resp_53;
 var text_124;
 var ExampleClock;
 var example_text;
 var example;
 var example_text_2;
 var key_resp_54;
 var lets_practiceClock;
 var text_125;
 var key_resp_55;
 var text_126;
 var trials_practice_2Clock;
 var fixation_4;
 var one_red_dot_2;
 var two_yellow_triangles_2;
 var three_green_crosses_2;
 var four_blue_stars_2;
 var trial_card_2;
 var response_2;
 var feedback_practice_2Clock;
 var corr_trial_counter;
 var prev;
 var feedback_text_2;
 var readyClock;
 var text_127;
 var text_128;
 var key_resp_56;
 var code_meta_2Clock;
 var TrialsClock;
 var fixation_5;
 var one_red_dot;
 var two_yellow_triangles;
 var three_green_crosses;
 var four_blue_stars;
 var trial_card;
 var response;
 var Feedback_2Clock;
 var feedback_text;
 var code_end_2Clock;
 var tol_welcomeClock;
 var light_gray_bg_6;
 var text_129;
 var mouse_8;
 var check_box_welcome;
 var text_next_wel;
 var tol_explanationClock;
 var light_gray_bg_7;
 var base_right_6;
 var pole_right_13;
 var pole_right_14;
 var pole_right_15;
 var right_green_5;
 var right_red_5;
 var right_blue_5;
 var base_left_6;
 var bart1m2_leftc_4;
 var bart1m2_leftb_4;
 var bart1m2_lefta_4;
 var mouse_9;
 var fixedt1m2_a1_4;
 var fixedt1m2_a2_4;
 var fixedt1m2_a3_4;
 var fixedt1m2_b1_4;
 var fixedt1m2_b2_4;
 var fixedt1m2_c1_4;
 var text_exp;
 var greent1m2_4;
 var redt1m2_4;
 var bluet1m2_4;
 var check_box_2;
 var text_132;
 var text_133;
 var text_134;
 var tol_instructionsClock;
 var light_gray_bg_8;
 var base_right_7;
 var pole_right_16;
 var pole_right_17;
 var pole_right_18;
 var right_green_6;
 var right_red_6;
 var right_blue_6;
 var base_left_7;
 var bart1m2_leftc_5;
 var bart1m2_leftb_5;
 var bart1m2_lefta_5;
 var mouse_10;
 var fixedt1m2_a1_5;
 var fixedt1m2_a2_5;
 var fixedt1m2_a3_5;
 var fixedt1m2_b1_5;
 var fixedt1m2_b2_5;
 var fixedt1m2_c1_5;
 var text_exp_2;
 var greent1m2_5;
 var redt1m2_5;
 var bluet1m2_5;
 var check_box_3;
 var text_135;
 var text_136;
 var text_137;
 var tol_exampleClock;
 var light_gray_bg_9;
 var base_right_8;
 var pole_right_19;
 var pole_right_20;
 var pole_right_21;
 var right_green_7;
 var right_red_7;
 var right_blue_7;
 var base_left_8;
 var bart1m2_leftc_6;
 var bart1m2_leftb_6;
 var bart1m2_lefta_6;
 var mouse_11;
 var fixedt1m2_a1_6;
 var fixedt1m2_a2_6;
 var fixedt1m2_a3_6;
 var fixedt1m2_b1_6;
 var fixedt1m2_b2_6;
 var fixedt1m2_c1_6;
 var text_exp_3;
 var greent1m2_6;
 var redt1m2_6;
 var bluet1m2_6;
 var check_box_4;
 var text_138;
 var text_139;
 var text_140;
 var tol_prepracticeClock;
 var light_gray_bg_10;
 var base_right_9;
 var pole_right_22;
 var pole_right_23;
 var pole_right_24;
 var right_green_8;
 var right_red_8;
 var right_blue_8;
 var base_left_9;
 var bart1m2_leftc_7;
 var bart1m2_leftb_7;
 var bart1m2_lefta_7;
 var mouse_12;
 var fixedt1m2_a1_7;
 var fixedt1m2_a2_7;
 var fixedt1m2_a3_7;
 var fixedt1m2_b1_7;
 var fixedt1m2_b2_7;
 var fixedt1m2_c1_7;
 var text_exp_4;
 var greent1m2_7;
 var redt1m2_7;
 var bluet1m2_7;
 var check_box_5;
 var text_141;
 var text_142;
 var text_143;
 var text_144;
 var tol_next_trialClock;
 var light_gray_bg_13;
 var text_146;
 var mouse_15;
 var check_box_trial;
 var text_next_wel_3;
 var first_movementClock;
 var mouse_3;
 var light_gray_bg;
 var base_right;
 var pole_right_01;
 var pole_right_02;
 var pole_right_03;
 var right_green;
 var right_red;
 var right_blue;
 var ball_hand_box;
 var base_left;
 var bart1m1_lefta;
 var bart1m1_leftb;
 var bart1m1_leftc;
 var greent1m1;
 var redt1m1;
 var bluet1m1;
 var counter;
 var counter2;
 var bluepos_orig;
 var redpos_orig;
 var greenpos_orig;
 var bluepos;
 var greenpos;
 var redpos;
 var fixedt1m1_a1;
 var fixedt1m1_a2;
 var fixedt1m1_a3;
 var fixedt1m1_b1;
 var fixedt1m1_b2;
 var fixedt1m1_c1;
 var text_148;
 var check_step1_t1Clock;
 var light_gray_bg_5;
 var ball_hand_box_5;
 var base_right_5;
 var pole_right_10;
 var pole_right_11;
 var pole_right_12;
 var right_green_4;
 var right_red_4;
 var right_blue_4;
 var base_left_5;
 var bart1m2_leftc_3;
 var bart1m2_leftb_3;
 var bart1m2_lefta_3;
 var mouse_7;
 var fixedt1m2_a1_3;
 var fixedt1m2_a2_3;
 var fixedt1m2_a3_3;
 var fixedt1m2_b1_3;
 var fixedt1m2_b2_3;
 var fixedt1m2_c1_3;
 var greent1m2_3;
 var redt1m2_3;
 var bluet1m2_3;
 var text_150;
 var second_movClock;
 var light_gray_bg_3;
 var ball_hand_box_3;
 var base_right_3;
 var pole_right_2;
 var pole_right_5;
 var pole_right_6;
 var right_green_2;
 var right_red_2;
 var right_blue_2;
 var base_left_3;
 var bart1m2_leftc;
 var bart1m2_leftb;
 var bart1m2_lefta;
 var mouse_4;
 var fixedt1m2_a1;
 var fixedt1m2_a2;
 var fixedt1m2_a3;
 var fixedt1m2_b1;
 var fixedt1m2_b2;
 var fixedt1m2_c1;
 var greent1m2;
 var redt1m2;
 var bluet1m2;
 var text_152;
 var check_step2_t1Clock;
 var light_gray_bg_4;
 var ball_hand_box_4;
 var base_right_4;
 var pole_right_7;
 var pole_right_8;
 var pole_right_9;
 var right_green_3;
 var right_red_3;
 var right_blue_3;
 var base_left_4;
 var bart1m2_leftc_2;
 var bart1m2_leftb_2;
 var bart1m2_lefta_2;
 var mouse_6;
 var fixedt1m2_a1_2;
 var fixedt1m2_a2_2;
 var fixedt1m2_a3_2;
 var fixedt1m2_b1_2;
 var fixedt1m2_b2_2;
 var fixedt1m2_c1_2;
 var greent1m2_2;
 var redt1m2_2;
 var bluet1m2_2;
 var check_box;
 var text_154;
 var check_positionsClock;
 var End_2Clock;
 var thank_you_2;
 var end;
 var image_16;
 var globalClock;
 var routineTimer;
 function experimentInit() {
   // Initialize components for Routine "Welcome"
   WelcomeClock = new util.Clock();
   text_12 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_12',
     text: 'Welcome!',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.16,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   text_13 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_13',
     text: 'Press space bar to continue.',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   key_resp_8 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   x3 = expInfo["Enter participant ID"];
   console.log(x3)
   x2 = parseInt(x3.substr(-2));
   console.log(x2)
   x1 = parseInt(x2%5);
   console.log(x1)
   
   if (isNaN(x1)) {
     psychoJS.quit()
   } 
   
   end_experiment = 0;
   timer = new util.Clock();
   timer_exp = new util.Clock();
   beginning_exp = timer.getTime();
   beginning_exp2 = timer_exp.getTime();
   psychoJS.experiment.addData("Browser", myBrowser)
   // Initialize components for Routine "overal_ef_assessment_instructions"
   overal_ef_assessment_instructionsClock = new util.Clock();
   text_130 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_130',
     text: 'Today, you will complete five computer tasks. \nHowever, if you need to exit the session at any given moment, please press escape twice and wait until you see this popup window before you close the window browser.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.3], height: 0.05,  wrapWidth: 1.5, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   text_131 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_131',
     text: 'Press space bar to continue.',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   key_resp_57 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   image_29 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_29', units : undefined, 
     image : 'ef_math_saving_message.png', mask : undefined,
     ori : 0, pos : [0, (- 0.025)], size : [0.5, 0.25],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 512, interpolate : true, depth : -3.0 
   });
   // Initialize components for Routine "Introduction"
   IntroductionClock = new util.Clock();
   text_14 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_14',
     text: 'In this first task you will see a series of circles light up. \n\nYour job is to use the mouse to click on the circles in reverse order.',
     font: 'Arial',
     units: undefined, 
     pos: [0.0, 0.15], height: 0.05,  wrapWidth: 1.8, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   text_16 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_16',
     text: 'Press space bar to continue.',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   key_resp_9 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "Circles_Example_1"
   Circles_Example_1Clock = new util.Clock();
   init_circle = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   init_circle_17 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_17', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   init_circle_18 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_18', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   init_circle_19 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_19', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   init_circle_20 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_20', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   init_circle_21 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_21', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   init_circle_22 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_22', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   init_circle_23 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_23', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   init_circle_24 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_24', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   init_circle_25 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_25', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   init_circle_26 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_26', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   init_circle_27 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_27', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   init_circle_28 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_28', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   init_circle_29 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_29', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   init_circle_30 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_30', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   init_circle_31 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_31', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   For_example = new visual.TextStim({
     win: psychoJS.window,
     name: 'For_example',
     text: 'For example, if you saw the following sequence:',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.85], height: 0.1,  wrapWidth: 2, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -16.0 
   });
   
   // Initialize components for Routine "Circles_Example_2"
   Circles_Example_2Clock = new util.Clock();
   init_circle_32 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_32', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   init_circle_33 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_33', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   init_circle_34 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_34', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   C4_circle_lights_up = new visual.Polygon ({
     win: psychoJS.window, name: 'C4_circle_lights_up', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([1.0, 1.0, 1.0]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   init_circle_36 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_36', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   init_circle_37 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_37', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   init_circle_38 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_38', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   init_circle_39 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_39', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   init_circle_40 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_40', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   init_circle_41 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_41', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   init_circle_42 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_42', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   init_circle_43 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_43', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   init_circle_44 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_44', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   init_circle_45 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_45', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   init_circle_46 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_46', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   init_circle_47 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_47', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   For_example_2 = new visual.TextStim({
     win: psychoJS.window,
     name: 'For_example_2',
     text: 'For example, if you saw the following sequence:',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.85], height: 0.1,  wrapWidth: 2, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -16.0 
   });
   
   // Initialize components for Routine "Circles_Example_3"
   Circles_Example_3Clock = new util.Clock();
   init_circle_35 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_35', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   init_circle_48 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_48', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   init_circle_49 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_49', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   init_circle_63 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_63', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   init_circle_50 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_50', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   circle_6_lights_up = new visual.Polygon ({
     win: psychoJS.window, name: 'circle_6_lights_up', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([1.0, 1.0, 1.0]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   init_circle_52 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_52', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   init_circle_53 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_53', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   init_circle_54 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_54', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   init_circle_55 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_55', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   init_circle_56 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_56', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   init_circle_57 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_57', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   init_circle_58 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_58', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   init_circle_59 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_59', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   init_circle_60 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_60', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   init_circle_61 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_61', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   b_For_example_4 = new visual.TextStim({
     win: psychoJS.window,
     name: 'b_For_example_4',
     text: 'For example, if you saw the following sequence:',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.85], height: 0.1,  wrapWidth: 2, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -16.0 
   });
   
   // Initialize components for Routine "Circle_Example_4"
   Circle_Example_4Clock = new util.Clock();
   init_circle_51 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_51', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   init_circle_62 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_62', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   init_circle_64 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_64', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   init_circle_65 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_65', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   init_circle_66 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_66', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   init_circle_80 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_80', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   init_circle_67 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_67', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   init_circle_68 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_68', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   init_circle_69 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_69', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   init_circle_70 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_70', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   init_circle_71 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_71', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   init_circle_72 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_72', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   init_circle_73 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_73', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   init_circle_74 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_74', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   circle_15_lights_up = new visual.Polygon ({
     win: psychoJS.window, name: 'circle_15_lights_up', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([1.0, 1.0, 1.0]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   init_circle_76 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_76', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   For_example_5 = new visual.TextStim({
     win: psychoJS.window,
     name: 'For_example_5',
     text: 'For example, if you saw the following sequence:',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.85], height: 0.1,  wrapWidth: 2, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -16.0 
   });
   
   // Initialize components for Routine "Initial_Circles"
   Initial_CirclesClock = new util.Clock();
   init_circle_1 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   init_circle_2 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   init_circle_3 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   init_circle_4 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   init_circle_5 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   init_circle_6 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   init_circle_7 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   init_circle_8 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   init_circle_9 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   init_circle_10 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   init_circle_11 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   init_circle_12 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   init_circle_13 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   init_circle_14 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   init_circle_15 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   init_circle_16 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   // Initialize components for Routine "Circle_Example_5A"
   Circle_Example_5AClock = new util.Clock();
   first_response_C1_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C1_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   first_response_C2_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C2_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   first_response_C3_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C3_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   first_response_C4_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C4_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   first_response_C5_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C5_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   first_response_C6_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C6_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   first_response_C7_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C7_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   first_response_C8_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C8_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   first_response_C9_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C9_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   first_response_C10_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C10_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   first_response_C11_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C11_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   first_response_C12_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C12_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   first_response_C13_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C13_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   first_response_C14_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C14_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   first_response_C15_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C15_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   first_response_C16_example = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C16_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   first_mouse_response_example = new core.Mouse({
     win: psychoJS.window,
   });
   first_mouse_response_example.mouseClock = new util.Clock();
   polygon = new visual.ShapeStim ({
     win: psychoJS.window, name: 'polygon', units : 'height', 
     vertices: [[-[0.05, 0.05][0]/2.0, 0], [+[0.05, 0.05][0]/2.0, 0]],
     ori: 0, pos: [0.25, (- 0.3)],
     lineWidth: 4, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: -18, interpolate: true,
   });
   
   triangle = new visual.ShapeStim ({
     win: psychoJS.window, name: 'triangle', units : 'height', 
     vertices: [[-[0.02, 0.02][0]/2.0, -[0.02, 0.02][1]/2.0], [+[0.02, 0.02][0]/2.0, -[0.02, 0.02][1]/2.0], [0, [0.02, 0.02][1]/2.0]],
     ori: 90, pos: [0.23, (- 0.3)],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: -19, interpolate: true,
   });
   
   push_these_circles = new visual.TextStim({
     win: psychoJS.window,
     name: 'push_these_circles',
     text: 'You would click on the circles in this order:',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.85], height: 0.1,  wrapWidth: 2, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -20.0 
   });
   
   // Initialize components for Routine "Circle_Example_6"
   Circle_Example_6Clock = new util.Clock();
   second_response_C1_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C1_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   second_response_C2_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C2_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   second_response_C3_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C3_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   second_response_C4_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C4_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   second_response_C5_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C5_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   second_response_C6_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C6_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   second_response_C7_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C7_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   second_response_C8_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C8_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   second_response_C9_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C9_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   second_response_C10_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C10_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   second_response_C11_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C11_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   second_response_C12_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C12_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   second_response_C13_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C13_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   second_response_C14_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C14_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   second_response_C15_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C15_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   second_response_C16_example = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C16_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   second_mouse_response_example = new core.Mouse({
     win: psychoJS.window,
   });
   second_mouse_response_example.mouseClock = new util.Clock();
   polygon_2 = new visual.ShapeStim ({
     win: psychoJS.window, name: 'polygon_2', units : 'height', 
     vertices: [[-[0.05, 0.05][0]/2.0, 0], [+[0.05, 0.05][0]/2.0, 0]],
     ori: 0, pos: [(- 0.05), 0.1],
     lineWidth: 4, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: -18, interpolate: true,
   });
   
   triangle_2 = new visual.ShapeStim ({
     win: psychoJS.window, name: 'triangle_2', units : 'height', 
     vertices: [[-[0.02, 0.02][0]/2.0, -[0.02, 0.02][1]/2.0], [+[0.02, 0.02][0]/2.0, -[0.02, 0.02][1]/2.0], [0, [0.02, 0.02][1]/2.0]],
     ori: 90, pos: [(- 0.07), 0.1],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: -19, interpolate: true,
   });
   
   push_these_circles_2 = new visual.TextStim({
     win: psychoJS.window,
     name: 'push_these_circles_2',
     text: 'You would click on the circles in this order:',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.85], height: 0.1,  wrapWidth: 2, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -20.0 
   });
   
   // Initialize components for Routine "Circle_Example_7"
   Circle_Example_7Clock = new util.Clock();
   third_response_C1_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C1_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   third_response_C2_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C2_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   third_response_C3_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C3_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   third_response_C4_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C4_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   third_response_C5_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C5_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   third_response_C6_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C6_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   third_response_C7_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C7_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   third_response_C8_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C8_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   third_response_C9_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C9_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   third_response_C10_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C10_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   third_response_C11_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C11_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   third_response_C12_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C12_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   third_response_C13_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C13_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   third_response_C14_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C14_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   third_response_C15_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C15_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   third_response_C16_example = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C16_example', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   third_mouse_response_example = new core.Mouse({
     win: psychoJS.window,
   });
   third_mouse_response_example.mouseClock = new util.Clock();
   polygon_3 = new visual.ShapeStim ({
     win: psychoJS.window, name: 'polygon_3', units : 'height', 
     vertices: [[-[0.05, 0.05][0]/2.0, 0], [+[0.05, 0.05][0]/2.0, 0]],
     ori: 0, pos: [0.55, 0.3],
     lineWidth: 4, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: -18, interpolate: true,
   });
   
   triangle_3 = new visual.ShapeStim ({
     win: psychoJS.window, name: 'triangle_3', units : 'height', 
     vertices: [[-[0.02, 0.02][0]/2.0, -[0.02, 0.02][1]/2.0], [+[0.02, 0.02][0]/2.0, -[0.02, 0.02][1]/2.0], [0, [0.02, 0.02][1]/2.0]],
     ori: 90, pos: [0.53, 0.3],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: -19, interpolate: true,
   });
   
   push_these_circles_3 = new visual.TextStim({
     win: psychoJS.window,
     name: 'push_these_circles_3',
     text: 'You would click on the circles in this order:',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.85], height: 0.1,  wrapWidth: 2, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -20.0 
   });
   
   // Initialize components for Routine "Start_Practice"
   Start_PracticeClock = new util.Clock();
   practice_text = new visual.TextStim({
     win: psychoJS.window,
     name: 'practice_text',
     text: "You'll first do a short practice.",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: 1.8, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   spacebar_text = new visual.TextStim({
     win: psychoJS.window,
     name: 'spacebar_text',
     text: 'Click the mouse to continue.',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: 1.8, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   mouse = new core.Mouse({
     win: psychoJS.window,
   });
   mouse.mouseClock = new util.Clock();
   // Initialize components for Routine "Update_loop"
   Update_loopClock = new util.Clock();
   circle_loop = 0;
   
   // Initialize components for Routine "Check_practice_over"
   Check_practice_overClock = new util.Clock();
   text_3 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_3',
     text: "You'll now start the game. ",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: 1.8, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   mouse_2 = new core.Mouse({
     win: psychoJS.window,
   });
   mouse_2.mouseClock = new util.Clock();
   mouse_click_text = new visual.TextStim({
     win: psychoJS.window,
     name: 'mouse_click_text',
     text: 'Click the mouse to continue.',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: 1.8, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -3.0 
   });
   
   // Initialize components for Routine "check_first_round_practice"
   check_first_round_practiceClock = new util.Clock();
   // Initialize components for Routine "Initial_Circles"
   Initial_CirclesClock = new util.Clock();
   init_circle_1 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   init_circle_2 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   init_circle_3 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   init_circle_4 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   init_circle_5 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   init_circle_6 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   init_circle_7 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   init_circle_8 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   init_circle_9 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   init_circle_10 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   init_circle_11 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   init_circle_12 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   init_circle_13 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   init_circle_14 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   init_circle_15 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   init_circle_16 = new visual.Polygon ({
     win: psychoJS.window, name: 'init_circle_16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   // Initialize components for Routine "First_Circle_Presentation"
   First_Circle_PresentationClock = new util.Clock();
   first_circle_pres_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   first_circle_pres_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   first_circle_pres_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   first_circle_pres_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   first_circle_pres_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   first_circle_pres_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   first_circle_pres_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   first_circle_pres_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   first_circle_pres_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   first_circle_pres_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   first_circle_pres_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   first_circle_pres_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   first_circle_pres_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   first_circle_pres_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   first_circle_pres_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   first_circle_pres_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_circle_pres_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   // Initialize components for Routine "Second_Circle_Presentation"
   Second_Circle_PresentationClock = new util.Clock();
   second_circle_pres_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   second_circle_pres_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   second_circle_pres_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   second_circle_pres_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   second_circle_pres_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   second_circle_pres_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   second_circle_pres_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   second_circle_pres_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   second_circle_pres_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   second_circle_pres_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   second_circle_pres_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   second_circle_pres_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   second_circle_pres_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   second_circle_pres_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   second_circle_pres_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   second_circle_pres_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_circle_pres_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   // Initialize components for Routine "Third_Circle_Presentation"
   Third_Circle_PresentationClock = new util.Clock();
   third_circle_pres_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   third_circle_pres_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   third_circle_pres_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   third_circle_pres_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   third_circle_pres_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   third_circle_pres_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   third_circle_pres_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   third_circle_pres_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   third_circle_pres_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   third_circle_pres_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   third_circle_pres_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   third_circle_pres_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   third_circle_pres_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   third_circle_pres_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   third_circle_pres_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   third_circle_pres_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_circle_pres_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   // Initialize components for Routine "Fourth_Circle_Presentation"
   Fourth_Circle_PresentationClock = new util.Clock();
   fourth_circle_pres_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   fourth_circle_pres_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   fourth_circle_pres_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   fourth_circle_pres_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   fourth_circle_pres_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   fourth_circle_pres_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   fourth_circle_pres_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   fourth_circle_pres_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   fourth_circle_pres_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   fourth_circle_pres_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   fourth_circle_pres_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   fourth_circle_pres_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   fourth_circle_pres_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   fourth_circle_pres_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   fourth_circle_pres_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   fourth_circle_pres_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_circle_pres_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -16, interpolate: true,
   });
   
   // Initialize components for Routine "Fifth_Circle_Presentation"
   Fifth_Circle_PresentationClock = new util.Clock();
   fifth_circle_pres_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   fifth_circle_pres_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   fifth_circle_pres_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   fifth_circle_pres_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   fifth_circle_pres_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   fifth_circle_pres_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   fifth_circle_pres_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   fifth_circle_pres_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   fifth_circle_pres_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   fifth_circle_pres_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   fifth_circle_pres_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   fifth_circle_pres_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   fifth_circle_pres_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   fifth_circle_pres_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   fifth_circle_pres_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   fifth_circle_pres_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_circle_pres_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -16, interpolate: true,
   });
   
   // Initialize components for Routine "Sixth_Circle_Presentation"
   Sixth_Circle_PresentationClock = new util.Clock();
   sixth_circle_pres_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   sixth_circle_pres_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   sixth_circle_pres_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   sixth_circle_pres_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   sixth_circle_pres_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   sixth_circle_pres_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   sixth_circle_pres_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   sixth_circle_pres_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   sixth_circle_pres_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   sixth_circle_pres_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   sixth_circle_pres_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   sixth_circle_pres_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   sixth_circle_pres_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   sixth_circle_pres_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   sixth_circle_pres_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   sixth_circle_pres_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_circle_pres_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -16, interpolate: true,
   });
   
   // Initialize components for Routine "Seventh_Circle_Presentation"
   Seventh_Circle_PresentationClock = new util.Clock();
   seventh_circle_pres_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   seventh_circle_pres_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   seventh_circle_pres_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   seventh_circle_pres_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   seventh_circle_pres_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   seventh_circle_pres_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   seventh_circle_pres_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   seventh_circle_pres_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   seventh_circle_pres_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   seventh_circle_pres_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   seventh_circle_pres_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   seventh_circle_pres_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   seventh_circle_pres_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   seventh_circle_pres_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   seventh_circle_pres_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   seventh_circle_pres_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_circle_pres_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -16, interpolate: true,
   });
   
   // Initialize components for Routine "Eighth_Circle_Presentation"
   Eighth_Circle_PresentationClock = new util.Clock();
   eighth_circle_pres_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   eighth_circle_pres_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   eighth_circle_pres_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   eighth_circle_pres_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   eighth_circle_pres_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   eighth_circle_pres_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   eighth_circle_pres_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   eighth_circle_pres_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   eighth_circle_pres_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   eighth_circle_pres_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   eighth_circle_pres_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   eighth_circle_pres_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   eighth_circle_pres_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   eighth_circle_pres_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   eighth_circle_pres_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   eighth_circle_pres_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_circle_pres_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color(1.0),
     fillColor: new util.Color(1.0),
     opacity: 1, depth: -16, interpolate: true,
   });
   
   // Initialize components for Routine "Wait_for_First_response"
   Wait_for_First_responseClock = new util.Clock();
   first_response_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   first_response_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   first_response_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   first_response_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   first_response_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   first_response_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   first_response_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   first_response_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   first_response_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   first_response_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   first_response_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   first_response_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   first_response_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   first_response_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   first_response_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   first_response_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'first_response_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   first_mouse_response = new core.Mouse({
     win: psychoJS.window,
   });
   first_mouse_response.mouseClock = new util.Clock();
   // Initialize components for Routine "Wait_for_Second_response"
   Wait_for_Second_responseClock = new util.Clock();
   second_response_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   second_response_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   second_response_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   second_response_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   second_response_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   second_response_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   second_response_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   second_response_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   second_response_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   second_response_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   second_response_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   second_response_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   second_response_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   second_response_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   second_response_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   second_response_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'second_response_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   second_mouse_response = new core.Mouse({
     win: psychoJS.window,
   });
   second_mouse_response.mouseClock = new util.Clock();
   // Initialize components for Routine "Wait_for_Third_Response"
   Wait_for_Third_ResponseClock = new util.Clock();
   third_response_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   third_response_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   third_response_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   third_response_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   third_response_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   third_response_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   third_response_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   third_response_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   third_response_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   third_response_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   third_response_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   third_response_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   third_response_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   third_response_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   third_response_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   third_response_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'third_response_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   third_mouse_response = new core.Mouse({
     win: psychoJS.window,
   });
   third_mouse_response.mouseClock = new util.Clock();
   // Initialize components for Routine "Wait_for_Fourth_Response"
   Wait_for_Fourth_ResponseClock = new util.Clock();
   fourth_response_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   fourth_response_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   fourth_response_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   fourth_response_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   fourth_response_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   fourth_response_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   fourth_response_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   fourth_response_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   fourth_response_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   fourth_response_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   fourth_response_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   fourth_response_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   fourth_response_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   fourth_response_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   fourth_response_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   fourth_response_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'fourth_response_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -16, interpolate: true,
   });
   
   fourth_mouse_response = new core.Mouse({
     win: psychoJS.window,
   });
   fourth_mouse_response.mouseClock = new util.Clock();
   // Initialize components for Routine "Wait_for_Fifth_Response"
   Wait_for_Fifth_ResponseClock = new util.Clock();
   fifth_response_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   fifth_response_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   fifth_response_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   fifth_response_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   fifth_response_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   fifth_response_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   fifth_response_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   fifth_response_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   fifth_response_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   fifth_response_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   fifth_response_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   fifth_response_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   fifth_response_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   fifth_response_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   fifth_response_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   fifth_response_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'fifth_response_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -16, interpolate: true,
   });
   
   fifth_mouse_response = new core.Mouse({
     win: psychoJS.window,
   });
   fifth_mouse_response.mouseClock = new util.Clock();
   // Initialize components for Routine "Wait_For_Sixth_Response"
   Wait_For_Sixth_ResponseClock = new util.Clock();
   sixth_response_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   sixth_response_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   sixth_response_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   sixth_response_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   sixth_response_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   sixth_response_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   sixth_response_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   sixth_response_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   sixth_response_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   sixth_response_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   sixth_response_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   sixth_response_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   sixth_response_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   sixth_response_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   sixth_response_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   sixth_response_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'sixth_response_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -16, interpolate: true,
   });
   
   sixth_mouse_response = new core.Mouse({
     win: psychoJS.window,
   });
   sixth_mouse_response.mouseClock = new util.Clock();
   // Initialize components for Routine "Wait_For_Seventh_Response"
   Wait_For_Seventh_ResponseClock = new util.Clock();
   seventh_response_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   seventh_response_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   seventh_response_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   seventh_response_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   seventh_response_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   seventh_response_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   seventh_response_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   seventh_response_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   seventh_response_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   seventh_response_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   seventh_response_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   seventh_response_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   seventh_response_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   seventh_response_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   seventh_response_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   seventh_response_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'seventh_response_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -16, interpolate: true,
   });
   
   seventh_mouse_response = new core.Mouse({
     win: psychoJS.window,
   });
   seventh_mouse_response.mouseClock = new util.Clock();
   // Initialize components for Routine "Wait_For_Eighth_Response"
   Wait_For_Eighth_ResponseClock = new util.Clock();
   eighth_response_C1 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C1', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   eighth_response_C2 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C2', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   eighth_response_C3 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C3', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   eighth_response_C4 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C4', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.3],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   eighth_response_C5 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C5', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   eighth_response_C6 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C6', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   eighth_response_C7 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C7', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   eighth_response_C8 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C8', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, 0.1],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   eighth_response_C9 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C9', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   eighth_response_C10 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C10', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   eighth_response_C11 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C11', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   eighth_response_C12 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C12', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.1)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   eighth_response_C13 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C13', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.45), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   eighth_response_C14 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C14', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [(- 0.15), (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   eighth_response_C15 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C15', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.15, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   eighth_response_C16 = new visual.Polygon ({
     win: psychoJS.window, name: 'eighth_response_C16', units : 'height', 
     edges: 90, size:[0.11, 0.11],
     ori: 0, pos: [0.45, (- 0.3)],
     lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
     fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
     opacity: 1, depth: -16, interpolate: true,
   });
   
   eighth_mouse_response = new core.Mouse({
     win: psychoJS.window,
   });
   eighth_mouse_response.mouseClock = new util.Clock();
   // Initialize components for Routine "Check_outcome"
   Check_outcomeClock = new util.Clock();
   corr = 0;
   // Initialize components for Routine "Blank_Screen"
   Blank_ScreenClock = new util.Clock();
   text = new visual.TextStim({
     win: psychoJS.window,
     name: 'text',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   // Initialize components for Routine "feedback"
   feedbackClock = new util.Clock();
   text_4 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_4',
     text: 'default text',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   msg = '';
   // Initialize components for Routine "Repeat_Instructions"
   Repeat_InstructionsClock = new util.Clock();
   repeat_inst = new visual.TextStim({
     win: psychoJS.window,
     name: 'repeat_inst',
     text: 'Remember!\nYour job is to use the mouse to click on the circles in reverse order.\n',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_5 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_5',
     text: 'Press space bar to continue.',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -3.0 
   });
   
   // Initialize components for Routine "check_end_experiment"
   check_end_experimentClock = new util.Clock();
   end_experiment = 0;
   
   // Initialize components for Routine "Get_Experimenter"
   Get_ExperimenterClock = new util.Clock();
   text_11 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_11',
     text: 'Thank you! This is the end of this task',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   b_text_15 = new visual.TextStim({
     win: psychoJS.window,
     name: 'b_text_15',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: 0.8, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   // Initialize components for Routine "Instructions"
   InstructionsClock = new util.Clock();
   instructions = new visual.TextStim({
     win: psychoJS.window,
     name: 'instructions',
     text: 'In the second task, you will try to remember a sequence of numbers that appears on the screen one after the other. \n\nWhen you see the "Recall" screen, type the numbers you saw in the opposite order you saw them. Use the number keys at the top of the keyboard.\n\nBe careful with your typing, as if you make a mistake, you will not be able to correct it. Press ENTER to confirm your answer.\n\nDo your best to memorize the numbers, and do not write them down or use any other tool to help you remember them.\n\nPress space bar to continue',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   key_resp_2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   trial_counter = 0;
   condition_counter = 0;
   // Initialize components for Routine "get_ready"
   get_readyClock = new util.Clock();
   text_6 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_6',
     text: 'Lets practice!\nWhen you the square, it means that the task is about to start.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   key_resp_3 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_7 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_7',
     text: 'Press space bar to continue',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.3)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -2.0 
   });
   
   // Initialize components for Routine "code_meta"
   code_metaClock = new util.Clock();
   // Initialize components for Routine "Presentation_practice"
   Presentation_practiceClock = new util.Clock();
   fixation_2 = new visual.TextStim({
     win: psychoJS.window,
     name: 'fixation_2',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   pres_text_2 = new visual.TextStim({
     win: psychoJS.window,
     name: 'pres_text_2',
     text: 'a',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   // Initialize components for Routine "Recall_practice"
   Recall_practiceClock = new util.Clock();
   recall_text_2 = new visual.TextStim({
     win: psychoJS.window,
     name: 'recall_text_2',
     text: 'Recall',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.25], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   key_resp_4 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Store responses
   allResponses_p = []
   current_resp = '';
   pts_response_2 = new visual.TextStim({
     win: psychoJS.window,
     name: 'pts_response_2',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -3.0 
   });
   
   // Initialize components for Routine "feedback_practice"
   feedback_practiceClock = new util.Clock();
   text_8 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_8',
     text: 'default text',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   // Initialize components for Routine "code_end"
   code_endClock = new util.Clock();
   // Initialize components for Routine "repeat_instructions"
   repeat_instructionsClock = new util.Clock();
   text_9 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_9',
     text: 'Remember that your job is to type the numbers you saw in the opposite order you saw them',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   key_resp_6 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_10 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_10',
     text: 'Press space bar to continue',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -3.0 
   });
   
   // Initialize components for Routine "real_trials"
   real_trialsClock = new util.Clock();
   get_ready_real_trial = new visual.TextStim({
     win: psychoJS.window,
     name: 'get_ready_real_trial',
     text: 'Great! Lets start the real task',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   press_space = new visual.TextStim({
     win: psychoJS.window,
     name: 'press_space',
     text: 'Press space bar to continue',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   key_resp_5 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "Presentation"
   PresentationClock = new util.Clock();
   fixation = new visual.TextStim({
     win: psychoJS.window,
     name: 'fixation',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   pres_text = new visual.TextStim({
     win: psychoJS.window,
     name: 'pres_text',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   // Initialize components for Routine "Recall"
   RecallClock = new util.Clock();
   recall_text = new visual.TextStim({
     win: psychoJS.window,
     name: 'recall_text',
     text: 'Recall',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.25], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   key_resp_7 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Store responses
   allResponses = []
   current_resp = ' ';
   pts_response = new visual.TextStim({
     win: psychoJS.window,
     name: 'pts_response',
     text: ' ',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -3.0 
   });
   
   // Initialize components for Routine "Feedback"
   FeedbackClock = new util.Clock();
   // Initialize components for Routine "End"
   EndClock = new util.Clock();
   thank_you = new visual.TextStim({
     win: psychoJS.window,
     name: 'thank_you',
     text: 'Thank you! This is the end of this task.\n',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   before_closing = new visual.TextStim({
     win: psychoJS.window,
     name: 'before_closing',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.3)], height: 0.04,  wrapWidth: 0.8, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   // Initialize components for Routine "Welcome_2"
   Welcome_2Clock = new util.Clock();
   white_background_10 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_10', 
     width: [3, 3][0], height: [3, 3][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_15 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_15',
     text: 'Welcome!',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_17 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_17',
     text: "Please press 'spacebar' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   key_resp_10 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "IntroA_2"
   IntroA_2Clock = new util.Clock();
   white_background_25 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_25', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   image_11 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_11', units : undefined, 
     image : 'heart_only.jpg', mask : undefined,
     ori : 0, pos : [0, (- 0.0)], size : [0.4, 0.4],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 256, interpolate : false, depth : -1.0 
   });
   text_40 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_40',
     text: 'In the third task, you will see hearts.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.3], height: 0.0825,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   text_46 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_46',
     text: "Press 'spacebar' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -3.0 
   });
   
   key_resp_27 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "IntroB_2"
   IntroB_2Clock = new util.Clock();
   white_background_21 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_21', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_52 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_52',
     text: "Your job will be to press the button on the SAME side as where the heart appears.\n\n\nIf the heart appears on the right, press 'm,' and if the heart appears on the left, press 'z.'",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_53 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_53',
     text: "Press 'spacebar' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   key_resp_28 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "Example1"
   Example1Clock = new util.Clock();
   white_background_14 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_14', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_18 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_18',
     text: 'In this example, the heart is on the right.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   image_3 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_3', units : undefined, 
     image : 'rightHeart.jpg', mask : undefined,
     ori : 0, pos : [0, (- 0.0)], size : [0.8, 0.3],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -2.0 
   });
   key_resp_11 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_60 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_60',
     text: "Press 'm'",
     font: 'Arial',
     units: undefined, 
     pos: [0.4, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -4.0 
   });
   
   // Initialize components for Routine "Example2"
   Example2Clock = new util.Clock();
   white_background_12 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_12', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_19 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_19',
     text: 'In this example, the heart is on the left.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   image_4 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_4', units : undefined, 
     image : 'leftHeart.jpg', mask : undefined,
     ori : 0, pos : [0, (- 0.0)], size : [0.8, 0.3],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -2.0 
   });
   key_resp_12 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_61 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_61',
     text: "Press 'z'",
     font: 'Arial',
     units: undefined, 
     pos: [(- 0.4), (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -4.0 
   });
   
   // Initialize components for Routine "Quick_Reminder"
   Quick_ReminderClock = new util.Clock();
   white_background_19 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_19', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_71 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_71',
     text: 'The hearts will appear very quickly. \nTry to be as fast as you can and try your \nbest!',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   key_resp_32 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_72 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_72',
     text: "Press 'z' or 'm' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -3.0 
   });
   
   // Initialize components for Routine "Practice_congruent"
   Practice_congruentClock = new util.Clock();
   white_background_7 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_7', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_20 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_20',
     text: "Let's practice!\n",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_21 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_21',
     text: "Press 'z' or 'm' to continue. ",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   key_resp_13 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "Practice_trial_congruent"
   Practice_trial_congruentClock = new util.Clock();
   white_background_17 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_17', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_22 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_22',
     text: '+',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_64 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_64',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -2.0 
   });
   
   image_5 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_5', units : undefined, 
     image : undefined, mask : undefined,
     ori : 0, pos : [0, 0], size : [0.8, 0.3],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -3.0 
   });
   text_28 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_28',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -4.0 
   });
   
   key_resp_14 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "feedback_hf_congruent_1"
   feedback_hf_congruent_1Clock = new util.Clock();
   white_background_33 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_33', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_108 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_108',
     text: 'default text',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   // Initialize components for Routine "congruent_reminder"
   congruent_reminderClock = new util.Clock();
   white_background_41 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_41', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_102 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_102',
     text: "Remember! Your job is to press the button on the SAME side as where the heart appears.\n\nIf the heart appears on the right, press 'm,' and if the heart appears on the left, press 'z.'",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_103 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_103',
     text: "Press 'spacebar' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   key_resp_37 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   var eachResp;
   eachResp=0;
   // Initialize components for Routine "Practice_trial_congruent_2"
   Practice_trial_congruent_2Clock = new util.Clock();
   white_background_32 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_32', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_93 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_93',
     text: '+',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_94 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_94',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -2.0 
   });
   
   image_13 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_13', units : undefined, 
     image : undefined, mask : undefined,
     ori : 0, pos : [0, 0], size : [0.8, 0.3],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -3.0 
   });
   text_95 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_95',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -4.0 
   });
   
   key_resp_21 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "feedback_hf_congruent_2"
   feedback_hf_congruent_2Clock = new util.Clock();
   white_background_34 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_34', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_114 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_114',
     text: 'default text',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   // Initialize components for Routine "Ready"
   ReadyClock = new util.Clock();
   white_background_30 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_30', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_29 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_29',
     text: "Let's play for real now.\n\n\nRemember, when the heart appears on the left, press 'z' and when the heart appears on the right, press 'm.'",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   key_resp_15 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_30 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_30',
     text: "Press 'z' or 'm' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -3.0 
   });
   
   // Initialize components for Routine "Hearts"
   HeartsClock = new util.Clock();
   white_background_6 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_6', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_23 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_23',
     text: '+',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_65 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_65',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -2.0 
   });
   
   hearts = new visual.ImageStim({
     win : psychoJS.window,
     name : 'hearts', units : undefined, 
     image : undefined, mask : undefined,
     ori : 0, pos : [0, 0], size : [0.8, 0.3],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -3.0 
   });
   text_31 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_31',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -4.0 
   });
   
   heart_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "IntroA_3"
   IntroA_3Clock = new util.Clock();
   white_background_26 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_26', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_32 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_32',
     text: 'Great job! In this next task, you will see flowers.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.3], height: 0.0825,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   key_resp_16 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_33 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_33',
     text: "Press 'spacebar' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -3.0 
   });
   
   image_12 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_12', units : undefined, 
     image : 'flower_only.jpg', mask : undefined,
     ori : 0, pos : [0, 0], size : [0.4, 0.4],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -4.0 
   });
   // Initialize components for Routine "IntroB_3"
   IntroB_3Clock = new util.Clock();
   white_background_20 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_20', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_47 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_47',
     text: "Your job will be to press the button on the OPPOSITE side of where the flower appears.\n\n\nIf the flower appears on the right, press 'z,' and if the flower appears on the left, press 'm.'",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_34 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_34',
     text: "Press 'spacebar' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   key_resp_17 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "Example3"
   Example3Clock = new util.Clock();
   white_background_13 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_13', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_35 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_35',
     text: 'In this example, the flower is on the right.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   image_6 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_6', units : undefined, 
     image : 'rightFlower.jpg', mask : undefined,
     ori : 0, pos : [0, 0], size : [0.8, 0.3],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -2.0 
   });
   key_resp_18 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_62 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_62',
     text: "Press 'z'",
     font: 'Arial',
     units: undefined, 
     pos: [(- 0.4), (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -4.0 
   });
   
   // Initialize components for Routine "Example4"
   Example4Clock = new util.Clock();
   white_background_11 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_11', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_36 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_36',
     text: 'In this example, the flower is on the left.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   image_7 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_7', units : undefined, 
     image : 'leftFlower.jpg', mask : undefined,
     ori : 0, pos : [0, 0], size : [0.8, 0.3],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -2.0 
   });
   key_resp_19 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_63 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_63',
     text: "Press 'm'",
     font: 'Arial',
     units: undefined, 
     pos: [0.4, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -4.0 
   });
   
   // Initialize components for Routine "Quick_Reminder_Incongruent"
   Quick_Reminder_IncongruentClock = new util.Clock();
   white_background_28 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_28', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_75 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_75',
     text: 'The flowers will appear very quickly. \nTry to be as fast as you can and try your best!',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   key_resp_34 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_76 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_76',
     text: "Press 'z' or 'm' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -3.0 
   });
   
   // Initialize components for Routine "Practice_Incongruent"
   Practice_IncongruentClock = new util.Clock();
   white_background_8 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_8', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_37 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_37',
     text: "Let's practice!\n",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_38 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_38',
     text: "Press 'z' or 'm' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   key_resp_20 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "Practice_trial_incongruent"
   Practice_trial_incongruentClock = new util.Clock();
   white_background_22 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_22', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_39 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_39',
     text: '+',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_66 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_66',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -2.0 
   });
   
   image_8 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_8', units : undefined, 
     image : undefined, mask : undefined,
     ori : 0, pos : [0, 0], size : [0.8, 0.3],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -3.0 
   });
   text_48 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_48',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -4.0 
   });
   
   key_resp_22 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "feedback_hf_incongruent_1"
   feedback_hf_incongruent_1Clock = new util.Clock();
   white_background_38 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_38', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_113 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_113',
     text: 'default text',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   // Initialize components for Routine "incongruent_reminder"
   incongruent_reminderClock = new util.Clock();
   white_background_42 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_42', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_104 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_104',
     text: "Remember! Your job is to press the button on the OPPOSITE side of where the flower appears.\n\nIf the flower appears on the right, press 'z,' and if the flower appears on the left, press 'm.'",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_105 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_105',
     text: "Press 'spacebar' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   key_resp_38 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   var nCorrhf02;
   // Initialize components for Routine "Practice_trial_incongruent_2"
   Practice_trial_incongruent_2Clock = new util.Clock();
   white_background_35 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_35', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_96 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_96',
     text: '+',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_97 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_97',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -2.0 
   });
   
   image_14 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_14', units : undefined, 
     image : undefined, mask : undefined,
     ori : 0, pos : [0, 0], size : [0.8, 0.3],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -3.0 
   });
   text_98 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_98',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -4.0 
   });
   
   key_resp_23 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "feedback_hf_incongruent_2"
   feedback_hf_incongruent_2Clock = new util.Clock();
   white_background_37 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_37', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_112 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_112',
     text: 'default text',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   // Initialize components for Routine "Ready2"
   Ready2Clock = new util.Clock();
   white_background_3 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_3', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_49 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_49',
     text: "Let's play for real now. \n\n\nRemember, when the flower appears on the left, press 'm,' and when the flower appears on the right, press 'z.'",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_50 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_50',
     text: "Press 'z' or 'm' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.25)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   key_resp_24 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "Flowers"
   FlowersClock = new util.Clock();
   white_background_16 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_16', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_51 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_51',
     text: '+',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_67 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_67',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -2.0 
   });
   
   image = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image', units : undefined, 
     image : undefined, mask : undefined,
     ori : 0, pos : [0, 0], size : [0.8, 0.3],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -3.0 
   });
   text_54 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_54',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -4.0 
   });
   
   key_resp_25 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "IntroA_4"
   IntroA_4Clock = new util.Clock();
   white_background_27 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_27', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_55 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_55',
     text: "Great job! \nNow in this last task, we'll put it all together.",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.0825,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   key_resp_26 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_56 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_56',
     text: "Press 'spacebar' to continue.\n",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -3.0 
   });
   
   // Initialize components for Routine "IntroB_5"
   IntroB_5Clock = new util.Clock();
   white_background_18 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_18', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_57 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_57',
     text: "In this next task, you'll see both hearts and flowers. ",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_58 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_58',
     text: "Press 'spacebar' to continue. ",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   key_resp_29 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "IntroC_11"
   IntroC_11Clock = new util.Clock();
   white_background_23 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_23', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_69 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_69',
     text: "If you see a heart, press the button on the SAME side as the heart appears. \n\n\nIf the heart appears on the right, press 'm,' and if the heart appears on the left, press 'z.'",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_70 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_70',
     text: "Press 'spacebar' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   key_resp_31 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "IntroC_2"
   IntroC_2Clock = new util.Clock();
   white_background_24 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_24', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_73 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_73',
     text: "If you see a flower, press the button on the OPPOSITE side of where the flower appears. \n\n\nIf the flower appears on the right, press 'z,' and if the flower appears on the left, press 'm.'",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_74 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_74',
     text: 'default text',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   key_resp_30 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "Quick_Reminder_Mixed"
   Quick_Reminder_MixedClock = new util.Clock();
   white_background_29 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_29', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_77 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_77',
     text: 'Remember, try to be as fast and accurate as you can.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   key_resp_33 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_78 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_78',
     text: "Press 'z' or 'm' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -3.0 
   });
   
   // Initialize components for Routine "Practice_mixed"
   Practice_mixedClock = new util.Clock();
   white_background_2 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_2', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_79 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_79',
     text: "Let's practice!",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   key_resp_35 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_80 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_80',
     text: "Press 'z' or 'm' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -3.0 
   });
   
   // Initialize components for Routine "Practice_trial_mixed"
   Practice_trial_mixedClock = new util.Clock();
   white_background_15 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_15', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_81 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_81',
     text: '+',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_82 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_82',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -2.0 
   });
   
   image_9 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_9', units : undefined, 
     image : undefined, mask : undefined,
     ori : 0, pos : [0, 0], size : [0.8, 0.3],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -3.0 
   });
   text_83 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_83',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -4.0 
   });
   
   key_resp_36 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "feedback_hf_mixed_1"
   feedback_hf_mixed_1Clock = new util.Clock();
   white_background_39 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_39', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_110 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_110',
     text: 'default text',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   // Initialize components for Routine "reminder_mixed"
   reminder_mixedClock = new util.Clock();
   white_background_43 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_43', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_106 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_106',
     text: 'Remember! If you see a heart, press the button on the SAME side as the heart appears. \n\nIf you see a flower, press the button on the OPPOSITE side of where the flower appears. ',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_107 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_107',
     text: "Press 'spacebar' to continue.",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   key_resp_39 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   var nCorrhf03;
   // Initialize components for Routine "Practice_trial_mixed_2"
   Practice_trial_mixed_2Clock = new util.Clock();
   white_background_36 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_36', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_99 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_99',
     text: '+',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_100 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_100',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -2.0 
   });
   
   image_15 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_15', units : undefined, 
     image : undefined, mask : undefined,
     ori : 0, pos : [0, 0], size : [0.8, 0.3],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -3.0 
   });
   text_101 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_101',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -4.0 
   });
   
   key_resp_40 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "feedback_hf_mixed_2"
   feedback_hf_mixed_2Clock = new util.Clock();
   white_background_40 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_40', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_109 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_109',
     text: 'default text',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   // Initialize components for Routine "Ready3"
   Ready3Clock = new util.Clock();
   white_background_4 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_4', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_84 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_84',
     text: "Let's play for real now. \n\n\nRemember, press the button on the SAME side as the heart.\n\n\nAnd press the button on the OPPOSITE side of the flower.",
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   key_resp_41 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_85 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_85',
     text: "Press 'z' or 'm' to continue. ",
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -3.0 
   });
   
   // Initialize components for Routine "mixed_first"
   mixed_firstClock = new util.Clock();
   white_background_9 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_9', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_86 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_86',
     text: '+',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   text_87 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_87',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -2.0 
   });
   
   image_10 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_10', units : undefined, 
     image : 'rightHeart.jpg', mask : undefined,
     ori : 0, pos : [0, 0], size : [0.8, 0.3],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -3.0 
   });
   text_88 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_88',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -4.0 
   });
   
   key_resp_42 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "Mixed"
   MixedClock = new util.Clock();
   white_background_5 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_5', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_89 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_89',
     text: '+',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_90 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_90',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -2.0 
   });
   
   image_2 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_2', units : undefined, 
     image : undefined, mask : undefined,
     ori : 0, pos : [0, 0], size : [0.8, 0.3],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : false, depth : -3.0 
   });
   text_91 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_91',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -4.0 
   });
   
   key_resp_43 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "Thank_You"
   Thank_YouClock = new util.Clock();
   white_background_31 = new visual.Rect ({
     win: psychoJS.window, name: 'white_background_31', 
     width: [2, 2][0], height: [2, 2][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_92 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_92',
     text: 'Great! This is the end of this task',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   text_111 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_111',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: 0.8, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   // Initialize components for Routine "welcome"
   welcomeClock = new util.Clock();
   text_122 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_122',
     text: 'Welcome!',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: undefined,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   text_123 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_123',
     text: 'Press space bar to continue',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   key_resp_52 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "Instructions_3"
   Instructions_3Clock = new util.Clock();
   instructions_2 = new visual.TextStim({
     win: psychoJS.window,
     name: 'instructions_2',
     text: 'The fourth task is an unusual one. Instead of telling you the rules, you have to figure them out.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   key_resp_53 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_124 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_124',
     text: 'Press space bar to continue',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -2.0 
   });
   
   // Initialize components for Routine "Example"
   ExampleClock = new util.Clock();
   example_text = new visual.TextStim({
     win: psychoJS.window,
     name: 'example_text',
     text: 'You will see a screen like this:',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.4], height: 0.04,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   example = new visual.ImageStim({
     win : psychoJS.window,
     name : 'example', units : undefined, 
     image : 'example.jpg', mask : undefined,
     ori : 0, pos : [0, 0.15], size : [0.7, 0.4],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : true, depth : -1.0 
   });
   example_text_2 = new visual.TextStim({
     win: psychoJS.window,
     name: 'example_text_2',
     text: 'Your job is to click on one of the four cards at the top you think is related to the one presented in the middle of the screen.  You will receive feedback on each trial. If you choose the right card, you will see a message saying correct. If you choose the incorrect one, you will see a message saying incorrect.\nPress space bar to continue.',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.25)], height: 0.04,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -2.0 
   });
   
   key_resp_54 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "lets_practice"
   lets_practiceClock = new util.Clock();
   text_125 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_125',
     text: 'Lets practice',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   key_resp_55 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   text_126 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_126',
     text: 'Press space bar continue',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -2.0 
   });
   
   // Initialize components for Routine "trials_practice_2"
   trials_practice_2Clock = new util.Clock();
   fixation_4 = new visual.TextStim({
     win: psychoJS.window,
     name: 'fixation_4',
     text: '+',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   one_red_dot_2 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'one_red_dot_2', units : undefined, 
     image : 'images/one_red_dot.jpg', mask : undefined,
     ori : 0, pos : [(- 0.45), 0.25], size : [0.25, 0.25],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : true, depth : -1.0 
   });
   two_yellow_triangles_2 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'two_yellow_triangles_2', units : undefined, 
     image : 'images/two_yellow_triangles.jpg', mask : undefined,
     ori : 0, pos : [(- 0.15), 0.25], size : [0.25, 0.25],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : true, depth : -2.0 
   });
   three_green_crosses_2 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'three_green_crosses_2', units : undefined, 
     image : 'images/three_green_crosses.jpg', mask : undefined,
     ori : 0, pos : [0.15, 0.25], size : [0.25, 0.25],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : true, depth : -3.0 
   });
   four_blue_stars_2 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'four_blue_stars_2', units : undefined, 
     image : 'images/four_blue_stars.jpg', mask : undefined,
     ori : 0, pos : [0.45, 0.25], size : [0.25, 0.25],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : true, depth : -4.0 
   });
   trial_card_2 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'trial_card_2', units : undefined, 
     image : undefined, mask : undefined,
     ori : 0, pos : [0, (- 0.2)], size : [0.25, 0.25],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 512, interpolate : true, depth : -5.0 
   });
   response_2 = new core.Mouse({
     win: psychoJS.window,
   });
   response_2.mouseClock = new util.Clock();
   // Initialize components for Routine "feedback_practice_2"
   feedback_practice_2Clock = new util.Clock();
   msg = "";
   
   trial_counter = 0;
   corr = 0 ;
   
   corr_trial_counter = 0;
   
   prev = 0;
   feedback_text_2 = new visual.TextStim({
     win: psychoJS.window,
     name: 'feedback_text_2',
     text: 'default text',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   // Initialize components for Routine "ready"
   readyClock = new util.Clock();
   text_127 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_127',
     text: 'Now, you will start the task.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   text_128 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_128',
     text: 'Press space bar to continue',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   key_resp_56 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
   
   // Initialize components for Routine "code_meta_2"
   code_meta_2Clock = new util.Clock();
   trial_counter = 0;
   condition_counter = 0;
   // Initialize components for Routine "Trials"
   TrialsClock = new util.Clock();
   fixation_5 = new visual.TextStim({
     win: psychoJS.window,
     name: 'fixation_5',
     text: '+',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   one_red_dot = new visual.ImageStim({
     win : psychoJS.window,
     name : 'one_red_dot', units : undefined, 
     image : 'images/one_red_dot.jpg', mask : undefined,
     ori : 0, pos : [(- 0.45), 0.25], size : [0.25, 0.25],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : true, depth : -1.0 
   });
   two_yellow_triangles = new visual.ImageStim({
     win : psychoJS.window,
     name : 'two_yellow_triangles', units : undefined, 
     image : 'images/two_yellow_triangles.jpg', mask : undefined,
     ori : 0, pos : [(- 0.15), 0.25], size : [0.25, 0.25],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : true, depth : -2.0 
   });
   three_green_crosses = new visual.ImageStim({
     win : psychoJS.window,
     name : 'three_green_crosses', units : undefined, 
     image : 'images/three_green_crosses.jpg', mask : undefined,
     ori : 0, pos : [0.15, 0.25], size : [0.25, 0.25],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : true, depth : -3.0 
   });
   four_blue_stars = new visual.ImageStim({
     win : psychoJS.window,
     name : 'four_blue_stars', units : undefined, 
     image : 'images/four_blue_stars.jpg', mask : undefined,
     ori : 0, pos : [0.45, 0.25], size : [0.25, 0.25],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 128, interpolate : true, depth : -4.0 
   });
   trial_card = new visual.ImageStim({
     win : psychoJS.window,
     name : 'trial_card', units : undefined, 
     image : undefined, mask : undefined,
     ori : 0, pos : [0, (- 0.2)], size : [0.25, 0.25],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 512, interpolate : true, depth : -5.0 
   });
   response = new core.Mouse({
     win: psychoJS.window,
   });
   response.mouseClock = new util.Clock();
   // Initialize components for Routine "Feedback_2"
   Feedback_2Clock = new util.Clock();
   msg = "";
   
   trial_counter = 0;
   corr = 0 ;
   
   corr_trial_counter = 0;
   
   prev = 0;
   feedback_text = new visual.TextStim({
     win: psychoJS.window,
     name: 'feedback_text',
     text: 'default text',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   // Initialize components for Routine "code_end_2"
   code_end_2Clock = new util.Clock();
   // Initialize components for Routine "tol_welcome"
   tol_welcomeClock = new util.Clock();
   light_gray_bg_6 = new visual.Rect ({
     win: psychoJS.window, name: 'light_gray_bg_6', units : 'height', 
     width: [1.5, 0.9][0], height: [1.5, 0.9][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#636363'),
     fillColor: new util.Color('#FFFFFF'),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   text_129 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_129',
     text: 'Welcome!\nThis is the last task and will take about 6 minutes. Click on NEXT to continue',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -1.0 
   });
   
   mouse_8 = new core.Mouse({
     win: psychoJS.window,
   });
   mouse_8.mouseClock = new util.Clock();
   check_box_welcome = new visual.Rect ({
     win: psychoJS.window, name: 'check_box_welcome', 
     width: [0.125, 0.1][0], height: [0.125, 0.1][1],
     ori: 0, pos: [0.587, (- 0.35)],
     lineWidth: 1, lineColor: new util.Color([(- 1), (- 1), (- 1)]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   text_next_wel = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_next_wel',
     text: 'NEXT',
     font: 'Arial',
     units: undefined, 
     pos: [0.587, (- 0.35)], height: 0.025,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -4.0 
   });
   
   // Initialize components for Routine "tol_explanation"
   tol_explanationClock = new util.Clock();
   light_gray_bg_7 = new visual.Rect ({
     win: psychoJS.window, name: 'light_gray_bg_7', units : 'height', 
     width: [1.5, 0.9][0], height: [1.5, 0.9][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#636363'),
     fillColor: new util.Color('#FFFFFF'),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   base_right_6 = new visual.Rect ({
     win: psychoJS.window, name: 'base_right_6', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [0.35, (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   pole_right_13 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_13', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [0.113, (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   pole_right_14 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_14', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [0.35, (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   pole_right_15 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_15', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [0.587, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   right_green_5 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_green_5', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0.587, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   right_red_5 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_red_5', 
     edges: 10000, size:[0.1, 0.1],
     ori: 0, pos: [0.35, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   right_blue_5 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_blue_5', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0.113, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   base_left_6 = new visual.Rect ({
     win: psychoJS.window, name: 'base_left_6', units : 'height', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [(- 0.35), (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   bart1m2_leftc_4 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_leftc_4', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   bart1m2_leftb_4 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_leftb_4', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [(- 0.35), (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   bart1m2_lefta_4 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_lefta_4', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [(- 0.587), (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   mouse_9 = new core.Mouse({
     win: psychoJS.window,
   });
   mouse_9.mouseClock = new util.Clock();
   fixedt1m2_a1_4 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a1_4', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -13, interpolate: true,
   });
   
   fixedt1m2_a2_4 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a2_4', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -14, interpolate: true,
   });
   
   fixedt1m2_a3_4 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a3_4', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), 0.05],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -15, interpolate: true,
   });
   
   fixedt1m2_b1_4 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_b1_4', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -16, interpolate: true,
   });
   
   fixedt1m2_b2_4 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_b2_4', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -17, interpolate: true,
   });
   
   fixedt1m2_c1_4 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_c1_4', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -18, interpolate: true,
   });
   
   text_exp = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_exp',
     text: 'During this task, two boards will be presented at a time. The boards will show colored balls arranged on pegs.\nImagine that these balls have holes through them and the pegs are going through the holes. Notice that the first peg can hold three balls, the second peg can hold two balls, and the third peg can hold one ball.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.3], height: 0.035,  wrapWidth: 1.3, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -19.0 
   });
   
   greent1m2_4 = new visual.Polygon ({
     win: psychoJS.window, name: 'greent1m2_4', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -20, interpolate: true,
   });
   
   redt1m2_4 = new visual.Polygon ({
     win: psychoJS.window, name: 'redt1m2_4', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -21, interpolate: true,
   });
   
   bluet1m2_4 = new visual.Polygon ({
     win: psychoJS.window, name: 'bluet1m2_4', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -22, interpolate: true,
   });
   
   check_box_2 = new visual.Rect ({
     win: psychoJS.window, name: 'check_box_2', 
     width: [0.125, 0.1][0], height: [0.125, 0.1][1],
     ori: 0, pos: [0.587, (- 0.35)],
     lineWidth: 1, lineColor: new util.Color([(- 1), (- 1), (- 1)]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: -23, interpolate: true,
   });
   
   text_132 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_132',
     text: 'NEXT',
     font: 'Arial',
     units: undefined, 
     pos: [0.587, (- 0.35)], height: 0.025,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -24.0 
   });
   
   text_133 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_133',
     text: 'Your board',
     font: 'Arial',
     units: undefined, 
     pos: [(- 0.35), (- 0.25)], height: 0.04,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -25.0 
   });
   
   text_134 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_134',
     text: 'Target board',
     font: 'Arial',
     units: undefined, 
     pos: [0.35, (- 0.25)], height: 0.04,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -26.0 
   });
   
   // Initialize components for Routine "tol_instructions"
   tol_instructionsClock = new util.Clock();
   light_gray_bg_8 = new visual.Rect ({
     win: psychoJS.window, name: 'light_gray_bg_8', units : 'height', 
     width: [1.5, 0.9][0], height: [1.5, 0.9][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#636363'),
     fillColor: new util.Color('#FFFFFF'),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   base_right_7 = new visual.Rect ({
     win: psychoJS.window, name: 'base_right_7', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [0.35, (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   pole_right_16 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_16', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [0.113, (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   pole_right_17 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_17', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [0.35, (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   pole_right_18 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_18', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [0.587, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   right_green_6 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_green_6', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0.587, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   right_red_6 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_red_6', 
     edges: 10000, size:[0.1, 0.1],
     ori: 0, pos: [0.35, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   right_blue_6 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_blue_6', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0.113, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   base_left_7 = new visual.Rect ({
     win: psychoJS.window, name: 'base_left_7', units : 'height', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [(- 0.35), (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   bart1m2_leftc_5 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_leftc_5', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   bart1m2_leftb_5 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_leftb_5', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [(- 0.35), (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   bart1m2_lefta_5 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_lefta_5', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [(- 0.587), (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   mouse_10 = new core.Mouse({
     win: psychoJS.window,
   });
   mouse_10.mouseClock = new util.Clock();
   fixedt1m2_a1_5 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a1_5', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -13, interpolate: true,
   });
   
   fixedt1m2_a2_5 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a2_5', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -14, interpolate: true,
   });
   
   fixedt1m2_a3_5 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a3_5', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), 0.05],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -15, interpolate: true,
   });
   
   fixedt1m2_b1_5 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_b1_5', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -16, interpolate: true,
   });
   
   fixedt1m2_b2_5 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_b2_5', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -17, interpolate: true,
   });
   
   fixedt1m2_c1_5 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_c1_5', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -18, interpolate: true,
   });
   
   text_exp_2 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_exp_2',
     text: 'Your task is to match the arrangement of balls shown on the target board in the fewest possible moves. \nThe balls on your board are moveable, but the ones on the target board are not. You have to move them to make your board look like the target board. Sometimes you will have to move a ball to a different peg in order to get to the ball below it. Keep in mind that you want to make the fewest possible moves.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.3], height: 0.035,  wrapWidth: 1.3, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -19.0 
   });
   
   greent1m2_5 = new visual.Polygon ({
     win: psychoJS.window, name: 'greent1m2_5', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -20, interpolate: true,
   });
   
   redt1m2_5 = new visual.Polygon ({
     win: psychoJS.window, name: 'redt1m2_5', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -21, interpolate: true,
   });
   
   bluet1m2_5 = new visual.Polygon ({
     win: psychoJS.window, name: 'bluet1m2_5', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -22, interpolate: true,
   });
   
   check_box_3 = new visual.Rect ({
     win: psychoJS.window, name: 'check_box_3', 
     width: [0.125, 0.1][0], height: [0.125, 0.1][1],
     ori: 0, pos: [0.587, (- 0.35)],
     lineWidth: 1, lineColor: new util.Color([(- 1), (- 1), (- 1)]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: -23, interpolate: true,
   });
   
   text_135 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_135',
     text: 'NEXT',
     font: 'Arial',
     units: undefined, 
     pos: [0.587, (- 0.35)], height: 0.025,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -24.0 
   });
   
   text_136 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_136',
     text: 'Your board',
     font: 'Arial',
     units: undefined, 
     pos: [(- 0.35), (- 0.25)], height: 0.04,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -25.0 
   });
   
   text_137 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_137',
     text: 'Target board',
     font: 'Arial',
     units: undefined, 
     pos: [0.35, (- 0.25)], height: 0.04,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -26.0 
   });
   
   // Initialize components for Routine "tol_example"
   tol_exampleClock = new util.Clock();
   light_gray_bg_9 = new visual.Rect ({
     win: psychoJS.window, name: 'light_gray_bg_9', units : 'height', 
     width: [1.5, 0.9][0], height: [1.5, 0.9][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#636363'),
     fillColor: new util.Color('#FFFFFF'),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   base_right_8 = new visual.Rect ({
     win: psychoJS.window, name: 'base_right_8', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [0.35, (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   pole_right_19 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_19', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [0.113, (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   pole_right_20 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_20', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [0.35, (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   pole_right_21 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_21', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [0.587, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   right_green_7 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_green_7', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0.587, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   right_red_7 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_red_7', 
     edges: 10000, size:[0.1, 0.1],
     ori: 0, pos: [0.35, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   right_blue_7 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_blue_7', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0.113, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   base_left_8 = new visual.Rect ({
     win: psychoJS.window, name: 'base_left_8', units : 'height', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [(- 0.35), (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   bart1m2_leftc_6 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_leftc_6', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   bart1m2_leftb_6 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_leftb_6', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [(- 0.35), (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   bart1m2_lefta_6 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_lefta_6', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [(- 0.587), (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   mouse_11 = new core.Mouse({
     win: psychoJS.window,
   });
   mouse_11.mouseClock = new util.Clock();
   fixedt1m2_a1_6 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a1_6', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -13, interpolate: true,
   });
   
   fixedt1m2_a2_6 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a2_6', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -14, interpolate: true,
   });
   
   fixedt1m2_a3_6 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a3_6', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), 0.05],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -15, interpolate: true,
   });
   
   fixedt1m2_b1_6 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_b1_6', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -16, interpolate: true,
   });
   
   fixedt1m2_b2_6 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_b2_6', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -17, interpolate: true,
   });
   
   fixedt1m2_c1_6 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_c1_6', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -18, interpolate: true,
   });
   
   text_exp_3 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_exp_3',
     text: 'Here is an example. Notice that the balls in your board are in a different arrangement than in the target board. If we move the green ball from the first peg in your board to the third peg then it would look like the target board.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.3], height: 0.035,  wrapWidth: 1.3, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -19.0 
   });
   
   greent1m2_6 = new visual.Polygon ({
     win: psychoJS.window, name: 'greent1m2_6', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -20, interpolate: true,
   });
   
   redt1m2_6 = new visual.Polygon ({
     win: psychoJS.window, name: 'redt1m2_6', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -21, interpolate: true,
   });
   
   bluet1m2_6 = new visual.Polygon ({
     win: psychoJS.window, name: 'bluet1m2_6', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -22, interpolate: true,
   });
   
   check_box_4 = new visual.Rect ({
     win: psychoJS.window, name: 'check_box_4', 
     width: [0.125, 0.1][0], height: [0.125, 0.1][1],
     ori: 0, pos: [0.587, (- 0.35)],
     lineWidth: 1, lineColor: new util.Color([(- 1), (- 1), (- 1)]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: -23, interpolate: true,
   });
   
   text_138 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_138',
     text: 'NEXT',
     font: 'Arial',
     units: undefined, 
     pos: [0.587, (- 0.35)], height: 0.025,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -24.0 
   });
   
   text_139 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_139',
     text: 'Your board',
     font: 'Arial',
     units: undefined, 
     pos: [(- 0.35), (- 0.25)], height: 0.04,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -25.0 
   });
   
   text_140 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_140',
     text: 'Target board',
     font: 'Arial',
     units: undefined, 
     pos: [0.35, (- 0.25)], height: 0.04,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -26.0 
   });
   
   // Initialize components for Routine "tol_prepractice"
   tol_prepracticeClock = new util.Clock();
   light_gray_bg_10 = new visual.Rect ({
     win: psychoJS.window, name: 'light_gray_bg_10', units : 'height', 
     width: [1.5, 0.9][0], height: [1.5, 0.9][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#636363'),
     fillColor: new util.Color('#FFFFFF'),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   base_right_9 = new visual.Rect ({
     win: psychoJS.window, name: 'base_right_9', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [0.35, (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   pole_right_22 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_22', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [0.113, (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   pole_right_23 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_23', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [0.35, (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   pole_right_24 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_24', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [0.587, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   right_green_8 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_green_8', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0.587, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   right_red_8 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_red_8', 
     edges: 10000, size:[0.1, 0.1],
     ori: 0, pos: [0.35, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   right_blue_8 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_blue_8', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0.113, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   base_left_9 = new visual.Rect ({
     win: psychoJS.window, name: 'base_left_9', units : 'height', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [(- 0.35), (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   bart1m2_leftc_7 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_leftc_7', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   bart1m2_leftb_7 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_leftb_7', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [(- 0.35), (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   bart1m2_lefta_7 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_lefta_7', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [(- 0.587), (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   mouse_12 = new core.Mouse({
     win: psychoJS.window,
   });
   mouse_12.mouseClock = new util.Clock();
   fixedt1m2_a1_7 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a1_7', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -13, interpolate: true,
   });
   
   fixedt1m2_a2_7 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a2_7', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -14, interpolate: true,
   });
   
   fixedt1m2_a3_7 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a3_7', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), 0.05],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -15, interpolate: true,
   });
   
   fixedt1m2_b1_7 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_b1_7', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -16, interpolate: true,
   });
   
   fixedt1m2_b2_7 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_b2_7', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -17, interpolate: true,
   });
   
   fixedt1m2_c1_7 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_c1_7', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -18, interpolate: true,
   });
   
   text_exp_4 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_exp_4',
     text: 'During the task you will move the balls on your board by clicking on the pegs. When you click on a peg, the top ball will move into a grey box. You will have to click on that box and then click on another peg to move the ball to the top of that peg.\nIf you try to select a peg with no balls or try to place a ball on a full peg, nothing will happen. If you successfully make your board look like the target board, the trial will end and you will move to the next problem.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.3], height: 0.035,  wrapWidth: 1.3, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -19.0 
   });
   
   greent1m2_7 = new visual.Polygon ({
     win: psychoJS.window, name: 'greent1m2_7', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -20, interpolate: true,
   });
   
   redt1m2_7 = new visual.Polygon ({
     win: psychoJS.window, name: 'redt1m2_7', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -21, interpolate: true,
   });
   
   bluet1m2_7 = new visual.Polygon ({
     win: psychoJS.window, name: 'bluet1m2_7', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -22, interpolate: true,
   });
   
   check_box_5 = new visual.Rect ({
     win: psychoJS.window, name: 'check_box_5', 
     width: [0.125, 0.1][0], height: [0.125, 0.1][1],
     ori: 0, pos: [0.587, (- 0.35)],
     lineWidth: 1, lineColor: new util.Color([(- 1), (- 1), (- 1)]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: -23, interpolate: true,
   });
   
   text_141 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_141',
     text: 'NEXT',
     font: 'Arial',
     units: undefined, 
     pos: [0.587, (- 0.35)], height: 0.025,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -24.0 
   });
   
   text_142 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_142',
     text: 'Your board',
     font: 'Arial',
     units: undefined, 
     pos: [(- 0.35), (- 0.25)], height: 0.04,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -25.0 
   });
   
   text_143 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_143',
     text: 'Target board',
     font: 'Arial',
     units: undefined, 
     pos: [0.35, (- 0.25)], height: 0.04,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -26.0 
   });
   
   text_144 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_144',
     text: 'We will start with an easy practice example.',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.035,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -27.0 
   });
   
   // Initialize components for Routine "tol_next_trial"
   tol_next_trialClock = new util.Clock();
   light_gray_bg_13 = new visual.Rect ({
     win: psychoJS.window, name: 'light_gray_bg_13', units : 'height', 
     width: [1.5, 0.9][0], height: [1.5, 0.9][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#636363'),
     fillColor: new util.Color('#FFFFFF'),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   text_146 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_146',
     text: 'default text',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -2.0 
   });
   
   mouse_15 = new core.Mouse({
     win: psychoJS.window,
   });
   mouse_15.mouseClock = new util.Clock();
   check_box_trial = new visual.Rect ({
     win: psychoJS.window, name: 'check_box_trial', 
     width: [0.125, 0.1][0], height: [0.125, 0.1][1],
     ori: 0, pos: [0.587, (- 0.35)],
     lineWidth: 1, lineColor: new util.Color([(- 1), (- 1), (- 1)]),
     fillColor: new util.Color([1, 1, 1]),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   text_next_wel_3 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_next_wel_3',
     text: 'NEXT',
     font: 'Arial',
     units: undefined, 
     pos: [0.587, (- 0.35)], height: 0.025,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -5.0 
   });
   
   // Initialize components for Routine "first_movement"
   first_movementClock = new util.Clock();
   mouse_3 = new core.Mouse({
     win: psychoJS.window,
   });
   mouse_3.mouseClock = new util.Clock();
   light_gray_bg = new visual.Rect ({
     win: psychoJS.window, name: 'light_gray_bg', units : 'height', 
     width: [1.5, 0.9][0], height: [1.5, 0.9][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#636363'),
     fillColor: new util.Color('#FFFFFF'),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   base_right = new visual.Rect ({
     win: psychoJS.window, name: 'base_right', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [0.35, (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   pole_right_01 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_01', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [0.113, (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   pole_right_02 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_02', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [0.35, (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   pole_right_03 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_03', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [0.587, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   right_green = new visual.Polygon ({
     win: psychoJS.window, name: 'right_green', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   right_red = new visual.Polygon ({
     win: psychoJS.window, name: 'right_red', 
     edges: 10000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   right_blue = new visual.Polygon ({
     win: psychoJS.window, name: 'right_blue', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   ball_hand_box = new visual.Rect ({
     win: psychoJS.window, name: 'ball_hand_box', units : 'height', 
     width: [0.25, 0.2][0], height: [0.25, 0.2][1],
     ori: 0, pos: [(- 0.35), 0.3],
     lineWidth: 4, lineColor: new util.Color([(- 1), (- 1), (- 1)]),
     fillColor: new util.Color('#808080'),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   base_left = new visual.Rect ({
     win: psychoJS.window, name: 'base_left', units : 'height', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [(- 0.35), (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   bart1m1_lefta = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m1_lefta', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   bart1m1_leftb = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m1_leftb', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [(- 0.35), (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   bart1m1_leftc = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m1_leftc', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [(- 0.587), (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -13, interpolate: true,
   });
   
   greent1m1 = new visual.Polygon ({
     win: psychoJS.window, name: 'greent1m1', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -14, interpolate: true,
   });
   
   redt1m1 = new visual.Polygon ({
     win: psychoJS.window, name: 'redt1m1', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -15, interpolate: true,
   });
   
   bluet1m1 = new visual.Polygon ({
     win: psychoJS.window, name: 'bluet1m1', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -16, interpolate: true,
   });
   
   counter = 0;
   counter2 = 0;
   bluepos_orig = bluet1m1.pos;
   redpos_orig = redt1m1.pos;
   greenpos_orig = greent1m1.pos;
   bluepos = [];
   greenpos = [];
   redpos = [];
   
   fixedt1m1_a1 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m1_a1', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -18, interpolate: true,
   });
   
   fixedt1m1_a2 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m1_a2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -19, interpolate: true,
   });
   
   fixedt1m1_a3 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m1_a3', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), 0.05],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -20, interpolate: true,
   });
   
   fixedt1m1_b1 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m1_b1', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -21, interpolate: true,
   });
   
   fixedt1m1_b2 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m1_b2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -22, interpolate: true,
   });
   
   fixedt1m1_c1 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m1_c1', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -23, interpolate: true,
   });
   
   text_148 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_148',
     text: 'Choose the ball',
     font: 'Arial',
     units: undefined, 
     pos: [(- 0.35), 0.18], height: 0.025,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -24.0 
   });
   
   // Initialize components for Routine "check_step1_t1"
   check_step1_t1Clock = new util.Clock();
   light_gray_bg_5 = new visual.Rect ({
     win: psychoJS.window, name: 'light_gray_bg_5', units : 'height', 
     width: [1.5, 0.9][0], height: [1.5, 0.9][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#636363'),
     fillColor: new util.Color('#FFFFFF'),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   ball_hand_box_5 = new visual.Rect ({
     win: psychoJS.window, name: 'ball_hand_box_5', units : 'height', 
     width: [0.25, 0.2][0], height: [0.25, 0.2][1],
     ori: 0, pos: [(- 0.35), 0.3],
     lineWidth: 4, lineColor: new util.Color([(- 1), (- 1), (- 1)]),
     fillColor: new util.Color('#808080'),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   base_right_5 = new visual.Rect ({
     win: psychoJS.window, name: 'base_right_5', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [0.35, (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   pole_right_10 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_10', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [0.113, (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   pole_right_11 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_11', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [0.35, (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   pole_right_12 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_12', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [0.587, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   right_green_4 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_green_4', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   right_red_4 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_red_4', 
     edges: 10000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   right_blue_4 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_blue_4', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   base_left_5 = new visual.Rect ({
     win: psychoJS.window, name: 'base_left_5', units : 'height', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [(- 0.35), (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   bart1m2_leftc_3 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_leftc_3', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   bart1m2_leftb_3 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_leftb_3', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [(- 0.35), (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   bart1m2_lefta_3 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_lefta_3', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [(- 0.587), (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   mouse_7 = new core.Mouse({
     win: psychoJS.window,
   });
   mouse_7.mouseClock = new util.Clock();
   fixedt1m2_a1_3 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a1_3', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -14, interpolate: true,
   });
   
   fixedt1m2_a2_3 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a2_3', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -15, interpolate: true,
   });
   
   fixedt1m2_a3_3 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a3_3', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), 0.05],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -16, interpolate: true,
   });
   
   fixedt1m2_b1_3 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_b1_3', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -17, interpolate: true,
   });
   
   fixedt1m2_b2_3 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_b2_3', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -18, interpolate: true,
   });
   
   fixedt1m2_c1_3 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_c1_3', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -19, interpolate: true,
   });
   
   greent1m2_3 = new visual.Polygon ({
     win: psychoJS.window, name: 'greent1m2_3', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -20, interpolate: true,
   });
   
   redt1m2_3 = new visual.Polygon ({
     win: psychoJS.window, name: 'redt1m2_3', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -21, interpolate: true,
   });
   
   bluet1m2_3 = new visual.Polygon ({
     win: psychoJS.window, name: 'bluet1m2_3', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -22, interpolate: true,
   });
   
   text_150 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_150',
     text: 'Press the grey box',
     font: 'Arial',
     units: undefined, 
     pos: [(- 0.35), 0.18], height: 0.025,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -23.0 
   });
   
   // Initialize components for Routine "second_mov"
   second_movClock = new util.Clock();
   light_gray_bg_3 = new visual.Rect ({
     win: psychoJS.window, name: 'light_gray_bg_3', units : 'height', 
     width: [1.5, 0.9][0], height: [1.5, 0.9][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#636363'),
     fillColor: new util.Color('#FFFFFF'),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   ball_hand_box_3 = new visual.Rect ({
     win: psychoJS.window, name: 'ball_hand_box_3', units : 'height', 
     width: [0.25, 0.2][0], height: [0.25, 0.2][1],
     ori: 0, pos: [(- 0.35), 0.3],
     lineWidth: 4, lineColor: new util.Color([(- 1), (- 1), (- 1)]),
     fillColor: new util.Color('#808080'),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   base_right_3 = new visual.Rect ({
     win: psychoJS.window, name: 'base_right_3', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [0.35, (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   pole_right_2 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_2', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [0.113, (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   pole_right_5 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_5', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [0.35, (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   pole_right_6 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_6', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [0.587, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   right_green_2 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_green_2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   right_red_2 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_red_2', 
     edges: 10000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   right_blue_2 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_blue_2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   base_left_3 = new visual.Rect ({
     win: psychoJS.window, name: 'base_left_3', units : 'height', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [(- 0.35), (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   bart1m2_leftc = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_leftc', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   bart1m2_leftb = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_leftb', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [(- 0.35), (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   bart1m2_lefta = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_lefta', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [(- 0.587), (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   mouse_4 = new core.Mouse({
     win: psychoJS.window,
   });
   mouse_4.mouseClock = new util.Clock();
   fixedt1m2_a1 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a1', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -14, interpolate: true,
   });
   
   fixedt1m2_a2 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -15, interpolate: true,
   });
   
   fixedt1m2_a3 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a3', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), 0.05],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -16, interpolate: true,
   });
   
   fixedt1m2_b1 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_b1', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -17, interpolate: true,
   });
   
   fixedt1m2_b2 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_b2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -18, interpolate: true,
   });
   
   fixedt1m2_c1 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_c1', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -19, interpolate: true,
   });
   
   greent1m2 = new visual.Polygon ({
     win: psychoJS.window, name: 'greent1m2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -21, interpolate: true,
   });
   
   redt1m2 = new visual.Polygon ({
     win: psychoJS.window, name: 'redt1m2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -22, interpolate: true,
   });
   
   bluet1m2 = new visual.Polygon ({
     win: psychoJS.window, name: 'bluet1m2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -23, interpolate: true,
   });
   
   text_152 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_152',
     text: 'Choose the new position',
     font: 'Arial',
     units: undefined, 
     pos: [(- 0.35), 0.18], height: 0.025,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -24.0 
   });
   
   // Initialize components for Routine "check_step2_t1"
   check_step2_t1Clock = new util.Clock();
   light_gray_bg_4 = new visual.Rect ({
     win: psychoJS.window, name: 'light_gray_bg_4', units : 'height', 
     width: [1.5, 0.9][0], height: [1.5, 0.9][1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#636363'),
     fillColor: new util.Color('#FFFFFF'),
     opacity: 1, depth: 0, interpolate: true,
   });
   
   ball_hand_box_4 = new visual.Rect ({
     win: psychoJS.window, name: 'ball_hand_box_4', units : 'height', 
     width: [0.25, 0.2][0], height: [0.25, 0.2][1],
     ori: 0, pos: [(- 0.35), 0.3],
     lineWidth: 4, lineColor: new util.Color([(- 1), (- 1), (- 1)]),
     fillColor: new util.Color('#808080'),
     opacity: 1, depth: -1, interpolate: true,
   });
   
   base_right_4 = new visual.Rect ({
     win: psychoJS.window, name: 'base_right_4', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [0.35, (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -2, interpolate: true,
   });
   
   pole_right_7 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_7', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [0.113, (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -3, interpolate: true,
   });
   
   pole_right_8 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_8', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [0.35, (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -4, interpolate: true,
   });
   
   pole_right_9 = new visual.Rect ({
     win: psychoJS.window, name: 'pole_right_9', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [0.587, (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -5, interpolate: true,
   });
   
   right_green_3 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_green_3', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -6, interpolate: true,
   });
   
   right_red_3 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_red_3', 
     edges: 10000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -7, interpolate: true,
   });
   
   right_blue_3 = new visual.Polygon ({
     win: psychoJS.window, name: 'right_blue_3', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -8, interpolate: true,
   });
   
   base_left_4 = new visual.Rect ({
     win: psychoJS.window, name: 'base_left_4', units : 'height', 
     width: [0.499, 0.05][0], height: [0.499, 0.05][1],
     ori: 0, pos: [(- 0.35), (- 0.25)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -9, interpolate: true,
   });
   
   bart1m2_leftc_2 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_leftc_2', 
     width: [0.025, 0.16][0], height: [0.025, 0.16][1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -10, interpolate: true,
   });
   
   bart1m2_leftb_2 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_leftb_2', 
     width: [0.025, 0.28][0], height: [0.025, 0.28][1],
     ori: 0, pos: [(- 0.35), (- 0.11)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -11, interpolate: true,
   });
   
   bart1m2_lefta_2 = new visual.Rect ({
     win: psychoJS.window, name: 'bart1m2_lefta_2', 
     width: [0.025, 0.4][0], height: [0.025, 0.4][1],
     ori: 0, pos: [(- 0.587), (- 0.05)],
     lineWidth: 1, lineColor: new util.Color('#A52A2A'),
     fillColor: new util.Color('#A52A2A'),
     opacity: 1, depth: -12, interpolate: true,
   });
   
   mouse_6 = new core.Mouse({
     win: psychoJS.window,
   });
   mouse_6.mouseClock = new util.Clock();
   fixedt1m2_a1_2 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a1_2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -14, interpolate: true,
   });
   
   fixedt1m2_a2_2 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a2_2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -15, interpolate: true,
   });
   
   fixedt1m2_a3_2 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_a3_2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.587), 0.05],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -16, interpolate: true,
   });
   
   fixedt1m2_b1_2 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_b1_2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -17, interpolate: true,
   });
   
   fixedt1m2_b2_2 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_b2_2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.35), (- 0.06)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -18, interpolate: true,
   });
   
   fixedt1m2_c1_2 = new visual.Polygon ({
     win: psychoJS.window, name: 'fixedt1m2_c1_2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [(- 0.113), (- 0.17)],
     lineWidth: 1, lineColor: new util.Color('#808080'),
     fillColor: new util.Color('#808080'),
     opacity: 0, depth: -19, interpolate: true,
   });
   
   greent1m2_2 = new visual.Polygon ({
     win: psychoJS.window, name: 'greent1m2_2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#00CC33'),
     fillColor: new util.Color('#00CC33'),
     opacity: 1, depth: -20, interpolate: true,
   });
   
   redt1m2_2 = new visual.Polygon ({
     win: psychoJS.window, name: 'redt1m2_2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#FF0000'),
     fillColor: new util.Color('#FF0000'),
     opacity: 1, depth: -21, interpolate: true,
   });
   
   bluet1m2_2 = new visual.Polygon ({
     win: psychoJS.window, name: 'bluet1m2_2', 
     edges: 1000, size:[0.1, 0.1],
     ori: 0, pos: [0, 0],
     lineWidth: 1, lineColor: new util.Color('#0099FF'),
     fillColor: new util.Color('#0099FF'),
     opacity: 1, depth: -22, interpolate: true,
   });
   
   check_box = new visual.Polygon ({
     win: psychoJS.window, name: 'check_box', 
     edges: 1000, size:[0.15, 0.1],
     ori: 0, pos: [0, (- 0.35)],
     lineWidth: 1.5, lineColor: new util.Color([(- 1), (- 1), (- 1)]),
     fillColor: new util.Color('#F0E68C'),
     opacity: 1, depth: -23, interpolate: true,
   });
   
   text_154 = new visual.TextStim({
     win: psychoJS.window,
     name: 'text_154',
     text: 'Press here',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.35)], height: 0.025,  wrapWidth: undefined, ori: 0,
     color: new util.Color('black'),  opacity: 1,
     depth: -24.0 
   });
   
   // Initialize components for Routine "check_positions"
   check_positionsClock = new util.Clock();
   // Initialize components for Routine "End_2"
   End_2Clock = new util.Clock();
   thank_you_2 = new visual.TextStim({
     win: psychoJS.window,
     name: 'thank_you_2',
     text: 'Great! You have finished all the tasks.\nPlease, DO NOT close the window browser until you have seen the following message. Then, click on OK to be directed to the next task.',
     font: 'Arial',
     units: undefined, 
     pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: 0.0 
   });
   
   end = new visual.TextStim({
     win: psychoJS.window,
     name: 'end',
     text: '',
     font: 'Arial',
     units: undefined, 
     pos: [0, (- 0.3)], height: 0.05,  wrapWidth: 0.8, ori: 0,
     color: new util.Color('white'),  opacity: 1,
     depth: -1.0 
   });
   
   image_16 = new visual.ImageStim({
     win : psychoJS.window,
     name : 'image_16', units : undefined, 
     image : 'ef_math_saving_message.png', mask : undefined,
     ori : 0, pos : [0, (- 0.04)], size : [0.5, 0.25],
     color : new util.Color([1, 1, 1]), opacity : 1,
     flipHoriz : false, flipVert : false,
     texRes : 512, interpolate : true, depth : -3.0 
   });
   // Create some handy timers
   globalClock = new util.Clock();  // to track the time since experiment started
   routineTimer = new util.CountdownTimer();  // to track time remaining of each (non-slip) routine
   
   return Scheduler.Event.NEXT;
 }
 
 
 var t;
 var frameN;
 var _key_resp_8_allKeys;
 var WelcomeComponents;
 function WelcomeRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Welcome'-------
     t = 0;
     WelcomeClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_8.keys = undefined;
     key_resp_8.rt = undefined;
     _key_resp_8_allKeys = [];
     // keep track of which components have finished
     WelcomeComponents = [];
     WelcomeComponents.push(text_12);
     WelcomeComponents.push(text_13);
     WelcomeComponents.push(key_resp_8);
     
     for (const thisComponent of WelcomeComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 var continueRoutine;
 function WelcomeRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Welcome'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = WelcomeClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *text_12* updates
     if (t >= 0.0 && text_12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_12.tStart = t;  // (not accounting for frame time here)
       text_12.frameNStart = frameN;  // exact frame index
       
       text_12.setAutoDraw(true);
     }
 
     
     // *text_13* updates
     if (t >= 0.0 && text_13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_13.tStart = t;  // (not accounting for frame time here)
       text_13.frameNStart = frameN;  // exact frame index
       
       text_13.setAutoDraw(true);
     }
 
     
     // *key_resp_8* updates
     if (t >= 0.0 && key_resp_8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_8.tStart = t;  // (not accounting for frame time here)
       key_resp_8.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_8.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_8.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_8.clearEvents(); });
     }
 
     if (key_resp_8.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_8.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_8_allKeys = _key_resp_8_allKeys.concat(theseKeys);
       if (_key_resp_8_allKeys.length > 0) {
         key_resp_8.keys = _key_resp_8_allKeys[_key_resp_8_allKeys.length - 1].name;  // just the last key pressed
         key_resp_8.rt = _key_resp_8_allKeys[_key_resp_8_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of WelcomeComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function WelcomeRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Welcome'-------
     for (const thisComponent of WelcomeComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // the Routine "Welcome" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_57_allKeys;
 var overal_ef_assessment_instructionsComponents;
 function overal_ef_assessment_instructionsRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'overal_ef_assessment_instructions'-------
     t = 0;
     overal_ef_assessment_instructionsClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_57.keys = undefined;
     key_resp_57.rt = undefined;
     _key_resp_57_allKeys = [];
     // keep track of which components have finished
     overal_ef_assessment_instructionsComponents = [];
     overal_ef_assessment_instructionsComponents.push(text_130);
     overal_ef_assessment_instructionsComponents.push(text_131);
     overal_ef_assessment_instructionsComponents.push(key_resp_57);
     overal_ef_assessment_instructionsComponents.push(image_29);
     
     for (const thisComponent of overal_ef_assessment_instructionsComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function overal_ef_assessment_instructionsRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'overal_ef_assessment_instructions'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = overal_ef_assessment_instructionsClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *text_130* updates
     if (t >= 0.0 && text_130.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_130.tStart = t;  // (not accounting for frame time here)
       text_130.frameNStart = frameN;  // exact frame index
       
       text_130.setAutoDraw(true);
     }
 
     
     // *text_131* updates
     if (t >= 0.0 && text_131.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_131.tStart = t;  // (not accounting for frame time here)
       text_131.frameNStart = frameN;  // exact frame index
       
       text_131.setAutoDraw(true);
     }
 
     
     // *key_resp_57* updates
     if (t >= 0.0 && key_resp_57.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_57.tStart = t;  // (not accounting for frame time here)
       key_resp_57.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_57.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_57.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_57.clearEvents(); });
     }
 
     if (key_resp_57.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_57.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_57_allKeys = _key_resp_57_allKeys.concat(theseKeys);
       if (_key_resp_57_allKeys.length > 0) {
         key_resp_57.keys = _key_resp_57_allKeys[_key_resp_57_allKeys.length - 1].name;  // just the last key pressed
         key_resp_57.rt = _key_resp_57_allKeys[_key_resp_57_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *image_29* updates
     if (t >= 0.0 && image_29.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_29.tStart = t;  // (not accounting for frame time here)
       image_29.frameNStart = frameN;  // exact frame index
       
       image_29.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of overal_ef_assessment_instructionsComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function overal_ef_assessment_instructionsRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'overal_ef_assessment_instructions'-------
     for (const thisComponent of overal_ef_assessment_instructionsComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_57.keys', key_resp_57.keys);
     if (typeof key_resp_57.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_57.rt', key_resp_57.rt);
         routineTimer.reset();
         }
     
     key_resp_57.stop();
     // the Routine "overal_ef_assessment_instructions" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_9_allKeys;
 var IntroductionComponents;
 function IntroductionRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Introduction'-------
     t = 0;
     IntroductionClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_9.keys = undefined;
     key_resp_9.rt = undefined;
     _key_resp_9_allKeys = [];
     // keep track of which components have finished
     IntroductionComponents = [];
     IntroductionComponents.push(text_14);
     IntroductionComponents.push(text_16);
     IntroductionComponents.push(key_resp_9);
     
     for (const thisComponent of IntroductionComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroductionRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Introduction'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = IntroductionClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *text_14* updates
     if (t >= 0.0 && text_14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_14.tStart = t;  // (not accounting for frame time here)
       text_14.frameNStart = frameN;  // exact frame index
       
       text_14.setAutoDraw(true);
     }
 
     
     // *text_16* updates
     if (t >= 0 && text_16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_16.tStart = t;  // (not accounting for frame time here)
       text_16.frameNStart = frameN;  // exact frame index
       
       text_16.setAutoDraw(true);
     }
 
     
     // *key_resp_9* updates
     if (t >= 0 && key_resp_9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_9.tStart = t;  // (not accounting for frame time here)
       key_resp_9.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_9.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_9.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_9.clearEvents(); });
     }
 
     if (key_resp_9.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_9.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_9_allKeys = _key_resp_9_allKeys.concat(theseKeys);
       if (_key_resp_9_allKeys.length > 0) {
         key_resp_9.keys = _key_resp_9_allKeys[_key_resp_9_allKeys.length - 1].name;  // just the last key pressed
         key_resp_9.rt = _key_resp_9_allKeys[_key_resp_9_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of IntroductionComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroductionRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Introduction'-------
     for (const thisComponent of IntroductionComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // the Routine "Introduction" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Circles_Example_1Components;
 function Circles_Example_1RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Circles_Example_1'-------
     t = 0;
     Circles_Example_1Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(1.000000);
     // update component parameters for each repeat
     // keep track of which components have finished
     Circles_Example_1Components = [];
     Circles_Example_1Components.push(init_circle);
     Circles_Example_1Components.push(init_circle_17);
     Circles_Example_1Components.push(init_circle_18);
     Circles_Example_1Components.push(init_circle_19);
     Circles_Example_1Components.push(init_circle_20);
     Circles_Example_1Components.push(init_circle_21);
     Circles_Example_1Components.push(init_circle_22);
     Circles_Example_1Components.push(init_circle_23);
     Circles_Example_1Components.push(init_circle_24);
     Circles_Example_1Components.push(init_circle_25);
     Circles_Example_1Components.push(init_circle_26);
     Circles_Example_1Components.push(init_circle_27);
     Circles_Example_1Components.push(init_circle_28);
     Circles_Example_1Components.push(init_circle_29);
     Circles_Example_1Components.push(init_circle_30);
     Circles_Example_1Components.push(init_circle_31);
     Circles_Example_1Components.push(For_example);
     
     for (const thisComponent of Circles_Example_1Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 var frameRemains;
 function Circles_Example_1RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Circles_Example_1'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Circles_Example_1Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *init_circle* updates
     if (t >= 0 && init_circle.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle.tStart = t;  // (not accounting for frame time here)
       init_circle.frameNStart = frameN;  // exact frame index
       
       init_circle.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle.status === PsychoJS.Status.STARTED || init_circle.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle.setAutoDraw(false);
     }
     
     // *init_circle_17* updates
     if (t >= 0 && init_circle_17.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_17.tStart = t;  // (not accounting for frame time here)
       init_circle_17.frameNStart = frameN;  // exact frame index
       
       init_circle_17.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_17.status === PsychoJS.Status.STARTED || init_circle_17.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_17.setAutoDraw(false);
     }
     
     // *init_circle_18* updates
     if (t >= 0 && init_circle_18.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_18.tStart = t;  // (not accounting for frame time here)
       init_circle_18.frameNStart = frameN;  // exact frame index
       
       init_circle_18.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_18.status === PsychoJS.Status.STARTED || init_circle_18.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_18.setAutoDraw(false);
     }
     
     // *init_circle_19* updates
     if (t >= 0 && init_circle_19.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_19.tStart = t;  // (not accounting for frame time here)
       init_circle_19.frameNStart = frameN;  // exact frame index
       
       init_circle_19.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_19.status === PsychoJS.Status.STARTED || init_circle_19.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_19.setAutoDraw(false);
     }
     
     // *init_circle_20* updates
     if (t >= 0 && init_circle_20.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_20.tStart = t;  // (not accounting for frame time here)
       init_circle_20.frameNStart = frameN;  // exact frame index
       
       init_circle_20.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_20.status === PsychoJS.Status.STARTED || init_circle_20.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_20.setAutoDraw(false);
     }
     
     // *init_circle_21* updates
     if (t >= 0 && init_circle_21.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_21.tStart = t;  // (not accounting for frame time here)
       init_circle_21.frameNStart = frameN;  // exact frame index
       
       init_circle_21.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_21.status === PsychoJS.Status.STARTED || init_circle_21.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_21.setAutoDraw(false);
     }
     
     // *init_circle_22* updates
     if (t >= 0 && init_circle_22.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_22.tStart = t;  // (not accounting for frame time here)
       init_circle_22.frameNStart = frameN;  // exact frame index
       
       init_circle_22.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_22.status === PsychoJS.Status.STARTED || init_circle_22.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_22.setAutoDraw(false);
     }
     
     // *init_circle_23* updates
     if (t >= 0 && init_circle_23.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_23.tStart = t;  // (not accounting for frame time here)
       init_circle_23.frameNStart = frameN;  // exact frame index
       
       init_circle_23.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_23.status === PsychoJS.Status.STARTED || init_circle_23.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_23.setAutoDraw(false);
     }
     
     // *init_circle_24* updates
     if (t >= 0 && init_circle_24.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_24.tStart = t;  // (not accounting for frame time here)
       init_circle_24.frameNStart = frameN;  // exact frame index
       
       init_circle_24.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_24.status === PsychoJS.Status.STARTED || init_circle_24.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_24.setAutoDraw(false);
     }
     
     // *init_circle_25* updates
     if (t >= 0 && init_circle_25.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_25.tStart = t;  // (not accounting for frame time here)
       init_circle_25.frameNStart = frameN;  // exact frame index
       
       init_circle_25.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_25.status === PsychoJS.Status.STARTED || init_circle_25.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_25.setAutoDraw(false);
     }
     
     // *init_circle_26* updates
     if (t >= 0 && init_circle_26.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_26.tStart = t;  // (not accounting for frame time here)
       init_circle_26.frameNStart = frameN;  // exact frame index
       
       init_circle_26.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_26.status === PsychoJS.Status.STARTED || init_circle_26.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_26.setAutoDraw(false);
     }
     
     // *init_circle_27* updates
     if (t >= 0 && init_circle_27.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_27.tStart = t;  // (not accounting for frame time here)
       init_circle_27.frameNStart = frameN;  // exact frame index
       
       init_circle_27.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_27.status === PsychoJS.Status.STARTED || init_circle_27.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_27.setAutoDraw(false);
     }
     
     // *init_circle_28* updates
     if (t >= 0 && init_circle_28.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_28.tStart = t;  // (not accounting for frame time here)
       init_circle_28.frameNStart = frameN;  // exact frame index
       
       init_circle_28.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_28.status === PsychoJS.Status.STARTED || init_circle_28.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_28.setAutoDraw(false);
     }
     
     // *init_circle_29* updates
     if (t >= 0 && init_circle_29.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_29.tStart = t;  // (not accounting for frame time here)
       init_circle_29.frameNStart = frameN;  // exact frame index
       
       init_circle_29.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_29.status === PsychoJS.Status.STARTED || init_circle_29.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_29.setAutoDraw(false);
     }
     
     // *init_circle_30* updates
     if (t >= 0 && init_circle_30.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_30.tStart = t;  // (not accounting for frame time here)
       init_circle_30.frameNStart = frameN;  // exact frame index
       
       init_circle_30.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_30.status === PsychoJS.Status.STARTED || init_circle_30.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_30.setAutoDraw(false);
     }
     
     // *init_circle_31* updates
     if (t >= 0 && init_circle_31.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_31.tStart = t;  // (not accounting for frame time here)
       init_circle_31.frameNStart = frameN;  // exact frame index
       
       init_circle_31.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_31.status === PsychoJS.Status.STARTED || init_circle_31.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_31.setAutoDraw(false);
     }
     
     // *For_example* updates
     if (t >= 0.0 && For_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       For_example.tStart = t;  // (not accounting for frame time here)
       For_example.frameNStart = frameN;  // exact frame index
       
       For_example.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((For_example.status === PsychoJS.Status.STARTED || For_example.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       For_example.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Circles_Example_1Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Circles_Example_1RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Circles_Example_1'-------
     for (const thisComponent of Circles_Example_1Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Circles_Example_2Components;
 function Circles_Example_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Circles_Example_2'-------
     t = 0;
     Circles_Example_2Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(0.900000);
     // update component parameters for each repeat
     // keep track of which components have finished
     Circles_Example_2Components = [];
     Circles_Example_2Components.push(init_circle_32);
     Circles_Example_2Components.push(init_circle_33);
     Circles_Example_2Components.push(init_circle_34);
     Circles_Example_2Components.push(C4_circle_lights_up);
     Circles_Example_2Components.push(init_circle_36);
     Circles_Example_2Components.push(init_circle_37);
     Circles_Example_2Components.push(init_circle_38);
     Circles_Example_2Components.push(init_circle_39);
     Circles_Example_2Components.push(init_circle_40);
     Circles_Example_2Components.push(init_circle_41);
     Circles_Example_2Components.push(init_circle_42);
     Circles_Example_2Components.push(init_circle_43);
     Circles_Example_2Components.push(init_circle_44);
     Circles_Example_2Components.push(init_circle_45);
     Circles_Example_2Components.push(init_circle_46);
     Circles_Example_2Components.push(init_circle_47);
     Circles_Example_2Components.push(For_example_2);
     
     for (const thisComponent of Circles_Example_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Circles_Example_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Circles_Example_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Circles_Example_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *init_circle_32* updates
     if (t >= 0 && init_circle_32.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_32.tStart = t;  // (not accounting for frame time here)
       init_circle_32.frameNStart = frameN;  // exact frame index
       
       init_circle_32.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_32.status === PsychoJS.Status.STARTED || init_circle_32.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_32.setAutoDraw(false);
     }
     
     // *init_circle_33* updates
     if (t >= 0 && init_circle_33.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_33.tStart = t;  // (not accounting for frame time here)
       init_circle_33.frameNStart = frameN;  // exact frame index
       
       init_circle_33.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_33.status === PsychoJS.Status.STARTED || init_circle_33.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_33.setAutoDraw(false);
     }
     
     // *init_circle_34* updates
     if (t >= 0 && init_circle_34.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_34.tStart = t;  // (not accounting for frame time here)
       init_circle_34.frameNStart = frameN;  // exact frame index
       
       init_circle_34.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_34.status === PsychoJS.Status.STARTED || init_circle_34.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_34.setAutoDraw(false);
     }
     
     // *C4_circle_lights_up* updates
     if (t >= 0 && C4_circle_lights_up.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       C4_circle_lights_up.tStart = t;  // (not accounting for frame time here)
       C4_circle_lights_up.frameNStart = frameN;  // exact frame index
       
       C4_circle_lights_up.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((C4_circle_lights_up.status === PsychoJS.Status.STARTED || C4_circle_lights_up.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       C4_circle_lights_up.setAutoDraw(false);
     }
     
     // *init_circle_36* updates
     if (t >= 0 && init_circle_36.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_36.tStart = t;  // (not accounting for frame time here)
       init_circle_36.frameNStart = frameN;  // exact frame index
       
       init_circle_36.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_36.status === PsychoJS.Status.STARTED || init_circle_36.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_36.setAutoDraw(false);
     }
     
     // *init_circle_37* updates
     if (t >= 0 && init_circle_37.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_37.tStart = t;  // (not accounting for frame time here)
       init_circle_37.frameNStart = frameN;  // exact frame index
       
       init_circle_37.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_37.status === PsychoJS.Status.STARTED || init_circle_37.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_37.setAutoDraw(false);
     }
     
     // *init_circle_38* updates
     if (t >= 0 && init_circle_38.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_38.tStart = t;  // (not accounting for frame time here)
       init_circle_38.frameNStart = frameN;  // exact frame index
       
       init_circle_38.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_38.status === PsychoJS.Status.STARTED || init_circle_38.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_38.setAutoDraw(false);
     }
     
     // *init_circle_39* updates
     if (t >= 0 && init_circle_39.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_39.tStart = t;  // (not accounting for frame time here)
       init_circle_39.frameNStart = frameN;  // exact frame index
       
       init_circle_39.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_39.status === PsychoJS.Status.STARTED || init_circle_39.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_39.setAutoDraw(false);
     }
     
     // *init_circle_40* updates
     if (t >= 0 && init_circle_40.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_40.tStart = t;  // (not accounting for frame time here)
       init_circle_40.frameNStart = frameN;  // exact frame index
       
       init_circle_40.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_40.status === PsychoJS.Status.STARTED || init_circle_40.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_40.setAutoDraw(false);
     }
     
     // *init_circle_41* updates
     if (t >= 0 && init_circle_41.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_41.tStart = t;  // (not accounting for frame time here)
       init_circle_41.frameNStart = frameN;  // exact frame index
       
       init_circle_41.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_41.status === PsychoJS.Status.STARTED || init_circle_41.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_41.setAutoDraw(false);
     }
     
     // *init_circle_42* updates
     if (t >= 0 && init_circle_42.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_42.tStart = t;  // (not accounting for frame time here)
       init_circle_42.frameNStart = frameN;  // exact frame index
       
       init_circle_42.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_42.status === PsychoJS.Status.STARTED || init_circle_42.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_42.setAutoDraw(false);
     }
     
     // *init_circle_43* updates
     if (t >= 0 && init_circle_43.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_43.tStart = t;  // (not accounting for frame time here)
       init_circle_43.frameNStart = frameN;  // exact frame index
       
       init_circle_43.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_43.status === PsychoJS.Status.STARTED || init_circle_43.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_43.setAutoDraw(false);
     }
     
     // *init_circle_44* updates
     if (t >= 0 && init_circle_44.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_44.tStart = t;  // (not accounting for frame time here)
       init_circle_44.frameNStart = frameN;  // exact frame index
       
       init_circle_44.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_44.status === PsychoJS.Status.STARTED || init_circle_44.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_44.setAutoDraw(false);
     }
     
     // *init_circle_45* updates
     if (t >= 0 && init_circle_45.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_45.tStart = t;  // (not accounting for frame time here)
       init_circle_45.frameNStart = frameN;  // exact frame index
       
       init_circle_45.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_45.status === PsychoJS.Status.STARTED || init_circle_45.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_45.setAutoDraw(false);
     }
     
     // *init_circle_46* updates
     if (t >= 0 && init_circle_46.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_46.tStart = t;  // (not accounting for frame time here)
       init_circle_46.frameNStart = frameN;  // exact frame index
       
       init_circle_46.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_46.status === PsychoJS.Status.STARTED || init_circle_46.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_46.setAutoDraw(false);
     }
     
     // *init_circle_47* updates
     if (t >= 0 && init_circle_47.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_47.tStart = t;  // (not accounting for frame time here)
       init_circle_47.frameNStart = frameN;  // exact frame index
       
       init_circle_47.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_47.status === PsychoJS.Status.STARTED || init_circle_47.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_47.setAutoDraw(false);
     }
     
     // *For_example_2* updates
     if (t >= 0.0 && For_example_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       For_example_2.tStart = t;  // (not accounting for frame time here)
       For_example_2.frameNStart = frameN;  // exact frame index
       
       For_example_2.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((For_example_2.status === PsychoJS.Status.STARTED || For_example_2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       For_example_2.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Circles_Example_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Circles_Example_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Circles_Example_2'-------
     for (const thisComponent of Circles_Example_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Circles_Example_3Components;
 function Circles_Example_3RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Circles_Example_3'-------
     t = 0;
     Circles_Example_3Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(0.900000);
     // update component parameters for each repeat
     // keep track of which components have finished
     Circles_Example_3Components = [];
     Circles_Example_3Components.push(init_circle_35);
     Circles_Example_3Components.push(init_circle_48);
     Circles_Example_3Components.push(init_circle_49);
     Circles_Example_3Components.push(init_circle_63);
     Circles_Example_3Components.push(init_circle_50);
     Circles_Example_3Components.push(circle_6_lights_up);
     Circles_Example_3Components.push(init_circle_52);
     Circles_Example_3Components.push(init_circle_53);
     Circles_Example_3Components.push(init_circle_54);
     Circles_Example_3Components.push(init_circle_55);
     Circles_Example_3Components.push(init_circle_56);
     Circles_Example_3Components.push(init_circle_57);
     Circles_Example_3Components.push(init_circle_58);
     Circles_Example_3Components.push(init_circle_59);
     Circles_Example_3Components.push(init_circle_60);
     Circles_Example_3Components.push(init_circle_61);
     Circles_Example_3Components.push(b_For_example_4);
     
     for (const thisComponent of Circles_Example_3Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Circles_Example_3RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Circles_Example_3'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Circles_Example_3Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *init_circle_35* updates
     if (t >= 0 && init_circle_35.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_35.tStart = t;  // (not accounting for frame time here)
       init_circle_35.frameNStart = frameN;  // exact frame index
       
       init_circle_35.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_35.status === PsychoJS.Status.STARTED || init_circle_35.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_35.setAutoDraw(false);
     }
     
     // *init_circle_48* updates
     if (t >= 0 && init_circle_48.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_48.tStart = t;  // (not accounting for frame time here)
       init_circle_48.frameNStart = frameN;  // exact frame index
       
       init_circle_48.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_48.status === PsychoJS.Status.STARTED || init_circle_48.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_48.setAutoDraw(false);
     }
     
     // *init_circle_49* updates
     if (t >= 0 && init_circle_49.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_49.tStart = t;  // (not accounting for frame time here)
       init_circle_49.frameNStart = frameN;  // exact frame index
       
       init_circle_49.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_49.status === PsychoJS.Status.STARTED || init_circle_49.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_49.setAutoDraw(false);
     }
     
     // *init_circle_63* updates
     if (t >= 0 && init_circle_63.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_63.tStart = t;  // (not accounting for frame time here)
       init_circle_63.frameNStart = frameN;  // exact frame index
       
       init_circle_63.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_63.status === PsychoJS.Status.STARTED || init_circle_63.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_63.setAutoDraw(false);
     }
     
     // *init_circle_50* updates
     if (t >= 0 && init_circle_50.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_50.tStart = t;  // (not accounting for frame time here)
       init_circle_50.frameNStart = frameN;  // exact frame index
       
       init_circle_50.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_50.status === PsychoJS.Status.STARTED || init_circle_50.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_50.setAutoDraw(false);
     }
     
     // *circle_6_lights_up* updates
     if (t >= 0 && circle_6_lights_up.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       circle_6_lights_up.tStart = t;  // (not accounting for frame time here)
       circle_6_lights_up.frameNStart = frameN;  // exact frame index
       
       circle_6_lights_up.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((circle_6_lights_up.status === PsychoJS.Status.STARTED || circle_6_lights_up.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       circle_6_lights_up.setAutoDraw(false);
     }
     
     // *init_circle_52* updates
     if (t >= 0 && init_circle_52.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_52.tStart = t;  // (not accounting for frame time here)
       init_circle_52.frameNStart = frameN;  // exact frame index
       
       init_circle_52.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_52.status === PsychoJS.Status.STARTED || init_circle_52.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_52.setAutoDraw(false);
     }
     
     // *init_circle_53* updates
     if (t >= 0 && init_circle_53.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_53.tStart = t;  // (not accounting for frame time here)
       init_circle_53.frameNStart = frameN;  // exact frame index
       
       init_circle_53.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_53.status === PsychoJS.Status.STARTED || init_circle_53.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_53.setAutoDraw(false);
     }
     
     // *init_circle_54* updates
     if (t >= 0 && init_circle_54.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_54.tStart = t;  // (not accounting for frame time here)
       init_circle_54.frameNStart = frameN;  // exact frame index
       
       init_circle_54.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_54.status === PsychoJS.Status.STARTED || init_circle_54.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_54.setAutoDraw(false);
     }
     
     // *init_circle_55* updates
     if (t >= 0 && init_circle_55.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_55.tStart = t;  // (not accounting for frame time here)
       init_circle_55.frameNStart = frameN;  // exact frame index
       
       init_circle_55.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_55.status === PsychoJS.Status.STARTED || init_circle_55.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_55.setAutoDraw(false);
     }
     
     // *init_circle_56* updates
     if (t >= 0 && init_circle_56.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_56.tStart = t;  // (not accounting for frame time here)
       init_circle_56.frameNStart = frameN;  // exact frame index
       
       init_circle_56.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_56.status === PsychoJS.Status.STARTED || init_circle_56.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_56.setAutoDraw(false);
     }
     
     // *init_circle_57* updates
     if (t >= 0 && init_circle_57.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_57.tStart = t;  // (not accounting for frame time here)
       init_circle_57.frameNStart = frameN;  // exact frame index
       
       init_circle_57.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_57.status === PsychoJS.Status.STARTED || init_circle_57.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_57.setAutoDraw(false);
     }
     
     // *init_circle_58* updates
     if (t >= 0 && init_circle_58.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_58.tStart = t;  // (not accounting for frame time here)
       init_circle_58.frameNStart = frameN;  // exact frame index
       
       init_circle_58.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_58.status === PsychoJS.Status.STARTED || init_circle_58.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_58.setAutoDraw(false);
     }
     
     // *init_circle_59* updates
     if (t >= 0 && init_circle_59.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_59.tStart = t;  // (not accounting for frame time here)
       init_circle_59.frameNStart = frameN;  // exact frame index
       
       init_circle_59.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_59.status === PsychoJS.Status.STARTED || init_circle_59.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_59.setAutoDraw(false);
     }
     
     // *init_circle_60* updates
     if (t >= 0 && init_circle_60.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_60.tStart = t;  // (not accounting for frame time here)
       init_circle_60.frameNStart = frameN;  // exact frame index
       
       init_circle_60.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_60.status === PsychoJS.Status.STARTED || init_circle_60.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_60.setAutoDraw(false);
     }
     
     // *init_circle_61* updates
     if (t >= 0 && init_circle_61.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_61.tStart = t;  // (not accounting for frame time here)
       init_circle_61.frameNStart = frameN;  // exact frame index
       
       init_circle_61.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_61.status === PsychoJS.Status.STARTED || init_circle_61.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_61.setAutoDraw(false);
     }
     
     // *b_For_example_4* updates
     if (t >= 0.0 && b_For_example_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       b_For_example_4.tStart = t;  // (not accounting for frame time here)
       b_For_example_4.frameNStart = frameN;  // exact frame index
       
       b_For_example_4.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((b_For_example_4.status === PsychoJS.Status.STARTED || b_For_example_4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       b_For_example_4.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Circles_Example_3Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Circles_Example_3RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Circles_Example_3'-------
     for (const thisComponent of Circles_Example_3Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Circle_Example_4Components;
 function Circle_Example_4RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Circle_Example_4'-------
     t = 0;
     Circle_Example_4Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(0.900000);
     // update component parameters for each repeat
     // keep track of which components have finished
     Circle_Example_4Components = [];
     Circle_Example_4Components.push(init_circle_51);
     Circle_Example_4Components.push(init_circle_62);
     Circle_Example_4Components.push(init_circle_64);
     Circle_Example_4Components.push(init_circle_65);
     Circle_Example_4Components.push(init_circle_66);
     Circle_Example_4Components.push(init_circle_80);
     Circle_Example_4Components.push(init_circle_67);
     Circle_Example_4Components.push(init_circle_68);
     Circle_Example_4Components.push(init_circle_69);
     Circle_Example_4Components.push(init_circle_70);
     Circle_Example_4Components.push(init_circle_71);
     Circle_Example_4Components.push(init_circle_72);
     Circle_Example_4Components.push(init_circle_73);
     Circle_Example_4Components.push(init_circle_74);
     Circle_Example_4Components.push(circle_15_lights_up);
     Circle_Example_4Components.push(init_circle_76);
     Circle_Example_4Components.push(For_example_5);
     
     for (const thisComponent of Circle_Example_4Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Circle_Example_4RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Circle_Example_4'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Circle_Example_4Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *init_circle_51* updates
     if (t >= 0 && init_circle_51.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_51.tStart = t;  // (not accounting for frame time here)
       init_circle_51.frameNStart = frameN;  // exact frame index
       
       init_circle_51.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_51.status === PsychoJS.Status.STARTED || init_circle_51.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_51.setAutoDraw(false);
     }
     
     // *init_circle_62* updates
     if (t >= 0 && init_circle_62.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_62.tStart = t;  // (not accounting for frame time here)
       init_circle_62.frameNStart = frameN;  // exact frame index
       
       init_circle_62.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_62.status === PsychoJS.Status.STARTED || init_circle_62.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_62.setAutoDraw(false);
     }
     
     // *init_circle_64* updates
     if (t >= 0 && init_circle_64.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_64.tStart = t;  // (not accounting for frame time here)
       init_circle_64.frameNStart = frameN;  // exact frame index
       
       init_circle_64.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_64.status === PsychoJS.Status.STARTED || init_circle_64.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_64.setAutoDraw(false);
     }
     
     // *init_circle_65* updates
     if (t >= 0 && init_circle_65.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_65.tStart = t;  // (not accounting for frame time here)
       init_circle_65.frameNStart = frameN;  // exact frame index
       
       init_circle_65.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_65.status === PsychoJS.Status.STARTED || init_circle_65.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_65.setAutoDraw(false);
     }
     
     // *init_circle_66* updates
     if (t >= 0 && init_circle_66.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_66.tStart = t;  // (not accounting for frame time here)
       init_circle_66.frameNStart = frameN;  // exact frame index
       
       init_circle_66.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_66.status === PsychoJS.Status.STARTED || init_circle_66.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_66.setAutoDraw(false);
     }
     
     // *init_circle_80* updates
     if (t >= 0 && init_circle_80.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_80.tStart = t;  // (not accounting for frame time here)
       init_circle_80.frameNStart = frameN;  // exact frame index
       
       init_circle_80.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_80.status === PsychoJS.Status.STARTED || init_circle_80.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_80.setAutoDraw(false);
     }
     
     // *init_circle_67* updates
     if (t >= 0 && init_circle_67.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_67.tStart = t;  // (not accounting for frame time here)
       init_circle_67.frameNStart = frameN;  // exact frame index
       
       init_circle_67.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_67.status === PsychoJS.Status.STARTED || init_circle_67.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_67.setAutoDraw(false);
     }
     
     // *init_circle_68* updates
     if (t >= 0 && init_circle_68.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_68.tStart = t;  // (not accounting for frame time here)
       init_circle_68.frameNStart = frameN;  // exact frame index
       
       init_circle_68.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_68.status === PsychoJS.Status.STARTED || init_circle_68.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_68.setAutoDraw(false);
     }
     
     // *init_circle_69* updates
     if (t >= 0 && init_circle_69.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_69.tStart = t;  // (not accounting for frame time here)
       init_circle_69.frameNStart = frameN;  // exact frame index
       
       init_circle_69.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_69.status === PsychoJS.Status.STARTED || init_circle_69.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_69.setAutoDraw(false);
     }
     
     // *init_circle_70* updates
     if (t >= 0 && init_circle_70.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_70.tStart = t;  // (not accounting for frame time here)
       init_circle_70.frameNStart = frameN;  // exact frame index
       
       init_circle_70.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_70.status === PsychoJS.Status.STARTED || init_circle_70.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_70.setAutoDraw(false);
     }
     
     // *init_circle_71* updates
     if (t >= 0 && init_circle_71.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_71.tStart = t;  // (not accounting for frame time here)
       init_circle_71.frameNStart = frameN;  // exact frame index
       
       init_circle_71.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_71.status === PsychoJS.Status.STARTED || init_circle_71.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_71.setAutoDraw(false);
     }
     
     // *init_circle_72* updates
     if (t >= 0 && init_circle_72.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_72.tStart = t;  // (not accounting for frame time here)
       init_circle_72.frameNStart = frameN;  // exact frame index
       
       init_circle_72.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_72.status === PsychoJS.Status.STARTED || init_circle_72.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_72.setAutoDraw(false);
     }
     
     // *init_circle_73* updates
     if (t >= 0 && init_circle_73.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_73.tStart = t;  // (not accounting for frame time here)
       init_circle_73.frameNStart = frameN;  // exact frame index
       
       init_circle_73.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_73.status === PsychoJS.Status.STARTED || init_circle_73.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_73.setAutoDraw(false);
     }
     
     // *init_circle_74* updates
     if (t >= 0 && init_circle_74.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_74.tStart = t;  // (not accounting for frame time here)
       init_circle_74.frameNStart = frameN;  // exact frame index
       
       init_circle_74.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_74.status === PsychoJS.Status.STARTED || init_circle_74.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_74.setAutoDraw(false);
     }
     
     // *circle_15_lights_up* updates
     if (t >= 0 && circle_15_lights_up.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       circle_15_lights_up.tStart = t;  // (not accounting for frame time here)
       circle_15_lights_up.frameNStart = frameN;  // exact frame index
       
       circle_15_lights_up.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((circle_15_lights_up.status === PsychoJS.Status.STARTED || circle_15_lights_up.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       circle_15_lights_up.setAutoDraw(false);
     }
     
     // *init_circle_76* updates
     if (t >= 0 && init_circle_76.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_76.tStart = t;  // (not accounting for frame time here)
       init_circle_76.frameNStart = frameN;  // exact frame index
       
       init_circle_76.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_76.status === PsychoJS.Status.STARTED || init_circle_76.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_76.setAutoDraw(false);
     }
     
     // *For_example_5* updates
     if (t >= 0.0 && For_example_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       For_example_5.tStart = t;  // (not accounting for frame time here)
       For_example_5.frameNStart = frameN;  // exact frame index
       
       For_example_5.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((For_example_5.status === PsychoJS.Status.STARTED || For_example_5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       For_example_5.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Circle_Example_4Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Circle_Example_4RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Circle_Example_4'-------
     for (const thisComponent of Circle_Example_4Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Initial_CirclesComponents;
 function Initial_CirclesRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Initial_Circles'-------
     t = 0;
     Initial_CirclesClock.reset(); // clock
     frameN = -1;
     routineTimer.add(0.500000);
     // update component parameters for each repeat
     // keep track of which components have finished
     Initial_CirclesComponents = [];
     Initial_CirclesComponents.push(init_circle_1);
     Initial_CirclesComponents.push(init_circle_2);
     Initial_CirclesComponents.push(init_circle_3);
     Initial_CirclesComponents.push(init_circle_4);
     Initial_CirclesComponents.push(init_circle_5);
     Initial_CirclesComponents.push(init_circle_6);
     Initial_CirclesComponents.push(init_circle_7);
     Initial_CirclesComponents.push(init_circle_8);
     Initial_CirclesComponents.push(init_circle_9);
     Initial_CirclesComponents.push(init_circle_10);
     Initial_CirclesComponents.push(init_circle_11);
     Initial_CirclesComponents.push(init_circle_12);
     Initial_CirclesComponents.push(init_circle_13);
     Initial_CirclesComponents.push(init_circle_14);
     Initial_CirclesComponents.push(init_circle_15);
     Initial_CirclesComponents.push(init_circle_16);
     
     for (const thisComponent of Initial_CirclesComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Initial_CirclesRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Initial_Circles'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Initial_CirclesClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *init_circle_1* updates
     if (t >= 0 && init_circle_1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_1.tStart = t;  // (not accounting for frame time here)
       init_circle_1.frameNStart = frameN;  // exact frame index
       
       init_circle_1.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_1.status === PsychoJS.Status.STARTED || init_circle_1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_1.setAutoDraw(false);
     }
     
     // *init_circle_2* updates
     if (t >= 0 && init_circle_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_2.tStart = t;  // (not accounting for frame time here)
       init_circle_2.frameNStart = frameN;  // exact frame index
       
       init_circle_2.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_2.status === PsychoJS.Status.STARTED || init_circle_2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_2.setAutoDraw(false);
     }
     
     // *init_circle_3* updates
     if (t >= 0 && init_circle_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_3.tStart = t;  // (not accounting for frame time here)
       init_circle_3.frameNStart = frameN;  // exact frame index
       
       init_circle_3.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_3.status === PsychoJS.Status.STARTED || init_circle_3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_3.setAutoDraw(false);
     }
     
     // *init_circle_4* updates
     if (t >= 0 && init_circle_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_4.tStart = t;  // (not accounting for frame time here)
       init_circle_4.frameNStart = frameN;  // exact frame index
       
       init_circle_4.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_4.status === PsychoJS.Status.STARTED || init_circle_4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_4.setAutoDraw(false);
     }
     
     // *init_circle_5* updates
     if (t >= 0 && init_circle_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_5.tStart = t;  // (not accounting for frame time here)
       init_circle_5.frameNStart = frameN;  // exact frame index
       
       init_circle_5.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_5.status === PsychoJS.Status.STARTED || init_circle_5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_5.setAutoDraw(false);
     }
     
     // *init_circle_6* updates
     if (t >= 0 && init_circle_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_6.tStart = t;  // (not accounting for frame time here)
       init_circle_6.frameNStart = frameN;  // exact frame index
       
       init_circle_6.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_6.status === PsychoJS.Status.STARTED || init_circle_6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_6.setAutoDraw(false);
     }
     
     // *init_circle_7* updates
     if (t >= 0 && init_circle_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_7.tStart = t;  // (not accounting for frame time here)
       init_circle_7.frameNStart = frameN;  // exact frame index
       
       init_circle_7.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_7.status === PsychoJS.Status.STARTED || init_circle_7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_7.setAutoDraw(false);
     }
     
     // *init_circle_8* updates
     if (t >= 0 && init_circle_8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_8.tStart = t;  // (not accounting for frame time here)
       init_circle_8.frameNStart = frameN;  // exact frame index
       
       init_circle_8.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_8.status === PsychoJS.Status.STARTED || init_circle_8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_8.setAutoDraw(false);
     }
     
     // *init_circle_9* updates
     if (t >= 0 && init_circle_9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_9.tStart = t;  // (not accounting for frame time here)
       init_circle_9.frameNStart = frameN;  // exact frame index
       
       init_circle_9.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_9.status === PsychoJS.Status.STARTED || init_circle_9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_9.setAutoDraw(false);
     }
     
     // *init_circle_10* updates
     if (t >= 0 && init_circle_10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_10.tStart = t;  // (not accounting for frame time here)
       init_circle_10.frameNStart = frameN;  // exact frame index
       
       init_circle_10.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_10.status === PsychoJS.Status.STARTED || init_circle_10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_10.setAutoDraw(false);
     }
     
     // *init_circle_11* updates
     if (t >= 0 && init_circle_11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_11.tStart = t;  // (not accounting for frame time here)
       init_circle_11.frameNStart = frameN;  // exact frame index
       
       init_circle_11.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_11.status === PsychoJS.Status.STARTED || init_circle_11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_11.setAutoDraw(false);
     }
     
     // *init_circle_12* updates
     if (t >= 0 && init_circle_12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_12.tStart = t;  // (not accounting for frame time here)
       init_circle_12.frameNStart = frameN;  // exact frame index
       
       init_circle_12.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_12.status === PsychoJS.Status.STARTED || init_circle_12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_12.setAutoDraw(false);
     }
     
     // *init_circle_13* updates
     if (t >= 0 && init_circle_13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_13.tStart = t;  // (not accounting for frame time here)
       init_circle_13.frameNStart = frameN;  // exact frame index
       
       init_circle_13.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_13.status === PsychoJS.Status.STARTED || init_circle_13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_13.setAutoDraw(false);
     }
     
     // *init_circle_14* updates
     if (t >= 0 && init_circle_14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_14.tStart = t;  // (not accounting for frame time here)
       init_circle_14.frameNStart = frameN;  // exact frame index
       
       init_circle_14.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_14.status === PsychoJS.Status.STARTED || init_circle_14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_14.setAutoDraw(false);
     }
     
     // *init_circle_15* updates
     if (t >= 0 && init_circle_15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_15.tStart = t;  // (not accounting for frame time here)
       init_circle_15.frameNStart = frameN;  // exact frame index
       
       init_circle_15.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_15.status === PsychoJS.Status.STARTED || init_circle_15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_15.setAutoDraw(false);
     }
     
     // *init_circle_16* updates
     if (t >= 0 && init_circle_16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       init_circle_16.tStart = t;  // (not accounting for frame time here)
       init_circle_16.frameNStart = frameN;  // exact frame index
       
       init_circle_16.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((init_circle_16.status === PsychoJS.Status.STARTED || init_circle_16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       init_circle_16.setAutoDraw(false);
     }
     if ((circle_loop < 3)) {
         if ((practice_correct === 1)) {
             continueRoutine = false;
         }
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Initial_CirclesComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Initial_CirclesRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Initial_Circles'-------
     for (const thisComponent of Initial_CirclesComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var gotValidClick;
 var clicked_frame;
 var Circle_Example_5AComponents;
 function Circle_Example_5ARoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Circle_Example_5A'-------
     t = 0;
     Circle_Example_5AClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the first_mouse_response_example
     // current position of the mouse:
     first_mouse_response_example.x = [];
     first_mouse_response_example.y = [];
     first_mouse_response_example.leftButton = [];
     first_mouse_response_example.midButton = [];
     first_mouse_response_example.rightButton = [];
     first_mouse_response_example.time = [];
     first_mouse_response_example.clicked_name = [];
     gotValidClick = false; // until a click is received
     first_mouse_response_example.mouseClock.reset();
     clicked_frame = null;
     
     // keep track of which components have finished
     Circle_Example_5AComponents = [];
     Circle_Example_5AComponents.push(first_response_C1_example);
     Circle_Example_5AComponents.push(first_response_C2_example);
     Circle_Example_5AComponents.push(first_response_C3_example);
     Circle_Example_5AComponents.push(first_response_C4_example);
     Circle_Example_5AComponents.push(first_response_C5_example);
     Circle_Example_5AComponents.push(first_response_C6_example);
     Circle_Example_5AComponents.push(first_response_C7_example);
     Circle_Example_5AComponents.push(first_response_C8_example);
     Circle_Example_5AComponents.push(first_response_C9_example);
     Circle_Example_5AComponents.push(first_response_C10_example);
     Circle_Example_5AComponents.push(first_response_C11_example);
     Circle_Example_5AComponents.push(first_response_C12_example);
     Circle_Example_5AComponents.push(first_response_C13_example);
     Circle_Example_5AComponents.push(first_response_C14_example);
     Circle_Example_5AComponents.push(first_response_C15_example);
     Circle_Example_5AComponents.push(first_response_C16_example);
     Circle_Example_5AComponents.push(first_mouse_response_example);
     Circle_Example_5AComponents.push(polygon);
     Circle_Example_5AComponents.push(triangle);
     Circle_Example_5AComponents.push(push_these_circles);
     
     for (const thisComponent of Circle_Example_5AComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 var prevButtonState;
 var _mouseButtons;
 var _mouseXYs;
 var clicked_circle;
 function Circle_Example_5ARoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Circle_Example_5A'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Circle_Example_5AClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *first_response_C1_example* updates
     if (t >= 0 && first_response_C1_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C1_example.tStart = t;  // (not accounting for frame time here)
       first_response_C1_example.frameNStart = frameN;  // exact frame index
       
       first_response_C1_example.setAutoDraw(true);
     }
 
     
     // *first_response_C2_example* updates
     if (t >= 0 && first_response_C2_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C2_example.tStart = t;  // (not accounting for frame time here)
       first_response_C2_example.frameNStart = frameN;  // exact frame index
       
       first_response_C2_example.setAutoDraw(true);
     }
 
     
     // *first_response_C3_example* updates
     if (t >= 0 && first_response_C3_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C3_example.tStart = t;  // (not accounting for frame time here)
       first_response_C3_example.frameNStart = frameN;  // exact frame index
       
       first_response_C3_example.setAutoDraw(true);
     }
 
     
     // *first_response_C4_example* updates
     if (t >= 0 && first_response_C4_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C4_example.tStart = t;  // (not accounting for frame time here)
       first_response_C4_example.frameNStart = frameN;  // exact frame index
       
       first_response_C4_example.setAutoDraw(true);
     }
 
     
     // *first_response_C5_example* updates
     if (t >= 0 && first_response_C5_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C5_example.tStart = t;  // (not accounting for frame time here)
       first_response_C5_example.frameNStart = frameN;  // exact frame index
       
       first_response_C5_example.setAutoDraw(true);
     }
 
     
     // *first_response_C6_example* updates
     if (t >= 0 && first_response_C6_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C6_example.tStart = t;  // (not accounting for frame time here)
       first_response_C6_example.frameNStart = frameN;  // exact frame index
       
       first_response_C6_example.setAutoDraw(true);
     }
 
     
     // *first_response_C7_example* updates
     if (t >= 0 && first_response_C7_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C7_example.tStart = t;  // (not accounting for frame time here)
       first_response_C7_example.frameNStart = frameN;  // exact frame index
       
       first_response_C7_example.setAutoDraw(true);
     }
 
     
     // *first_response_C8_example* updates
     if (t >= 0 && first_response_C8_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C8_example.tStart = t;  // (not accounting for frame time here)
       first_response_C8_example.frameNStart = frameN;  // exact frame index
       
       first_response_C8_example.setAutoDraw(true);
     }
 
     
     // *first_response_C9_example* updates
     if (t >= 0 && first_response_C9_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C9_example.tStart = t;  // (not accounting for frame time here)
       first_response_C9_example.frameNStart = frameN;  // exact frame index
       
       first_response_C9_example.setAutoDraw(true);
     }
 
     
     // *first_response_C10_example* updates
     if (t >= 0 && first_response_C10_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C10_example.tStart = t;  // (not accounting for frame time here)
       first_response_C10_example.frameNStart = frameN;  // exact frame index
       
       first_response_C10_example.setAutoDraw(true);
     }
 
     
     // *first_response_C11_example* updates
     if (t >= 0 && first_response_C11_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C11_example.tStart = t;  // (not accounting for frame time here)
       first_response_C11_example.frameNStart = frameN;  // exact frame index
       
       first_response_C11_example.setAutoDraw(true);
     }
 
     
     // *first_response_C12_example* updates
     if (t >= 0 && first_response_C12_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C12_example.tStart = t;  // (not accounting for frame time here)
       first_response_C12_example.frameNStart = frameN;  // exact frame index
       
       first_response_C12_example.setAutoDraw(true);
     }
 
     
     // *first_response_C13_example* updates
     if (t >= 0 && first_response_C13_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C13_example.tStart = t;  // (not accounting for frame time here)
       first_response_C13_example.frameNStart = frameN;  // exact frame index
       
       first_response_C13_example.setAutoDraw(true);
     }
 
     
     // *first_response_C14_example* updates
     if (t >= 0 && first_response_C14_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C14_example.tStart = t;  // (not accounting for frame time here)
       first_response_C14_example.frameNStart = frameN;  // exact frame index
       
       first_response_C14_example.setAutoDraw(true);
     }
 
     
     // *first_response_C15_example* updates
     if (t >= 0 && first_response_C15_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C15_example.tStart = t;  // (not accounting for frame time here)
       first_response_C15_example.frameNStart = frameN;  // exact frame index
       
       first_response_C15_example.setAutoDraw(true);
     }
 
     
     // *first_response_C16_example* updates
     if (t >= 0 && first_response_C16_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C16_example.tStart = t;  // (not accounting for frame time here)
       first_response_C16_example.frameNStart = frameN;  // exact frame index
       
       first_response_C16_example.setAutoDraw(true);
     }
 
     // *first_mouse_response_example* updates
     if (t >= 0.0 && first_mouse_response_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_mouse_response_example.tStart = t;  // (not accounting for frame time here)
       first_mouse_response_example.frameNStart = frameN;  // exact frame index
       
       first_mouse_response_example.status = PsychoJS.Status.STARTED;
       prevButtonState = first_mouse_response_example.getPressed();  // if button is down already this ISN'T a new click
       }
     if (first_mouse_response_example.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = first_mouse_response_example.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = first_mouse_response_example.getPos();
           first_mouse_response_example.x.push(_mouseXYs[0]);
           first_mouse_response_example.y.push(_mouseXYs[1]);
           first_mouse_response_example.leftButton.push(_mouseButtons[0]);
           first_mouse_response_example.midButton.push(_mouseButtons[1]);
           first_mouse_response_example.rightButton.push(_mouseButtons[2]);
           first_mouse_response_example.time.push(first_mouse_response_example.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [first_response_C15_example]) {
             if (obj.contains(first_mouse_response_example)) {
               gotValidClick = true;
               first_mouse_response_example.clicked_name.push(obj.name)
             }
           }
         }
       }
     }
     if (((first_mouse_response_example.clicked_name.length > 0) && (clicked_frame === null))) {
         clicked_frame = frameN;
         console.log(clicked_frame);
         clicked_circle = eval(first_mouse_response_example.clicked_name[0]);
         console.log(clicked_circle);
         clicked_circle.setFillColor(new util.Color([1, 1, 1]));
     }
     if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
         clicked_circle.setFillColor([(- 1.0), (- 1.0), (- 1.0)]);
         continueRoutine = false;
     }
     
     
     // *polygon* updates
     if (t >= 0.0 && polygon.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       polygon.tStart = t;  // (not accounting for frame time here)
       polygon.frameNStart = frameN;  // exact frame index
       
       polygon.setAutoDraw(true);
     }
 
     
     // *triangle* updates
     if (t >= 0.0 && triangle.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       triangle.tStart = t;  // (not accounting for frame time here)
       triangle.frameNStart = frameN;  // exact frame index
       
       triangle.setAutoDraw(true);
     }
 
     
     // *push_these_circles* updates
     if (t >= 0.0 && push_these_circles.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       push_these_circles.tStart = t;  // (not accounting for frame time here)
       push_these_circles.frameNStart = frameN;  // exact frame index
       
       push_these_circles.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Circle_Example_5AComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Circle_Example_5ARoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Circle_Example_5A'-------
     for (const thisComponent of Circle_Example_5AComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('first_mouse_response_example.x', first_mouse_response_example.x);
     psychoJS.experiment.addData('first_mouse_response_example.y', first_mouse_response_example.y);
     psychoJS.experiment.addData('first_mouse_response_example.leftButton', first_mouse_response_example.leftButton);
     psychoJS.experiment.addData('first_mouse_response_example.midButton', first_mouse_response_example.midButton);
     psychoJS.experiment.addData('first_mouse_response_example.rightButton', first_mouse_response_example.rightButton);
     psychoJS.experiment.addData('first_mouse_response_example.time', first_mouse_response_example.time);
     psychoJS.experiment.addData('first_mouse_response_example.clicked_name', first_mouse_response_example.clicked_name);
     
     // the Routine "Circle_Example_5A" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Circle_Example_6Components;
 function Circle_Example_6RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Circle_Example_6'-------
     t = 0;
     Circle_Example_6Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the second_mouse_response_example
     // current position of the mouse:
     second_mouse_response_example.x = [];
     second_mouse_response_example.y = [];
     second_mouse_response_example.leftButton = [];
     second_mouse_response_example.midButton = [];
     second_mouse_response_example.rightButton = [];
     second_mouse_response_example.time = [];
     second_mouse_response_example.clicked_name = [];
     gotValidClick = false; // until a click is received
     second_mouse_response_example.mouseClock.reset();
     clicked_frame = null;
     
     // keep track of which components have finished
     Circle_Example_6Components = [];
     Circle_Example_6Components.push(second_response_C1_example);
     Circle_Example_6Components.push(second_response_C2_example);
     Circle_Example_6Components.push(second_response_C3_example);
     Circle_Example_6Components.push(second_response_C4_example);
     Circle_Example_6Components.push(second_response_C5_example);
     Circle_Example_6Components.push(second_response_C6_example);
     Circle_Example_6Components.push(second_response_C7_example);
     Circle_Example_6Components.push(second_response_C8_example);
     Circle_Example_6Components.push(second_response_C9_example);
     Circle_Example_6Components.push(second_response_C10_example);
     Circle_Example_6Components.push(second_response_C11_example);
     Circle_Example_6Components.push(second_response_C12_example);
     Circle_Example_6Components.push(second_response_C13_example);
     Circle_Example_6Components.push(second_response_C14_example);
     Circle_Example_6Components.push(second_response_C15_example);
     Circle_Example_6Components.push(second_response_C16_example);
     Circle_Example_6Components.push(second_mouse_response_example);
     Circle_Example_6Components.push(polygon_2);
     Circle_Example_6Components.push(triangle_2);
     Circle_Example_6Components.push(push_these_circles_2);
     
     for (const thisComponent of Circle_Example_6Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Circle_Example_6RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Circle_Example_6'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Circle_Example_6Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *second_response_C1_example* updates
     if (t >= 0 && second_response_C1_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C1_example.tStart = t;  // (not accounting for frame time here)
       second_response_C1_example.frameNStart = frameN;  // exact frame index
       
       second_response_C1_example.setAutoDraw(true);
     }
 
     
     // *second_response_C2_example* updates
     if (t >= 0 && second_response_C2_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C2_example.tStart = t;  // (not accounting for frame time here)
       second_response_C2_example.frameNStart = frameN;  // exact frame index
       
       second_response_C2_example.setAutoDraw(true);
     }
 
     
     // *second_response_C3_example* updates
     if (t >= 0 && second_response_C3_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C3_example.tStart = t;  // (not accounting for frame time here)
       second_response_C3_example.frameNStart = frameN;  // exact frame index
       
       second_response_C3_example.setAutoDraw(true);
     }
 
     
     // *second_response_C4_example* updates
     if (t >= 0 && second_response_C4_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C4_example.tStart = t;  // (not accounting for frame time here)
       second_response_C4_example.frameNStart = frameN;  // exact frame index
       
       second_response_C4_example.setAutoDraw(true);
     }
 
     
     // *second_response_C5_example* updates
     if (t >= 0 && second_response_C5_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C5_example.tStart = t;  // (not accounting for frame time here)
       second_response_C5_example.frameNStart = frameN;  // exact frame index
       
       second_response_C5_example.setAutoDraw(true);
     }
 
     
     // *second_response_C6_example* updates
     if (t >= 0 && second_response_C6_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C6_example.tStart = t;  // (not accounting for frame time here)
       second_response_C6_example.frameNStart = frameN;  // exact frame index
       
       second_response_C6_example.setAutoDraw(true);
     }
 
     
     // *second_response_C7_example* updates
     if (t >= 0 && second_response_C7_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C7_example.tStart = t;  // (not accounting for frame time here)
       second_response_C7_example.frameNStart = frameN;  // exact frame index
       
       second_response_C7_example.setAutoDraw(true);
     }
 
     
     // *second_response_C8_example* updates
     if (t >= 0 && second_response_C8_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C8_example.tStart = t;  // (not accounting for frame time here)
       second_response_C8_example.frameNStart = frameN;  // exact frame index
       
       second_response_C8_example.setAutoDraw(true);
     }
 
     
     // *second_response_C9_example* updates
     if (t >= 0 && second_response_C9_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C9_example.tStart = t;  // (not accounting for frame time here)
       second_response_C9_example.frameNStart = frameN;  // exact frame index
       
       second_response_C9_example.setAutoDraw(true);
     }
 
     
     // *second_response_C10_example* updates
     if (t >= 0 && second_response_C10_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C10_example.tStart = t;  // (not accounting for frame time here)
       second_response_C10_example.frameNStart = frameN;  // exact frame index
       
       second_response_C10_example.setAutoDraw(true);
     }
 
     
     // *second_response_C11_example* updates
     if (t >= 0 && second_response_C11_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C11_example.tStart = t;  // (not accounting for frame time here)
       second_response_C11_example.frameNStart = frameN;  // exact frame index
       
       second_response_C11_example.setAutoDraw(true);
     }
 
     
     // *second_response_C12_example* updates
     if (t >= 0 && second_response_C12_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C12_example.tStart = t;  // (not accounting for frame time here)
       second_response_C12_example.frameNStart = frameN;  // exact frame index
       
       second_response_C12_example.setAutoDraw(true);
     }
 
     
     // *second_response_C13_example* updates
     if (t >= 0 && second_response_C13_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C13_example.tStart = t;  // (not accounting for frame time here)
       second_response_C13_example.frameNStart = frameN;  // exact frame index
       
       second_response_C13_example.setAutoDraw(true);
     }
 
     
     // *second_response_C14_example* updates
     if (t >= 0 && second_response_C14_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C14_example.tStart = t;  // (not accounting for frame time here)
       second_response_C14_example.frameNStart = frameN;  // exact frame index
       
       second_response_C14_example.setAutoDraw(true);
     }
 
     
     // *second_response_C15_example* updates
     if (t >= 0 && second_response_C15_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C15_example.tStart = t;  // (not accounting for frame time here)
       second_response_C15_example.frameNStart = frameN;  // exact frame index
       
       second_response_C15_example.setAutoDraw(true);
     }
 
     
     // *second_response_C16_example* updates
     if (t >= 0 && second_response_C16_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C16_example.tStart = t;  // (not accounting for frame time here)
       second_response_C16_example.frameNStart = frameN;  // exact frame index
       
       second_response_C16_example.setAutoDraw(true);
     }
 
     // *second_mouse_response_example* updates
     if (t >= 0.0 && second_mouse_response_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_mouse_response_example.tStart = t;  // (not accounting for frame time here)
       second_mouse_response_example.frameNStart = frameN;  // exact frame index
       
       second_mouse_response_example.status = PsychoJS.Status.STARTED;
       prevButtonState = second_mouse_response_example.getPressed();  // if button is down already this ISN'T a new click
       }
     if (second_mouse_response_example.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = second_mouse_response_example.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = second_mouse_response_example.getPos();
           second_mouse_response_example.x.push(_mouseXYs[0]);
           second_mouse_response_example.y.push(_mouseXYs[1]);
           second_mouse_response_example.leftButton.push(_mouseButtons[0]);
           second_mouse_response_example.midButton.push(_mouseButtons[1]);
           second_mouse_response_example.rightButton.push(_mouseButtons[2]);
           second_mouse_response_example.time.push(second_mouse_response_example.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [second_response_C6_example]) {
             if (obj.contains(second_mouse_response_example)) {
               gotValidClick = true;
               second_mouse_response_example.clicked_name.push(obj.name)
             }
           }
         }
       }
     }
     if (((second_mouse_response_example.clicked_name.length > 0) && (clicked_frame === null))) {
         clicked_frame = frameN;
         clicked_circle = eval(second_mouse_response_example.clicked_name[0]);
         clicked_circle.setFillColor(new util.Color([1, 1, 1]));
     }
     if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
         clicked_circle.setFillColor(new util.Color([-1, -1, -1]));
         continueRoutine = false;
     }
     
     
     // *polygon_2* updates
     if (t >= 0.0 && polygon_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       polygon_2.tStart = t;  // (not accounting for frame time here)
       polygon_2.frameNStart = frameN;  // exact frame index
       
       polygon_2.setAutoDraw(true);
     }
 
     
     // *triangle_2* updates
     if (t >= 0.0 && triangle_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       triangle_2.tStart = t;  // (not accounting for frame time here)
       triangle_2.frameNStart = frameN;  // exact frame index
       
       triangle_2.setAutoDraw(true);
     }
 
     
     // *push_these_circles_2* updates
     if (t >= 0.0 && push_these_circles_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       push_these_circles_2.tStart = t;  // (not accounting for frame time here)
       push_these_circles_2.frameNStart = frameN;  // exact frame index
       
       push_these_circles_2.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Circle_Example_6Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Circle_Example_6RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Circle_Example_6'-------
     for (const thisComponent of Circle_Example_6Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('second_mouse_response_example.x', second_mouse_response_example.x);
     psychoJS.experiment.addData('second_mouse_response_example.y', second_mouse_response_example.y);
     psychoJS.experiment.addData('second_mouse_response_example.leftButton', second_mouse_response_example.leftButton);
     psychoJS.experiment.addData('second_mouse_response_example.midButton', second_mouse_response_example.midButton);
     psychoJS.experiment.addData('second_mouse_response_example.rightButton', second_mouse_response_example.rightButton);
     psychoJS.experiment.addData('second_mouse_response_example.time', second_mouse_response_example.time);
     psychoJS.experiment.addData('second_mouse_response_example.clicked_name', second_mouse_response_example.clicked_name);
     
     /* Syntax Error: Fix Python code */
     // the Routine "Circle_Example_6" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Circle_Example_7Components;
 function Circle_Example_7RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Circle_Example_7'-------
     t = 0;
     Circle_Example_7Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the third_mouse_response_example
     // current position of the mouse:
     third_mouse_response_example.x = [];
     third_mouse_response_example.y = [];
     third_mouse_response_example.leftButton = [];
     third_mouse_response_example.midButton = [];
     third_mouse_response_example.rightButton = [];
     third_mouse_response_example.time = [];
     third_mouse_response_example.clicked_name = [];
     gotValidClick = false; // until a click is received
     third_mouse_response_example.mouseClock.reset();
     clicked_frame = null;
     
     // keep track of which components have finished
     Circle_Example_7Components = [];
     Circle_Example_7Components.push(third_response_C1_example);
     Circle_Example_7Components.push(third_response_C2_example);
     Circle_Example_7Components.push(third_response_C3_example);
     Circle_Example_7Components.push(third_response_C4_example);
     Circle_Example_7Components.push(third_response_C5_example);
     Circle_Example_7Components.push(third_response_C6_example);
     Circle_Example_7Components.push(third_response_C7_example);
     Circle_Example_7Components.push(third_response_C8_example);
     Circle_Example_7Components.push(third_response_C9_example);
     Circle_Example_7Components.push(third_response_C10_example);
     Circle_Example_7Components.push(third_response_C11_example);
     Circle_Example_7Components.push(third_response_C12_example);
     Circle_Example_7Components.push(third_response_C13_example);
     Circle_Example_7Components.push(third_response_C14_example);
     Circle_Example_7Components.push(third_response_C15_example);
     Circle_Example_7Components.push(third_response_C16_example);
     Circle_Example_7Components.push(third_mouse_response_example);
     Circle_Example_7Components.push(polygon_3);
     Circle_Example_7Components.push(triangle_3);
     Circle_Example_7Components.push(push_these_circles_3);
     
     for (const thisComponent of Circle_Example_7Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Circle_Example_7RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Circle_Example_7'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Circle_Example_7Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *third_response_C1_example* updates
     if (t >= 0 && third_response_C1_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C1_example.tStart = t;  // (not accounting for frame time here)
       third_response_C1_example.frameNStart = frameN;  // exact frame index
       
       third_response_C1_example.setAutoDraw(true);
     }
 
     
     // *third_response_C2_example* updates
     if (t >= 0 && third_response_C2_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C2_example.tStart = t;  // (not accounting for frame time here)
       third_response_C2_example.frameNStart = frameN;  // exact frame index
       
       third_response_C2_example.setAutoDraw(true);
     }
 
     
     // *third_response_C3_example* updates
     if (t >= 0 && third_response_C3_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C3_example.tStart = t;  // (not accounting for frame time here)
       third_response_C3_example.frameNStart = frameN;  // exact frame index
       
       third_response_C3_example.setAutoDraw(true);
     }
 
     
     // *third_response_C4_example* updates
     if (t >= 0 && third_response_C4_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C4_example.tStart = t;  // (not accounting for frame time here)
       third_response_C4_example.frameNStart = frameN;  // exact frame index
       
       third_response_C4_example.setAutoDraw(true);
     }
 
     
     // *third_response_C5_example* updates
     if (t >= 0 && third_response_C5_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C5_example.tStart = t;  // (not accounting for frame time here)
       third_response_C5_example.frameNStart = frameN;  // exact frame index
       
       third_response_C5_example.setAutoDraw(true);
     }
 
     
     // *third_response_C6_example* updates
     if (t >= 0 && third_response_C6_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C6_example.tStart = t;  // (not accounting for frame time here)
       third_response_C6_example.frameNStart = frameN;  // exact frame index
       
       third_response_C6_example.setAutoDraw(true);
     }
 
     
     // *third_response_C7_example* updates
     if (t >= 0 && third_response_C7_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C7_example.tStart = t;  // (not accounting for frame time here)
       third_response_C7_example.frameNStart = frameN;  // exact frame index
       
       third_response_C7_example.setAutoDraw(true);
     }
 
     
     // *third_response_C8_example* updates
     if (t >= 0 && third_response_C8_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C8_example.tStart = t;  // (not accounting for frame time here)
       third_response_C8_example.frameNStart = frameN;  // exact frame index
       
       third_response_C8_example.setAutoDraw(true);
     }
 
     
     // *third_response_C9_example* updates
     if (t >= 0 && third_response_C9_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C9_example.tStart = t;  // (not accounting for frame time here)
       third_response_C9_example.frameNStart = frameN;  // exact frame index
       
       third_response_C9_example.setAutoDraw(true);
     }
 
     
     // *third_response_C10_example* updates
     if (t >= 0 && third_response_C10_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C10_example.tStart = t;  // (not accounting for frame time here)
       third_response_C10_example.frameNStart = frameN;  // exact frame index
       
       third_response_C10_example.setAutoDraw(true);
     }
 
     
     // *third_response_C11_example* updates
     if (t >= 0 && third_response_C11_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C11_example.tStart = t;  // (not accounting for frame time here)
       third_response_C11_example.frameNStart = frameN;  // exact frame index
       
       third_response_C11_example.setAutoDraw(true);
     }
 
     
     // *third_response_C12_example* updates
     if (t >= 0 && third_response_C12_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C12_example.tStart = t;  // (not accounting for frame time here)
       third_response_C12_example.frameNStart = frameN;  // exact frame index
       
       third_response_C12_example.setAutoDraw(true);
     }
 
     
     // *third_response_C13_example* updates
     if (t >= 0 && third_response_C13_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C13_example.tStart = t;  // (not accounting for frame time here)
       third_response_C13_example.frameNStart = frameN;  // exact frame index
       
       third_response_C13_example.setAutoDraw(true);
     }
 
     
     // *third_response_C14_example* updates
     if (t >= 0 && third_response_C14_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C14_example.tStart = t;  // (not accounting for frame time here)
       third_response_C14_example.frameNStart = frameN;  // exact frame index
       
       third_response_C14_example.setAutoDraw(true);
     }
 
     
     // *third_response_C15_example* updates
     if (t >= 0 && third_response_C15_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C15_example.tStart = t;  // (not accounting for frame time here)
       third_response_C15_example.frameNStart = frameN;  // exact frame index
       
       third_response_C15_example.setAutoDraw(true);
     }
 
     
     // *third_response_C16_example* updates
     if (t >= 0 && third_response_C16_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C16_example.tStart = t;  // (not accounting for frame time here)
       third_response_C16_example.frameNStart = frameN;  // exact frame index
       
       third_response_C16_example.setAutoDraw(true);
     }
 
     // *third_mouse_response_example* updates
     if (t >= 0.0 && third_mouse_response_example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_mouse_response_example.tStart = t;  // (not accounting for frame time here)
       third_mouse_response_example.frameNStart = frameN;  // exact frame index
       
       third_mouse_response_example.status = PsychoJS.Status.STARTED;
       prevButtonState = third_mouse_response_example.getPressed();  // if button is down already this ISN'T a new click
       }
     if (third_mouse_response_example.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = third_mouse_response_example.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = third_mouse_response_example.getPos();
           third_mouse_response_example.x.push(_mouseXYs[0]);
           third_mouse_response_example.y.push(_mouseXYs[1]);
           third_mouse_response_example.leftButton.push(_mouseButtons[0]);
           third_mouse_response_example.midButton.push(_mouseButtons[1]);
           third_mouse_response_example.rightButton.push(_mouseButtons[2]);
           third_mouse_response_example.time.push(third_mouse_response_example.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [third_response_C4_example]) {
             if (obj.contains(third_mouse_response_example)) {
               gotValidClick = true;
               third_mouse_response_example.clicked_name.push(obj.name)
             }
           }
         }
       }
     }
     if (((third_mouse_response_example.clicked_name.length > 0) && (clicked_frame === null))) {
         clicked_frame = frameN;
         clicked_circle = eval(third_mouse_response_example.clicked_name[0]);
         clicked_circle.setFillColor(new util.Color([1, 1, 1]));
     }
     if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
         clicked_circle.setFillColor(new util.Color([-1, -1, -1]));
         continueRoutine = false;
     }
     
     // *polygon_3* updates
     if (t >= 0.0 && polygon_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       polygon_3.tStart = t;  // (not accounting for frame time here)
       polygon_3.frameNStart = frameN;  // exact frame index
       
       polygon_3.setAutoDraw(true);
     }
 
     
     // *triangle_3* updates
     if (t >= 0.0 && triangle_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       triangle_3.tStart = t;  // (not accounting for frame time here)
       triangle_3.frameNStart = frameN;  // exact frame index
       
       triangle_3.setAutoDraw(true);
     }
 
     
     // *push_these_circles_3* updates
     if (t >= 0.0 && push_these_circles_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       push_these_circles_3.tStart = t;  // (not accounting for frame time here)
       push_these_circles_3.frameNStart = frameN;  // exact frame index
       
       push_these_circles_3.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Circle_Example_7Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Circle_Example_7RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Circle_Example_7'-------
     for (const thisComponent of Circle_Example_7Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('third_mouse_response_example.x', third_mouse_response_example.x);
     psychoJS.experiment.addData('third_mouse_response_example.y', third_mouse_response_example.y);
     psychoJS.experiment.addData('third_mouse_response_example.leftButton', third_mouse_response_example.leftButton);
     psychoJS.experiment.addData('third_mouse_response_example.midButton', third_mouse_response_example.midButton);
     psychoJS.experiment.addData('third_mouse_response_example.rightButton', third_mouse_response_example.rightButton);
     psychoJS.experiment.addData('third_mouse_response_example.time', third_mouse_response_example.time);
     psychoJS.experiment.addData('third_mouse_response_example.clicked_name', third_mouse_response_example.clicked_name);
     
     /* Syntax Error: Fix Python code */
     // the Routine "Circle_Example_7" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Start_PracticeComponents;
 function Start_PracticeRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Start_Practice'-------
     t = 0;
     Start_PracticeClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the mouse
     gotValidClick = false; // until a click is received
     mouse.mouseClock.reset();
     // keep track of which components have finished
     Start_PracticeComponents = [];
     Start_PracticeComponents.push(practice_text);
     Start_PracticeComponents.push(spacebar_text);
     Start_PracticeComponents.push(mouse);
     
     for (const thisComponent of Start_PracticeComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Start_PracticeRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Start_Practice'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Start_PracticeClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *practice_text* updates
     if (t >= 0.0 && practice_text.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       practice_text.tStart = t;  // (not accounting for frame time here)
       practice_text.frameNStart = frameN;  // exact frame index
       
       practice_text.setAutoDraw(true);
     }
 
     
     // *spacebar_text* updates
     if (t >= 0.0 && spacebar_text.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       spacebar_text.tStart = t;  // (not accounting for frame time here)
       spacebar_text.frameNStart = frameN;  // exact frame index
       
       spacebar_text.setAutoDraw(true);
     }
 
     // *mouse* updates
     if (t >= 0.0 && mouse.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       mouse.tStart = t;  // (not accounting for frame time here)
       mouse.frameNStart = frameN;  // exact frame index
       
       mouse.status = PsychoJS.Status.STARTED;
       prevButtonState = mouse.getPressed();  // if button is down already this ISN'T a new click
       }
     if (mouse.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = mouse.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           // abort routine on response
           continueRoutine = false;
         }
       }
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Start_PracticeComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Start_PracticeRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Start_Practice'-------
     for (const thisComponent of Start_PracticeComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     // the Routine "Start_Practice" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Meta_Loop;
 var currentLoop;
 function Meta_LoopLoopBegin(Meta_LoopLoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   Meta_Loop = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.SEQUENTIAL,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'Meta_Loop_072418.xlsx',
     seed: undefined, name: 'Meta_Loop'
   });
   psychoJS.experiment.addLoop(Meta_Loop); // add the loop to the experiment
   currentLoop = Meta_Loop;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisMeta_Loop of Meta_Loop) {
     const snapshot = Meta_Loop.getSnapshot();
     Meta_LoopLoopScheduler.add(importConditions(snapshot));
     Meta_LoopLoopScheduler.add(Update_loopRoutineBegin(snapshot));
     Meta_LoopLoopScheduler.add(Update_loopRoutineEachFrame(snapshot));
     Meta_LoopLoopScheduler.add(Update_loopRoutineEnd(snapshot));
     Meta_LoopLoopScheduler.add(Check_practice_overRoutineBegin(snapshot));
     Meta_LoopLoopScheduler.add(Check_practice_overRoutineEachFrame(snapshot));
     Meta_LoopLoopScheduler.add(Check_practice_overRoutineEnd(snapshot));
     const Circle_BlocksLoopScheduler = new Scheduler(psychoJS);
     Meta_LoopLoopScheduler.add(Circle_BlocksLoopBegin, Circle_BlocksLoopScheduler);
     Meta_LoopLoopScheduler.add(Circle_BlocksLoopScheduler);
     Meta_LoopLoopScheduler.add(Circle_BlocksLoopEnd);
     Meta_LoopLoopScheduler.add(check_end_experimentRoutineBegin(snapshot));
     Meta_LoopLoopScheduler.add(check_end_experimentRoutineEachFrame(snapshot));
     Meta_LoopLoopScheduler.add(check_end_experimentRoutineEnd(snapshot));
     Meta_LoopLoopScheduler.add(endLoopIteration(Meta_LoopLoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 var Circle_Blocks;
 function Circle_BlocksLoopBegin(Circle_BlocksLoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   Circle_Blocks = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: Circle_Loop,
     seed: undefined, name: 'Circle_Blocks'
   });
   psychoJS.experiment.addLoop(Circle_Blocks); // add the loop to the experiment
   currentLoop = Circle_Blocks;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisCircle_Block of Circle_Blocks) {
     const snapshot = Circle_Blocks.getSnapshot();
     Circle_BlocksLoopScheduler.add(importConditions(snapshot));
     Circle_BlocksLoopScheduler.add(check_first_round_practiceRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(check_first_round_practiceRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(check_first_round_practiceRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Initial_CirclesRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Initial_CirclesRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Initial_CirclesRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(First_Circle_PresentationRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(First_Circle_PresentationRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(First_Circle_PresentationRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Second_Circle_PresentationRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Second_Circle_PresentationRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Second_Circle_PresentationRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Third_Circle_PresentationRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Third_Circle_PresentationRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Third_Circle_PresentationRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Fourth_Circle_PresentationRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Fourth_Circle_PresentationRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Fourth_Circle_PresentationRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Fifth_Circle_PresentationRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Fifth_Circle_PresentationRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Fifth_Circle_PresentationRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Sixth_Circle_PresentationRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Sixth_Circle_PresentationRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Sixth_Circle_PresentationRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Seventh_Circle_PresentationRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Seventh_Circle_PresentationRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Seventh_Circle_PresentationRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Eighth_Circle_PresentationRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Eighth_Circle_PresentationRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Eighth_Circle_PresentationRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_First_responseRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_First_responseRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_First_responseRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_Second_responseRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_Second_responseRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_Second_responseRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_Third_ResponseRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_Third_ResponseRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_Third_ResponseRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_Fourth_ResponseRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_Fourth_ResponseRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_Fourth_ResponseRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_Fifth_ResponseRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_Fifth_ResponseRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_for_Fifth_ResponseRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_For_Sixth_ResponseRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_For_Sixth_ResponseRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_For_Sixth_ResponseRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_For_Seventh_ResponseRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_For_Seventh_ResponseRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_For_Seventh_ResponseRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_For_Eighth_ResponseRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_For_Eighth_ResponseRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Wait_For_Eighth_ResponseRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Check_outcomeRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Check_outcomeRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Check_outcomeRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Blank_ScreenRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Blank_ScreenRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Blank_ScreenRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(feedbackRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(feedbackRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(feedbackRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(Repeat_InstructionsRoutineBegin(snapshot));
     Circle_BlocksLoopScheduler.add(Repeat_InstructionsRoutineEachFrame(snapshot));
     Circle_BlocksLoopScheduler.add(Repeat_InstructionsRoutineEnd(snapshot));
     Circle_BlocksLoopScheduler.add(endLoopIteration(Circle_BlocksLoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function Circle_BlocksLoopEnd() {
   psychoJS.experiment.removeLoop(Circle_Blocks);
 
   return Scheduler.Event.NEXT;
 }
 
 
 function Meta_LoopLoopEnd() {
   psychoJS.experiment.removeLoop(Meta_Loop);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var trials_2;
 function trials_2LoopBegin(trials_2LoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   trials_2 = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 2, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: undefined,
     seed: undefined, name: 'trials_2'
   });
   psychoJS.experiment.addLoop(trials_2); // add the loop to the experiment
   currentLoop = trials_2;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisTrial_2 of trials_2) {
     const snapshot = trials_2.getSnapshot();
     trials_2LoopScheduler.add(importConditions(snapshot));
     trials_2LoopScheduler.add(code_metaRoutineBegin(snapshot));
     trials_2LoopScheduler.add(code_metaRoutineEachFrame(snapshot));
     trials_2LoopScheduler.add(code_metaRoutineEnd(snapshot));
     const practiceLoopScheduler = new Scheduler(psychoJS);
     trials_2LoopScheduler.add(practiceLoopBegin, practiceLoopScheduler);
     trials_2LoopScheduler.add(practiceLoopScheduler);
     trials_2LoopScheduler.add(practiceLoopEnd);
     trials_2LoopScheduler.add(code_endRoutineBegin(snapshot));
     trials_2LoopScheduler.add(code_endRoutineEachFrame(snapshot));
     trials_2LoopScheduler.add(code_endRoutineEnd(snapshot));
     trials_2LoopScheduler.add(repeat_instructionsRoutineBegin(snapshot));
     trials_2LoopScheduler.add(repeat_instructionsRoutineEachFrame(snapshot));
     trials_2LoopScheduler.add(repeat_instructionsRoutineEnd(snapshot));
     trials_2LoopScheduler.add(endLoopIteration(trials_2LoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 var practice;
 function practiceLoopBegin(practiceLoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   practice = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'three_practice.xlsx',
     seed: undefined, name: 'practice'
   });
   psychoJS.experiment.addLoop(practice); // add the loop to the experiment
   currentLoop = practice;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisPractice of practice) {
     const snapshot = practice.getSnapshot();
     practiceLoopScheduler.add(importConditions(snapshot));
     practiceLoopScheduler.add(Presentation_practiceRoutineBegin(snapshot));
     practiceLoopScheduler.add(Presentation_practiceRoutineEachFrame(snapshot));
     practiceLoopScheduler.add(Presentation_practiceRoutineEnd(snapshot));
     practiceLoopScheduler.add(Recall_practiceRoutineBegin(snapshot));
     practiceLoopScheduler.add(Recall_practiceRoutineEachFrame(snapshot));
     practiceLoopScheduler.add(Recall_practiceRoutineEnd(snapshot));
     practiceLoopScheduler.add(feedback_practiceRoutineBegin(snapshot));
     practiceLoopScheduler.add(feedback_practiceRoutineEachFrame(snapshot));
     practiceLoopScheduler.add(feedback_practiceRoutineEnd(snapshot));
     practiceLoopScheduler.add(endLoopIteration(practiceLoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function practiceLoopEnd() {
   psychoJS.experiment.removeLoop(practice);
 
   return Scheduler.Event.NEXT;
 }
 
 
 function trials_2LoopEnd() {
   psychoJS.experiment.removeLoop(trials_2);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var blocks;
 function blocksLoopBegin(blocksLoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   blocks = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.SEQUENTIAL,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'choose_digitSpan.xlsx',
     seed: undefined, name: 'blocks'
   });
   psychoJS.experiment.addLoop(blocks); // add the loop to the experiment
   currentLoop = blocks;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisBlock of blocks) {
     const snapshot = blocks.getSnapshot();
     blocksLoopScheduler.add(importConditions(snapshot));
     const trialsLoopScheduler = new Scheduler(psychoJS);
     blocksLoopScheduler.add(trialsLoopBegin, trialsLoopScheduler);
     blocksLoopScheduler.add(trialsLoopScheduler);
     blocksLoopScheduler.add(trialsLoopEnd);
     blocksLoopScheduler.add(endLoopIteration(blocksLoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 var trials;
 function trialsLoopBegin(trialsLoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   trials = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: condition_file,
     seed: undefined, name: 'trials'
   });
   psychoJS.experiment.addLoop(trials); // add the loop to the experiment
   currentLoop = trials;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisTrial of trials) {
     const snapshot = trials.getSnapshot();
     trialsLoopScheduler.add(importConditions(snapshot));
     trialsLoopScheduler.add(PresentationRoutineBegin(snapshot));
     trialsLoopScheduler.add(PresentationRoutineEachFrame(snapshot));
     trialsLoopScheduler.add(PresentationRoutineEnd(snapshot));
     trialsLoopScheduler.add(RecallRoutineBegin(snapshot));
     trialsLoopScheduler.add(RecallRoutineEachFrame(snapshot));
     trialsLoopScheduler.add(RecallRoutineEnd(snapshot));
     trialsLoopScheduler.add(FeedbackRoutineBegin(snapshot));
     trialsLoopScheduler.add(FeedbackRoutineEachFrame(snapshot));
     trialsLoopScheduler.add(FeedbackRoutineEnd(snapshot));
     trialsLoopScheduler.add(endLoopIteration(trialsLoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function trialsLoopEnd() {
   psychoJS.experiment.removeLoop(trials);
 
   return Scheduler.Event.NEXT;
 }
 
 
 function blocksLoopEnd() {
   psychoJS.experiment.removeLoop(blocks);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var practice_congruent_1;
 function practice_congruent_1LoopBegin(practice_congruent_1LoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   practice_congruent_1 = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'test_practice_congruent.xlsx',
     seed: undefined, name: 'practice_congruent_1'
   });
   psychoJS.experiment.addLoop(practice_congruent_1); // add the loop to the experiment
   currentLoop = practice_congruent_1;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisPractice_congruent_1 of practice_congruent_1) {
     const snapshot = practice_congruent_1.getSnapshot();
     practice_congruent_1LoopScheduler.add(importConditions(snapshot));
     practice_congruent_1LoopScheduler.add(Practice_trial_congruentRoutineBegin(snapshot));
     practice_congruent_1LoopScheduler.add(Practice_trial_congruentRoutineEachFrame(snapshot));
     practice_congruent_1LoopScheduler.add(Practice_trial_congruentRoutineEnd(snapshot));
     practice_congruent_1LoopScheduler.add(feedback_hf_congruent_1RoutineBegin(snapshot));
     practice_congruent_1LoopScheduler.add(feedback_hf_congruent_1RoutineEachFrame(snapshot));
     practice_congruent_1LoopScheduler.add(feedback_hf_congruent_1RoutineEnd(snapshot));
     practice_congruent_1LoopScheduler.add(endLoopIteration(practice_congruent_1LoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function practice_congruent_1LoopEnd() {
   psychoJS.experiment.removeLoop(practice_congruent_1);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var practice_congruent_2;
 function practice_congruent_2LoopBegin(practice_congruent_2LoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   practice_congruent_2 = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'practice congruent.xlsx',
     seed: undefined, name: 'practice_congruent_2'
   });
   psychoJS.experiment.addLoop(practice_congruent_2); // add the loop to the experiment
   currentLoop = practice_congruent_2;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisPractice_congruent_2 of practice_congruent_2) {
     const snapshot = practice_congruent_2.getSnapshot();
     practice_congruent_2LoopScheduler.add(importConditions(snapshot));
     practice_congruent_2LoopScheduler.add(Practice_trial_congruent_2RoutineBegin(snapshot));
     practice_congruent_2LoopScheduler.add(Practice_trial_congruent_2RoutineEachFrame(snapshot));
     practice_congruent_2LoopScheduler.add(Practice_trial_congruent_2RoutineEnd(snapshot));
     practice_congruent_2LoopScheduler.add(feedback_hf_congruent_2RoutineBegin(snapshot));
     practice_congruent_2LoopScheduler.add(feedback_hf_congruent_2RoutineEachFrame(snapshot));
     practice_congruent_2LoopScheduler.add(feedback_hf_congruent_2RoutineEnd(snapshot));
     practice_congruent_2LoopScheduler.add(endLoopIteration(practice_congruent_2LoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function practice_congruent_2LoopEnd() {
   psychoJS.experiment.removeLoop(practice_congruent_2);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var trial_hearts;
 function trial_heartsLoopBegin(trial_heartsLoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   trial_hearts = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'block1_Hearts.xlsx',
     seed: undefined, name: 'trial_hearts'
   });
   psychoJS.experiment.addLoop(trial_hearts); // add the loop to the experiment
   currentLoop = trial_hearts;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisTrial_heart of trial_hearts) {
     const snapshot = trial_hearts.getSnapshot();
     trial_heartsLoopScheduler.add(importConditions(snapshot));
     trial_heartsLoopScheduler.add(HeartsRoutineBegin(snapshot));
     trial_heartsLoopScheduler.add(HeartsRoutineEachFrame(snapshot));
     trial_heartsLoopScheduler.add(HeartsRoutineEnd(snapshot));
     trial_heartsLoopScheduler.add(endLoopIteration(trial_heartsLoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function trial_heartsLoopEnd() {
   psychoJS.experiment.removeLoop(trial_hearts);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var practice_incongruent_1;
 function practice_incongruent_1LoopBegin(practice_incongruent_1LoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   practice_incongruent_1 = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'practice incongruent.xlsx',
     seed: undefined, name: 'practice_incongruent_1'
   });
   psychoJS.experiment.addLoop(practice_incongruent_1); // add the loop to the experiment
   currentLoop = practice_incongruent_1;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisPractice_incongruent_1 of practice_incongruent_1) {
     const snapshot = practice_incongruent_1.getSnapshot();
     practice_incongruent_1LoopScheduler.add(importConditions(snapshot));
     practice_incongruent_1LoopScheduler.add(Practice_trial_incongruentRoutineBegin(snapshot));
     practice_incongruent_1LoopScheduler.add(Practice_trial_incongruentRoutineEachFrame(snapshot));
     practice_incongruent_1LoopScheduler.add(Practice_trial_incongruentRoutineEnd(snapshot));
     practice_incongruent_1LoopScheduler.add(feedback_hf_incongruent_1RoutineBegin(snapshot));
     practice_incongruent_1LoopScheduler.add(feedback_hf_incongruent_1RoutineEachFrame(snapshot));
     practice_incongruent_1LoopScheduler.add(feedback_hf_incongruent_1RoutineEnd(snapshot));
     practice_incongruent_1LoopScheduler.add(endLoopIteration(practice_incongruent_1LoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function practice_incongruent_1LoopEnd() {
   psychoJS.experiment.removeLoop(practice_incongruent_1);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var practice_incongruent_2;
 function practice_incongruent_2LoopBegin(practice_incongruent_2LoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   practice_incongruent_2 = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'practice incongruent.xlsx',
     seed: undefined, name: 'practice_incongruent_2'
   });
   psychoJS.experiment.addLoop(practice_incongruent_2); // add the loop to the experiment
   currentLoop = practice_incongruent_2;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisPractice_incongruent_2 of practice_incongruent_2) {
     const snapshot = practice_incongruent_2.getSnapshot();
     practice_incongruent_2LoopScheduler.add(importConditions(snapshot));
     practice_incongruent_2LoopScheduler.add(Practice_trial_incongruent_2RoutineBegin(snapshot));
     practice_incongruent_2LoopScheduler.add(Practice_trial_incongruent_2RoutineEachFrame(snapshot));
     practice_incongruent_2LoopScheduler.add(Practice_trial_incongruent_2RoutineEnd(snapshot));
     practice_incongruent_2LoopScheduler.add(feedback_hf_incongruent_2RoutineBegin(snapshot));
     practice_incongruent_2LoopScheduler.add(feedback_hf_incongruent_2RoutineEachFrame(snapshot));
     practice_incongruent_2LoopScheduler.add(feedback_hf_incongruent_2RoutineEnd(snapshot));
     practice_incongruent_2LoopScheduler.add(endLoopIteration(practice_incongruent_2LoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function practice_incongruent_2LoopEnd() {
   psychoJS.experiment.removeLoop(practice_incongruent_2);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var trial_flowers;
 function trial_flowersLoopBegin(trial_flowersLoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   trial_flowers = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'block2_Flowers.xlsx',
     seed: undefined, name: 'trial_flowers'
   });
   psychoJS.experiment.addLoop(trial_flowers); // add the loop to the experiment
   currentLoop = trial_flowers;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisTrial_flower of trial_flowers) {
     const snapshot = trial_flowers.getSnapshot();
     trial_flowersLoopScheduler.add(importConditions(snapshot));
     trial_flowersLoopScheduler.add(FlowersRoutineBegin(snapshot));
     trial_flowersLoopScheduler.add(FlowersRoutineEachFrame(snapshot));
     trial_flowersLoopScheduler.add(FlowersRoutineEnd(snapshot));
     trial_flowersLoopScheduler.add(endLoopIteration(trial_flowersLoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function trial_flowersLoopEnd() {
   psychoJS.experiment.removeLoop(trial_flowers);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var practice_mixed_1;
 function practice_mixed_1LoopBegin(practice_mixed_1LoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   practice_mixed_1 = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'practice mixed.xlsx',
     seed: undefined, name: 'practice_mixed_1'
   });
   psychoJS.experiment.addLoop(practice_mixed_1); // add the loop to the experiment
   currentLoop = practice_mixed_1;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisPractice_mixed_1 of practice_mixed_1) {
     const snapshot = practice_mixed_1.getSnapshot();
     practice_mixed_1LoopScheduler.add(importConditions(snapshot));
     practice_mixed_1LoopScheduler.add(Practice_trial_mixedRoutineBegin(snapshot));
     practice_mixed_1LoopScheduler.add(Practice_trial_mixedRoutineEachFrame(snapshot));
     practice_mixed_1LoopScheduler.add(Practice_trial_mixedRoutineEnd(snapshot));
     practice_mixed_1LoopScheduler.add(feedback_hf_mixed_1RoutineBegin(snapshot));
     practice_mixed_1LoopScheduler.add(feedback_hf_mixed_1RoutineEachFrame(snapshot));
     practice_mixed_1LoopScheduler.add(feedback_hf_mixed_1RoutineEnd(snapshot));
     practice_mixed_1LoopScheduler.add(endLoopIteration(practice_mixed_1LoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function practice_mixed_1LoopEnd() {
   psychoJS.experiment.removeLoop(practice_mixed_1);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var practice_mixed_2;
 function practice_mixed_2LoopBegin(practice_mixed_2LoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   practice_mixed_2 = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'practice mixed.xlsx',
     seed: undefined, name: 'practice_mixed_2'
   });
   psychoJS.experiment.addLoop(practice_mixed_2); // add the loop to the experiment
   currentLoop = practice_mixed_2;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisPractice_mixed_2 of practice_mixed_2) {
     const snapshot = practice_mixed_2.getSnapshot();
     practice_mixed_2LoopScheduler.add(importConditions(snapshot));
     practice_mixed_2LoopScheduler.add(Practice_trial_mixed_2RoutineBegin(snapshot));
     practice_mixed_2LoopScheduler.add(Practice_trial_mixed_2RoutineEachFrame(snapshot));
     practice_mixed_2LoopScheduler.add(Practice_trial_mixed_2RoutineEnd(snapshot));
     practice_mixed_2LoopScheduler.add(feedback_hf_mixed_2RoutineBegin(snapshot));
     practice_mixed_2LoopScheduler.add(feedback_hf_mixed_2RoutineEachFrame(snapshot));
     practice_mixed_2LoopScheduler.add(feedback_hf_mixed_2RoutineEnd(snapshot));
     practice_mixed_2LoopScheduler.add(endLoopIteration(practice_mixed_2LoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function practice_mixed_2LoopEnd() {
   psychoJS.experiment.removeLoop(practice_mixed_2);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var trial_mixed;
 function trial_mixedLoopBegin(trial_mixedLoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   trial_mixed = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'block3_Mixed001_random.xlsx',
     seed: undefined, name: 'trial_mixed'
   });
   psychoJS.experiment.addLoop(trial_mixed); // add the loop to the experiment
   currentLoop = trial_mixed;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisTrial_mixed of trial_mixed) {
     const snapshot = trial_mixed.getSnapshot();
     trial_mixedLoopScheduler.add(importConditions(snapshot));
     trial_mixedLoopScheduler.add(MixedRoutineBegin(snapshot));
     trial_mixedLoopScheduler.add(MixedRoutineEachFrame(snapshot));
     trial_mixedLoopScheduler.add(MixedRoutineEnd(snapshot));
     trial_mixedLoopScheduler.add(endLoopIteration(trial_mixedLoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function trial_mixedLoopEnd() {
   psychoJS.experiment.removeLoop(trial_mixed);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var trials_practice_loop;
 function trials_practice_loopLoopBegin(trials_practice_loopLoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   trials_practice_loop = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'practice_trials.xlsx',
     seed: undefined, name: 'trials_practice_loop'
   });
   psychoJS.experiment.addLoop(trials_practice_loop); // add the loop to the experiment
   currentLoop = trials_practice_loop;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisTrials_practice_loop of trials_practice_loop) {
     const snapshot = trials_practice_loop.getSnapshot();
     trials_practice_loopLoopScheduler.add(importConditions(snapshot));
     trials_practice_loopLoopScheduler.add(trials_practice_2RoutineBegin(snapshot));
     trials_practice_loopLoopScheduler.add(trials_practice_2RoutineEachFrame(snapshot));
     trials_practice_loopLoopScheduler.add(trials_practice_2RoutineEnd(snapshot));
     trials_practice_loopLoopScheduler.add(feedback_practice_2RoutineBegin(snapshot));
     trials_practice_loopLoopScheduler.add(feedback_practice_2RoutineEachFrame(snapshot));
     trials_practice_loopLoopScheduler.add(feedback_practice_2RoutineEnd(snapshot));
     trials_practice_loopLoopScheduler.add(endLoopIteration(trials_practice_loopLoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function trials_practice_loopLoopEnd() {
   psychoJS.experiment.removeLoop(trials_practice_loop);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var blocks_2;
 function blocks_2LoopBegin(blocks_2LoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   blocks_2 = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'chooseRule.xlsx',
     seed: undefined, name: 'blocks_2'
   });
   psychoJS.experiment.addLoop(blocks_2); // add the loop to the experiment
   currentLoop = blocks_2;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisBlock_2 of blocks_2) {
     const snapshot = blocks_2.getSnapshot();
     blocks_2LoopScheduler.add(importConditions(snapshot));
     blocks_2LoopScheduler.add(code_meta_2RoutineBegin(snapshot));
     blocks_2LoopScheduler.add(code_meta_2RoutineEachFrame(snapshot));
     blocks_2LoopScheduler.add(code_meta_2RoutineEnd(snapshot));
     const trials_3LoopScheduler = new Scheduler(psychoJS);
     blocks_2LoopScheduler.add(trials_3LoopBegin, trials_3LoopScheduler);
     blocks_2LoopScheduler.add(trials_3LoopScheduler);
     blocks_2LoopScheduler.add(trials_3LoopEnd);
     blocks_2LoopScheduler.add(code_end_2RoutineBegin(snapshot));
     blocks_2LoopScheduler.add(code_end_2RoutineEachFrame(snapshot));
     blocks_2LoopScheduler.add(code_end_2RoutineEnd(snapshot));
     blocks_2LoopScheduler.add(endLoopIteration(blocks_2LoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 var trials_3;
 function trials_3LoopBegin(trials_3LoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   trials_3 = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.RANDOM,
     extraInfo: expInfo, originPath: undefined,
     trialList: condition_file,
     seed: undefined, name: 'trials_3'
   });
   psychoJS.experiment.addLoop(trials_3); // add the loop to the experiment
   currentLoop = trials_3;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisTrial_3 of trials_3) {
     const snapshot = trials_3.getSnapshot();
     trials_3LoopScheduler.add(importConditions(snapshot));
     trials_3LoopScheduler.add(TrialsRoutineBegin(snapshot));
     trials_3LoopScheduler.add(TrialsRoutineEachFrame(snapshot));
     trials_3LoopScheduler.add(TrialsRoutineEnd(snapshot));
     trials_3LoopScheduler.add(Feedback_2RoutineBegin(snapshot));
     trials_3LoopScheduler.add(Feedback_2RoutineEachFrame(snapshot));
     trials_3LoopScheduler.add(Feedback_2RoutineEnd(snapshot));
     trials_3LoopScheduler.add(endLoopIteration(trials_3LoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function trials_3LoopEnd() {
   psychoJS.experiment.removeLoop(trials_3);
 
   return Scheduler.Event.NEXT;
 }
 
 
 function blocks_2LoopEnd() {
   psychoJS.experiment.removeLoop(blocks_2);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var task_trials;
 function task_trialsLoopBegin(task_trialsLoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   task_trials = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 1, method: TrialHandler.Method.SEQUENTIAL,
     extraInfo: expInfo, originPath: undefined,
     trialList: 'tol_positions.csv',
     seed: undefined, name: 'task_trials'
   });
   psychoJS.experiment.addLoop(task_trials); // add the loop to the experiment
   currentLoop = task_trials;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisTask_trial of task_trials) {
     const snapshot = task_trials.getSnapshot();
     task_trialsLoopScheduler.add(importConditions(snapshot));
     task_trialsLoopScheduler.add(tol_next_trialRoutineBegin(snapshot));
     task_trialsLoopScheduler.add(tol_next_trialRoutineEachFrame(snapshot));
     task_trialsLoopScheduler.add(tol_next_trialRoutineEnd(snapshot));
     const movementsLoopScheduler = new Scheduler(psychoJS);
     task_trialsLoopScheduler.add(movementsLoopBegin, movementsLoopScheduler);
     task_trialsLoopScheduler.add(movementsLoopScheduler);
     task_trialsLoopScheduler.add(movementsLoopEnd);
     task_trialsLoopScheduler.add(endLoopIteration(task_trialsLoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 var movements;
 function movementsLoopBegin(movementsLoopScheduler) {
   // set up handler to look after randomisation of conditions etc
   movements = new TrialHandler({
     psychoJS: psychoJS,
     nReps: 40, method: TrialHandler.Method.SEQUENTIAL,
     extraInfo: expInfo, originPath: undefined,
     trialList: undefined,
     seed: undefined, name: 'movements'
   });
   psychoJS.experiment.addLoop(movements); // add the loop to the experiment
   currentLoop = movements;  // we're now the current loop
 
   // Schedule all the trials in the trialList:
   for (const thisMovement of movements) {
     const snapshot = movements.getSnapshot();
     movementsLoopScheduler.add(importConditions(snapshot));
     movementsLoopScheduler.add(first_movementRoutineBegin(snapshot));
     movementsLoopScheduler.add(first_movementRoutineEachFrame(snapshot));
     movementsLoopScheduler.add(first_movementRoutineEnd(snapshot));
     movementsLoopScheduler.add(check_step1_t1RoutineBegin(snapshot));
     movementsLoopScheduler.add(check_step1_t1RoutineEachFrame(snapshot));
     movementsLoopScheduler.add(check_step1_t1RoutineEnd(snapshot));
     movementsLoopScheduler.add(second_movRoutineBegin(snapshot));
     movementsLoopScheduler.add(second_movRoutineEachFrame(snapshot));
     movementsLoopScheduler.add(second_movRoutineEnd(snapshot));
     movementsLoopScheduler.add(check_step2_t1RoutineBegin(snapshot));
     movementsLoopScheduler.add(check_step2_t1RoutineEachFrame(snapshot));
     movementsLoopScheduler.add(check_step2_t1RoutineEnd(snapshot));
     movementsLoopScheduler.add(check_positionsRoutineBegin(snapshot));
     movementsLoopScheduler.add(check_positionsRoutineEachFrame(snapshot));
     movementsLoopScheduler.add(check_positionsRoutineEnd(snapshot));
     movementsLoopScheduler.add(endLoopIteration(movementsLoopScheduler, snapshot));
   }
 
   return Scheduler.Event.NEXT;
 }
 
 
 function movementsLoopEnd() {
   psychoJS.experiment.removeLoop(movements);
 
   return Scheduler.Event.NEXT;
 }
 
 
 function task_trialsLoopEnd() {
   psychoJS.experiment.removeLoop(task_trials);
 
   return Scheduler.Event.NEXT;
 }
 
 
 var trials_correct;
 var Update_loopComponents;
 function Update_loopRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Update_loop'-------
     t = 0;
     Update_loopClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     circle_loop = (circle_loop + 1);
     trial_counter = 0;
     trials_correct = 0;
     
     console.log(circle_loop)
     console.log(trial_counter)
     console.log(trials_correct)
     // keep track of which components have finished
     Update_loopComponents = [];
     
     for (const thisComponent of Update_loopComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Update_loopRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Update_loop'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Update_loopClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Update_loopComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Update_loopRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Update_loop'-------
     for (const thisComponent of Update_loopComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     console.log(circle_loop)
     console.log(trial_counter)
     console.log(trials_correct)
     // the Routine "Update_loop" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Check_practice_overComponents;
 function Check_practice_overRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Check_practice_over'-------
     t = 0;
     Check_practice_overClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the mouse_2
     gotValidClick = false; // until a click is received
     mouse_2.mouseClock.reset();
     // keep track of which components have finished
     Check_practice_overComponents = [];
     Check_practice_overComponents.push(text_3);
     Check_practice_overComponents.push(mouse_2);
     Check_practice_overComponents.push(mouse_click_text);
     
     for (const thisComponent of Check_practice_overComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Check_practice_overRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Check_practice_over'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Check_practice_overClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     console.log(circle_loop)
     if (circle_loop == 3) {
         console.log(circle_loop);
         console.log("this is not working");
         continueRoutine = true;
     } else {
         console.log(circle_loop);
         console.log("maybe");
         continueRoutine = false;
     }
     
     // *text_3* updates
     if (t >= 0.0 && text_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_3.tStart = t;  // (not accounting for frame time here)
       text_3.frameNStart = frameN;  // exact frame index
       
       text_3.setAutoDraw(true);
     }
 
     // *mouse_2* updates
     if (t >= 0.0 && mouse_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       mouse_2.tStart = t;  // (not accounting for frame time here)
       mouse_2.frameNStart = frameN;  // exact frame index
       
       mouse_2.status = PsychoJS.Status.STARTED;
       prevButtonState = mouse_2.getPressed();  // if button is down already this ISN'T a new click
       }
     if (mouse_2.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = mouse_2.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           // abort routine on response
           continueRoutine = false;
         }
       }
     }
     
     // *mouse_click_text* updates
     if (t >= 0.0 && mouse_click_text.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       mouse_click_text.tStart = t;  // (not accounting for frame time here)
       mouse_click_text.frameNStart = frameN;  // exact frame index
       
       mouse_click_text.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Check_practice_overComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Check_practice_overRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Check_practice_over'-------
     for (const thisComponent of Check_practice_overComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     // the Routine "Check_practice_over" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var check_first_round_practiceComponents;
 function check_first_round_practiceRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'check_first_round_practice'-------
     t = 0;
     check_first_round_practiceClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     console.log(practice_correct)
     console.log(circle_loop)
     // keep track of which components have finished
     check_first_round_practiceComponents = [];
     
     for (const thisComponent of check_first_round_practiceComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function check_first_round_practiceRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'check_first_round_practice'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = check_first_round_practiceClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     if ((circle_loop < 3)) {
         if ((practice_correct === 1)) {
             continueRoutine = false;
         }
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of check_first_round_practiceComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function check_first_round_practiceRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'check_first_round_practice'-------
     for (const thisComponent of check_first_round_practiceComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // the Routine "check_first_round_practice" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var First_Circle_PresentationComponents;
 function First_Circle_PresentationRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'First_Circle_Presentation'-------
     t = 0;
     First_Circle_PresentationClock.reset(); // clock
     frameN = -1;
     routineTimer.add(0.900000);
     // update component parameters for each repeat
     first_circle_pres_C1.setFillColor(new util.Color(circle1color_first_circle_shown));
     first_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C2.setFillColor(new util.Color(circle2color_first_circle_shown));
     first_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C3.setFillColor(new util.Color(circle3color_first_circle_shown));
     first_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C4.setFillColor(new util.Color(circle4color_first_circle_shown));
     first_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C5.setFillColor(new util.Color(circle5color_first_circle_shown));
     first_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C6.setFillColor(new util.Color(circle6color_first_circle_shown));
     first_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C7.setFillColor(new util.Color(circle7color_first_circle_shown));
     first_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C8.setFillColor(new util.Color(circle8color_first_circle_shown));
     first_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C9.setFillColor(new util.Color(circle9color_first_circle_shown));
     first_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C10.setFillColor(new util.Color(circle10color_first_circle_shown));
     first_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C11.setFillColor(new util.Color(circle11color_first_circle_shown));
     first_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C12.setFillColor(new util.Color(circle12color_first_circle_shown));
     first_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C13.setFillColor(new util.Color(circle13color_first_circle_shown));
     first_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C14.setFillColor(new util.Color(circle14color_first_circle_shown));
     first_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C15.setFillColor(new util.Color(circle15color_first_circle_shown));
     first_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     first_circle_pres_C16.setFillColor(new util.Color(circle16color_first_circle_shown));
     first_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     // keep track of which components have finished
     First_Circle_PresentationComponents = [];
     First_Circle_PresentationComponents.push(first_circle_pres_C1);
     First_Circle_PresentationComponents.push(first_circle_pres_C2);
     First_Circle_PresentationComponents.push(first_circle_pres_C3);
     First_Circle_PresentationComponents.push(first_circle_pres_C4);
     First_Circle_PresentationComponents.push(first_circle_pres_C5);
     First_Circle_PresentationComponents.push(first_circle_pres_C6);
     First_Circle_PresentationComponents.push(first_circle_pres_C7);
     First_Circle_PresentationComponents.push(first_circle_pres_C8);
     First_Circle_PresentationComponents.push(first_circle_pres_C9);
     First_Circle_PresentationComponents.push(first_circle_pres_C10);
     First_Circle_PresentationComponents.push(first_circle_pres_C11);
     First_Circle_PresentationComponents.push(first_circle_pres_C12);
     First_Circle_PresentationComponents.push(first_circle_pres_C13);
     First_Circle_PresentationComponents.push(first_circle_pres_C14);
     First_Circle_PresentationComponents.push(first_circle_pres_C15);
     First_Circle_PresentationComponents.push(first_circle_pres_C16);
     
     for (const thisComponent of First_Circle_PresentationComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function First_Circle_PresentationRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'First_Circle_Presentation'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = First_Circle_PresentationClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *first_circle_pres_C1* updates
     if (t >= 0 && first_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C1.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C1.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C1.status === PsychoJS.Status.STARTED || first_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C1.setAutoDraw(false);
     }
     
     // *first_circle_pres_C2* updates
     if (t >= 0 && first_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C2.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C2.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C2.status === PsychoJS.Status.STARTED || first_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C2.setAutoDraw(false);
     }
     
     // *first_circle_pres_C3* updates
     if (t >= 0 && first_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C3.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C3.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C3.status === PsychoJS.Status.STARTED || first_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C3.setAutoDraw(false);
     }
     
     // *first_circle_pres_C4* updates
     if (t >= 0 && first_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C4.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C4.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C4.status === PsychoJS.Status.STARTED || first_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C4.setAutoDraw(false);
     }
     
     // *first_circle_pres_C5* updates
     if (t >= 0 && first_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C5.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C5.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C5.status === PsychoJS.Status.STARTED || first_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C5.setAutoDraw(false);
     }
     
     // *first_circle_pres_C6* updates
     if (t >= 0 && first_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C6.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C6.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C6.status === PsychoJS.Status.STARTED || first_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C6.setAutoDraw(false);
     }
     
     // *first_circle_pres_C7* updates
     if (t >= 0 && first_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C7.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C7.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C7.status === PsychoJS.Status.STARTED || first_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C7.setAutoDraw(false);
     }
     
     // *first_circle_pres_C8* updates
     if (t >= 0 && first_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C8.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C8.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C8.status === PsychoJS.Status.STARTED || first_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C8.setAutoDraw(false);
     }
     
     // *first_circle_pres_C9* updates
     if (t >= 0 && first_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C9.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C9.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C9.status === PsychoJS.Status.STARTED || first_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C9.setAutoDraw(false);
     }
     
     // *first_circle_pres_C10* updates
     if (t >= 0 && first_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C10.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C10.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C10.status === PsychoJS.Status.STARTED || first_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C10.setAutoDraw(false);
     }
     
     // *first_circle_pres_C11* updates
     if (t >= 0 && first_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C11.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C11.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C11.status === PsychoJS.Status.STARTED || first_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C11.setAutoDraw(false);
     }
     
     // *first_circle_pres_C12* updates
     if (t >= 0 && first_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C12.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C12.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C12.status === PsychoJS.Status.STARTED || first_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C12.setAutoDraw(false);
     }
     
     // *first_circle_pres_C13* updates
     if (t >= 0 && first_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C13.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C13.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C13.status === PsychoJS.Status.STARTED || first_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C13.setAutoDraw(false);
     }
     
     // *first_circle_pres_C14* updates
     if (t >= 0 && first_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C14.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C14.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C14.status === PsychoJS.Status.STARTED || first_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C14.setAutoDraw(false);
     }
     
     // *first_circle_pres_C15* updates
     if (t >= 0 && first_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C15.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C15.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C15.status === PsychoJS.Status.STARTED || first_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C15.setAutoDraw(false);
     }
     
     // *first_circle_pres_C16* updates
     if (t >= 0 && first_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
       first_circle_pres_C16.frameNStart = frameN;  // exact frame index
       
       first_circle_pres_C16.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((first_circle_pres_C16.status === PsychoJS.Status.STARTED || first_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       first_circle_pres_C16.setAutoDraw(false);
     }
     if ((circle_loop < 3)) {
         if ((practice_correct === 1)) {
             continueRoutine = false;
         }
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of First_Circle_PresentationComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function First_Circle_PresentationRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'First_Circle_Presentation'-------
     for (const thisComponent of First_Circle_PresentationComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Second_Circle_PresentationComponents;
 function Second_Circle_PresentationRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Second_Circle_Presentation'-------
     t = 0;
     Second_Circle_PresentationClock.reset(); // clock
     frameN = -1;
     routineTimer.add(0.900000);
     // update component parameters for each repeat
     second_circle_pres_C1.setFillColor(new util.Color(circle1color_second_circle_shown));
     second_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C2.setFillColor(new util.Color(circle2color_second_circle_shown));
     second_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C3.setFillColor(new util.Color(circle3color_second_circle_shown));
     second_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C4.setFillColor(new util.Color(circle4color_second_circle_shown));
     second_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C5.setFillColor(new util.Color(circle5color_second_circle_shown));
     second_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C6.setFillColor(new util.Color(circle6color_second_circle_shown));
     second_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C7.setFillColor(new util.Color(circle7color_second_circle_shown));
     second_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C8.setFillColor(new util.Color(circle8color_second_circle_shown));
     second_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C9.setFillColor(new util.Color(circle9color_second_circle_shown));
     second_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C10.setFillColor(new util.Color(circle10color_second_circle_shown));
     second_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C11.setFillColor(new util.Color(circle11color_second_circle_shown));
     second_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C12.setFillColor(new util.Color(circle12color_second_circle_shown));
     second_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C13.setFillColor(new util.Color(circle13color_second_circle_shown));
     second_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C14.setFillColor(new util.Color(circle14color_second_circle_shown));
     second_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C15.setFillColor(new util.Color(circle15color_second_circle_shown));
     second_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     second_circle_pres_C16.setFillColor(new util.Color(circle16color_second_circle_shown));
     second_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     // keep track of which components have finished
     Second_Circle_PresentationComponents = [];
     Second_Circle_PresentationComponents.push(second_circle_pres_C1);
     Second_Circle_PresentationComponents.push(second_circle_pres_C2);
     Second_Circle_PresentationComponents.push(second_circle_pres_C3);
     Second_Circle_PresentationComponents.push(second_circle_pres_C4);
     Second_Circle_PresentationComponents.push(second_circle_pres_C5);
     Second_Circle_PresentationComponents.push(second_circle_pres_C6);
     Second_Circle_PresentationComponents.push(second_circle_pres_C7);
     Second_Circle_PresentationComponents.push(second_circle_pres_C8);
     Second_Circle_PresentationComponents.push(second_circle_pres_C9);
     Second_Circle_PresentationComponents.push(second_circle_pres_C10);
     Second_Circle_PresentationComponents.push(second_circle_pres_C11);
     Second_Circle_PresentationComponents.push(second_circle_pres_C12);
     Second_Circle_PresentationComponents.push(second_circle_pres_C13);
     Second_Circle_PresentationComponents.push(second_circle_pres_C14);
     Second_Circle_PresentationComponents.push(second_circle_pres_C15);
     Second_Circle_PresentationComponents.push(second_circle_pres_C16);
     
     for (const thisComponent of Second_Circle_PresentationComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Second_Circle_PresentationRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Second_Circle_Presentation'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Second_Circle_PresentationClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *second_circle_pres_C1* updates
     if (t >= 0 && second_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C1.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C1.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C1.status === PsychoJS.Status.STARTED || second_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C1.setAutoDraw(false);
     }
     
     // *second_circle_pres_C2* updates
     if (t >= 0 && second_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C2.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C2.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C2.status === PsychoJS.Status.STARTED || second_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C2.setAutoDraw(false);
     }
     
     // *second_circle_pres_C3* updates
     if (t >= 0 && second_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C3.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C3.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C3.status === PsychoJS.Status.STARTED || second_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C3.setAutoDraw(false);
     }
     
     // *second_circle_pres_C4* updates
     if (t >= 0 && second_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C4.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C4.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C4.status === PsychoJS.Status.STARTED || second_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C4.setAutoDraw(false);
     }
     
     // *second_circle_pres_C5* updates
     if (t >= 0 && second_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C5.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C5.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C5.status === PsychoJS.Status.STARTED || second_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C5.setAutoDraw(false);
     }
     
     // *second_circle_pres_C6* updates
     if (t >= 0 && second_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C6.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C6.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C6.status === PsychoJS.Status.STARTED || second_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C6.setAutoDraw(false);
     }
     
     // *second_circle_pres_C7* updates
     if (t >= 0 && second_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C7.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C7.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C7.status === PsychoJS.Status.STARTED || second_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C7.setAutoDraw(false);
     }
     
     // *second_circle_pres_C8* updates
     if (t >= 0 && second_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C8.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C8.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C8.status === PsychoJS.Status.STARTED || second_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C8.setAutoDraw(false);
     }
     
     // *second_circle_pres_C9* updates
     if (t >= 0 && second_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C9.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C9.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C9.status === PsychoJS.Status.STARTED || second_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C9.setAutoDraw(false);
     }
     
     // *second_circle_pres_C10* updates
     if (t >= 0 && second_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C10.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C10.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C10.status === PsychoJS.Status.STARTED || second_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C10.setAutoDraw(false);
     }
     
     // *second_circle_pres_C11* updates
     if (t >= 0 && second_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C11.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C11.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C11.status === PsychoJS.Status.STARTED || second_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C11.setAutoDraw(false);
     }
     
     // *second_circle_pres_C12* updates
     if (t >= 0 && second_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C12.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C12.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C12.status === PsychoJS.Status.STARTED || second_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C12.setAutoDraw(false);
     }
     
     // *second_circle_pres_C13* updates
     if (t >= 0 && second_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C13.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C13.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C13.status === PsychoJS.Status.STARTED || second_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C13.setAutoDraw(false);
     }
     
     // *second_circle_pres_C14* updates
     if (t >= 0 && second_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C14.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C14.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C14.status === PsychoJS.Status.STARTED || second_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C14.setAutoDraw(false);
     }
     
     // *second_circle_pres_C15* updates
     if (t >= 0 && second_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C15.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C15.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C15.status === PsychoJS.Status.STARTED || second_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C15.setAutoDraw(false);
     }
     
     // *second_circle_pres_C16* updates
     if (t >= 0 && second_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
       second_circle_pres_C16.frameNStart = frameN;  // exact frame index
       
       second_circle_pres_C16.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((second_circle_pres_C16.status === PsychoJS.Status.STARTED || second_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       second_circle_pres_C16.setAutoDraw(false);
     }
     if ((circle_loop < 3)) {
         if ((practice_correct === 1)) {
             continueRoutine = false;
         }
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Second_Circle_PresentationComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Second_Circle_PresentationRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Second_Circle_Presentation'-------
     for (const thisComponent of Second_Circle_PresentationComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Third_Circle_PresentationComponents;
 function Third_Circle_PresentationRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Third_Circle_Presentation'-------
     t = 0;
     Third_Circle_PresentationClock.reset(); // clock
     frameN = -1;
     routineTimer.add(0.900000);
     // update component parameters for each repeat
     third_circle_pres_C1.setFillColor(new util.Color(circle1color_third_circle_shown));
     third_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C2.setFillColor(new util.Color(circle2color_third_circle_shown));
     third_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C3.setFillColor(new util.Color(circle3color_third_circle_shown));
     third_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C4.setFillColor(new util.Color(circle4color_third_circle_shown));
     third_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C5.setFillColor(new util.Color(circle5color_third_circle_shown));
     third_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C6.setFillColor(new util.Color(circle6color_third_circle_shown));
     third_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C7.setFillColor(new util.Color(circle7color_third_circle_shown));
     third_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C8.setFillColor(new util.Color(circle8color_third_circle_shown));
     third_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C9.setFillColor(new util.Color(circle9color_third_circle_shown));
     third_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C10.setFillColor(new util.Color(circle10color_third_circle_shown));
     third_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C11.setFillColor(new util.Color(circle11color_third_circle_shown));
     third_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C12.setFillColor(new util.Color(circle12color_third_circle_shown));
     third_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C13.setFillColor(new util.Color(circle13color_third_circle_shown));
     third_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C14.setFillColor(new util.Color(circle14color_third_circle_shown));
     third_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C15.setFillColor(new util.Color(circle15color_third_circle_shown));
     third_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     third_circle_pres_C16.setFillColor(new util.Color(circle16color_third_circle_shown));
     third_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     // keep track of which components have finished
     Third_Circle_PresentationComponents = [];
     Third_Circle_PresentationComponents.push(third_circle_pres_C1);
     Third_Circle_PresentationComponents.push(third_circle_pres_C2);
     Third_Circle_PresentationComponents.push(third_circle_pres_C3);
     Third_Circle_PresentationComponents.push(third_circle_pres_C4);
     Third_Circle_PresentationComponents.push(third_circle_pres_C5);
     Third_Circle_PresentationComponents.push(third_circle_pres_C6);
     Third_Circle_PresentationComponents.push(third_circle_pres_C7);
     Third_Circle_PresentationComponents.push(third_circle_pres_C8);
     Third_Circle_PresentationComponents.push(third_circle_pres_C9);
     Third_Circle_PresentationComponents.push(third_circle_pres_C10);
     Third_Circle_PresentationComponents.push(third_circle_pres_C11);
     Third_Circle_PresentationComponents.push(third_circle_pres_C12);
     Third_Circle_PresentationComponents.push(third_circle_pres_C13);
     Third_Circle_PresentationComponents.push(third_circle_pres_C14);
     Third_Circle_PresentationComponents.push(third_circle_pres_C15);
     Third_Circle_PresentationComponents.push(third_circle_pres_C16);
     
     for (const thisComponent of Third_Circle_PresentationComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Third_Circle_PresentationRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Third_Circle_Presentation'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Third_Circle_PresentationClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *third_circle_pres_C1* updates
     if (t >= 0 && third_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C1.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C1.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C1.status === PsychoJS.Status.STARTED || third_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C1.setAutoDraw(false);
     }
     
     // *third_circle_pres_C2* updates
     if (t >= 0 && third_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C2.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C2.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C2.status === PsychoJS.Status.STARTED || third_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C2.setAutoDraw(false);
     }
     
     // *third_circle_pres_C3* updates
     if (t >= 0 && third_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C3.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C3.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C3.status === PsychoJS.Status.STARTED || third_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C3.setAutoDraw(false);
     }
     
     // *third_circle_pres_C4* updates
     if (t >= 0 && third_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C4.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C4.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C4.status === PsychoJS.Status.STARTED || third_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C4.setAutoDraw(false);
     }
     
     // *third_circle_pres_C5* updates
     if (t >= 0 && third_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C5.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C5.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C5.status === PsychoJS.Status.STARTED || third_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C5.setAutoDraw(false);
     }
     
     // *third_circle_pres_C6* updates
     if (t >= 0 && third_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C6.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C6.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C6.status === PsychoJS.Status.STARTED || third_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C6.setAutoDraw(false);
     }
     
     // *third_circle_pres_C7* updates
     if (t >= 0 && third_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C7.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C7.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C7.status === PsychoJS.Status.STARTED || third_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C7.setAutoDraw(false);
     }
     
     // *third_circle_pres_C8* updates
     if (t >= 0 && third_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C8.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C8.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C8.status === PsychoJS.Status.STARTED || third_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C8.setAutoDraw(false);
     }
     
     // *third_circle_pres_C9* updates
     if (t >= 0 && third_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C9.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C9.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C9.status === PsychoJS.Status.STARTED || third_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C9.setAutoDraw(false);
     }
     
     // *third_circle_pres_C10* updates
     if (t >= 0 && third_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C10.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C10.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C10.status === PsychoJS.Status.STARTED || third_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C10.setAutoDraw(false);
     }
     
     // *third_circle_pres_C11* updates
     if (t >= 0 && third_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C11.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C11.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C11.status === PsychoJS.Status.STARTED || third_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C11.setAutoDraw(false);
     }
     
     // *third_circle_pres_C12* updates
     if (t >= 0 && third_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C12.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C12.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C12.status === PsychoJS.Status.STARTED || third_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C12.setAutoDraw(false);
     }
     
     // *third_circle_pres_C13* updates
     if (t >= 0 && third_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C13.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C13.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C13.status === PsychoJS.Status.STARTED || third_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C13.setAutoDraw(false);
     }
     
     // *third_circle_pres_C14* updates
     if (t >= 0 && third_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C14.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C14.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C14.status === PsychoJS.Status.STARTED || third_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C14.setAutoDraw(false);
     }
     
     // *third_circle_pres_C15* updates
     if (t >= 0 && third_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C15.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C15.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C15.status === PsychoJS.Status.STARTED || third_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C15.setAutoDraw(false);
     }
     
     // *third_circle_pres_C16* updates
     if (t >= 0 && third_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
       third_circle_pres_C16.frameNStart = frameN;  // exact frame index
       
       third_circle_pres_C16.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((third_circle_pres_C16.status === PsychoJS.Status.STARTED || third_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       third_circle_pres_C16.setAutoDraw(false);
     }
     if ((circle_loop < 3)) {
         if ((practice_correct === 1)) {
             continueRoutine = false;
         }
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Third_Circle_PresentationComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Third_Circle_PresentationRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Third_Circle_Presentation'-------
     for (const thisComponent of Third_Circle_PresentationComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Fourth_Circle_PresentationComponents;
 function Fourth_Circle_PresentationRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Fourth_Circle_Presentation'-------
     t = 0;
     Fourth_Circle_PresentationClock.reset(); // clock
     frameN = -1;
     routineTimer.add(0.900000);
     // update component parameters for each repeat
     fourth_circle_pres_C1.setFillColor(new util.Color(circle1color_fourth_circle_shown));
     fourth_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C2.setFillColor(new util.Color(circle2color_fourth_circle_shown));
     fourth_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C3.setFillColor(new util.Color(circle3color_fourth_circle_shown));
     fourth_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C4.setFillColor(new util.Color(circle4color_fourth_circle_shown));
     fourth_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C5.setFillColor(new util.Color(circle5color_fourth_circle_shown));
     fourth_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C6.setFillColor(new util.Color(circle6color_fourth_circle_shown));
     fourth_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C7.setFillColor(new util.Color(circle7color_fourth_circle_shown));
     fourth_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C8.setFillColor(new util.Color(circle8color_fourth_circle_shown));
     fourth_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C9.setFillColor(new util.Color(circle9color_fourth_circle_shown));
     fourth_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C10.setFillColor(new util.Color(circle10color_fourth_circle_shown));
     fourth_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C11.setFillColor(new util.Color(circle11color_fourth_circle_shown));
     fourth_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C12.setFillColor(new util.Color(circle12color_fourth_circle_shown));
     fourth_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C13.setFillColor(new util.Color(circle13color_fourth_circle_shown));
     fourth_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C14.setFillColor(new util.Color(circle14color_fourth_circle_shown));
     fourth_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C15.setFillColor(new util.Color(circle15color_fourth_circle_shown));
     fourth_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fourth_circle_pres_C16.setFillColor(new util.Color(circle16color_fourth_circle_shown));
     fourth_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     // keep track of which components have finished
     Fourth_Circle_PresentationComponents = [];
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C1);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C2);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C3);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C4);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C5);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C6);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C7);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C8);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C9);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C10);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C11);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C12);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C13);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C14);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C15);
     Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C16);
     
     for (const thisComponent of Fourth_Circle_PresentationComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Fourth_Circle_PresentationRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Fourth_Circle_Presentation'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Fourth_Circle_PresentationClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     if ((circle_loop > 3)) {
         continueRoutine = true;
     } else {
         continueRoutine = false;
     }
     
     
     // *fourth_circle_pres_C1* updates
     if (t >= 0 && fourth_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C1.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C1.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C1.status === PsychoJS.Status.STARTED || fourth_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C1.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C2* updates
     if (t >= 0 && fourth_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C2.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C2.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C2.status === PsychoJS.Status.STARTED || fourth_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C2.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C3* updates
     if (t >= 0 && fourth_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C3.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C3.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C3.status === PsychoJS.Status.STARTED || fourth_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C3.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C4* updates
     if (t >= 0 && fourth_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C4.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C4.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C4.status === PsychoJS.Status.STARTED || fourth_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C4.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C5* updates
     if (t >= 0 && fourth_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C5.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C5.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C5.status === PsychoJS.Status.STARTED || fourth_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C5.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C6* updates
     if (t >= 0 && fourth_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C6.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C6.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C6.status === PsychoJS.Status.STARTED || fourth_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C6.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C7* updates
     if (t >= 0 && fourth_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C7.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C7.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C7.status === PsychoJS.Status.STARTED || fourth_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C7.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C8* updates
     if (t >= 0 && fourth_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C8.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C8.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C8.status === PsychoJS.Status.STARTED || fourth_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C8.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C9* updates
     if (t >= 0 && fourth_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C9.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C9.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C9.status === PsychoJS.Status.STARTED || fourth_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C9.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C10* updates
     if (t >= 0 && fourth_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C10.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C10.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C10.status === PsychoJS.Status.STARTED || fourth_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C10.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C11* updates
     if (t >= 0 && fourth_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C11.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C11.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C11.status === PsychoJS.Status.STARTED || fourth_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C11.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C12* updates
     if (t >= 0 && fourth_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C12.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C12.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C12.status === PsychoJS.Status.STARTED || fourth_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C12.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C13* updates
     if (t >= 0 && fourth_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C13.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C13.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C13.status === PsychoJS.Status.STARTED || fourth_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C13.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C14* updates
     if (t >= 0 && fourth_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C14.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C14.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C14.status === PsychoJS.Status.STARTED || fourth_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C14.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C15* updates
     if (t >= 0 && fourth_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C15.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C15.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C15.status === PsychoJS.Status.STARTED || fourth_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C15.setAutoDraw(false);
     }
     
     // *fourth_circle_pres_C16* updates
     if (t >= 0 && fourth_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
       fourth_circle_pres_C16.frameNStart = frameN;  // exact frame index
       
       fourth_circle_pres_C16.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fourth_circle_pres_C16.status === PsychoJS.Status.STARTED || fourth_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fourth_circle_pres_C16.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Fourth_Circle_PresentationComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Fourth_Circle_PresentationRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Fourth_Circle_Presentation'-------
     for (const thisComponent of Fourth_Circle_PresentationComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Fifth_Circle_PresentationComponents;
 function Fifth_Circle_PresentationRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Fifth_Circle_Presentation'-------
     t = 0;
     Fifth_Circle_PresentationClock.reset(); // clock
     frameN = -1;
     routineTimer.add(0.900000);
     // update component parameters for each repeat
     fifth_circle_pres_C1.setFillColor(new util.Color(circle1color_fifth_circle_shown));
     fifth_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C2.setFillColor(new util.Color(circle2color_fifth_circle_shown));
     fifth_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C3.setFillColor(new util.Color(circle3color_fifth_circle_shown));
     fifth_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C4.setFillColor(new util.Color(circle4color_fifth_circle_shown));
     fifth_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C5.setFillColor(new util.Color(circle5color_fifth_circle_shown));
     fifth_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C6.setFillColor(new util.Color(circle6color_fifth_circle_shown));
     fifth_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C7.setFillColor(new util.Color(circle7color_fifth_circle_shown));
     fifth_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C8.setFillColor(new util.Color(circle8color_fifth_circle_shown));
     fifth_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C9.setFillColor(new util.Color(circle9color_fifth_circle_shown));
     fifth_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C10.setFillColor(new util.Color(circle10color_fifth_circle_shown));
     fifth_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C11.setFillColor(new util.Color(circle11color_fifth_circle_shown));
     fifth_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C12.setFillColor(new util.Color(circle12color_fifth_circle_shown));
     fifth_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C13.setFillColor(new util.Color(circle13color_fifth_circle_shown));
     fifth_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C14.setFillColor(new util.Color(circle14color_fifth_circle_shown));
     fifth_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C15.setFillColor(new util.Color(circle15color_fifth_circle_shown));
     fifth_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     fifth_circle_pres_C16.setFillColor(new util.Color(circle16color_fifth_circle_shown));
     fifth_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     // keep track of which components have finished
     Fifth_Circle_PresentationComponents = [];
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C1);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C2);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C3);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C4);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C5);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C6);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C7);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C8);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C9);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C10);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C11);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C12);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C13);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C14);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C15);
     Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C16);
     
     for (const thisComponent of Fifth_Circle_PresentationComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Fifth_Circle_PresentationRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Fifth_Circle_Presentation'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Fifth_Circle_PresentationClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     if ((circle_loop > 4)) {
         continueRoutine = true;
     } else {
         continueRoutine = false;
     }
     
     
     // *fifth_circle_pres_C1* updates
     if (t >= 0 && fifth_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C1.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C1.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C1.status === PsychoJS.Status.STARTED || fifth_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C1.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C2* updates
     if (t >= 0 && fifth_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C2.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C2.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C2.status === PsychoJS.Status.STARTED || fifth_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C2.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C3* updates
     if (t >= 0 && fifth_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C3.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C3.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C3.status === PsychoJS.Status.STARTED || fifth_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C3.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C4* updates
     if (t >= 0 && fifth_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C4.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C4.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C4.status === PsychoJS.Status.STARTED || fifth_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C4.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C5* updates
     if (t >= 0 && fifth_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C5.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C5.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C5.status === PsychoJS.Status.STARTED || fifth_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C5.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C6* updates
     if (t >= 0 && fifth_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C6.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C6.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C6.status === PsychoJS.Status.STARTED || fifth_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C6.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C7* updates
     if (t >= 0 && fifth_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C7.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C7.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C7.status === PsychoJS.Status.STARTED || fifth_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C7.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C8* updates
     if (t >= 0 && fifth_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C8.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C8.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C8.status === PsychoJS.Status.STARTED || fifth_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C8.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C9* updates
     if (t >= 0 && fifth_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C9.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C9.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C9.status === PsychoJS.Status.STARTED || fifth_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C9.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C10* updates
     if (t >= 0 && fifth_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C10.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C10.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C10.status === PsychoJS.Status.STARTED || fifth_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C10.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C11* updates
     if (t >= 0 && fifth_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C11.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C11.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C11.status === PsychoJS.Status.STARTED || fifth_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C11.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C12* updates
     if (t >= 0 && fifth_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C12.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C12.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C12.status === PsychoJS.Status.STARTED || fifth_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C12.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C13* updates
     if (t >= 0 && fifth_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C13.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C13.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C13.status === PsychoJS.Status.STARTED || fifth_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C13.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C14* updates
     if (t >= 0 && fifth_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C14.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C14.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C14.status === PsychoJS.Status.STARTED || fifth_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C14.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C15* updates
     if (t >= 0 && fifth_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C15.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C15.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C15.status === PsychoJS.Status.STARTED || fifth_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C15.setAutoDraw(false);
     }
     
     // *fifth_circle_pres_C16* updates
     if (t >= 0 && fifth_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
       fifth_circle_pres_C16.frameNStart = frameN;  // exact frame index
       
       fifth_circle_pres_C16.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fifth_circle_pres_C16.status === PsychoJS.Status.STARTED || fifth_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fifth_circle_pres_C16.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Fifth_Circle_PresentationComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Fifth_Circle_PresentationRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Fifth_Circle_Presentation'-------
     for (const thisComponent of Fifth_Circle_PresentationComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Sixth_Circle_PresentationComponents;
 function Sixth_Circle_PresentationRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Sixth_Circle_Presentation'-------
     t = 0;
     Sixth_Circle_PresentationClock.reset(); // clock
     frameN = -1;
     routineTimer.add(0.900000);
     // update component parameters for each repeat
     sixth_circle_pres_C1.setFillColor(new util.Color(circle1color_sixth_circle_shown));
     sixth_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C2.setFillColor(new util.Color(circle2color_sixth_circle_shown));
     sixth_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C3.setFillColor(new util.Color(circle3color_sixth_circle_shown));
     sixth_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C4.setFillColor(new util.Color(circle4color_sixth_circle_shown));
     sixth_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C5.setFillColor(new util.Color(circle5color_sixth_circle_shown));
     sixth_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C6.setFillColor(new util.Color(circle6color_sixth_circle_shown));
     sixth_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C7.setFillColor(new util.Color(circle7color_sixth_circle_shown));
     sixth_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C8.setFillColor(new util.Color(circle8color_sixth_circle_shown));
     sixth_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C9.setFillColor(new util.Color(circle9color_sixth_circle_shown));
     sixth_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C10.setFillColor(new util.Color(circle10color_sixth_circle_shown));
     sixth_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C11.setFillColor(new util.Color(circle11color_sixth_circle_shown));
     sixth_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C12.setFillColor(new util.Color(circle12color_sixth_circle_shown));
     sixth_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C13.setFillColor(new util.Color(circle13color_sixth_circle_shown));
     sixth_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C14.setFillColor(new util.Color(circle14color_sixth_circle_shown));
     sixth_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C15.setFillColor(new util.Color(circle15color_sixth_circle_shown));
     sixth_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     sixth_circle_pres_C16.setFillColor(new util.Color(circle16color_sixth_circle_shown));
     sixth_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     // keep track of which components have finished
     Sixth_Circle_PresentationComponents = [];
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C1);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C2);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C3);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C4);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C5);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C6);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C7);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C8);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C9);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C10);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C11);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C12);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C13);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C14);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C15);
     Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C16);
     
     for (const thisComponent of Sixth_Circle_PresentationComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Sixth_Circle_PresentationRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Sixth_Circle_Presentation'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Sixth_Circle_PresentationClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     if ((circle_loop > 5)) {
         continueRoutine = true;
     } else {
         continueRoutine = false;
     }
     
     
     // *sixth_circle_pres_C1* updates
     if (t >= 0 && sixth_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C1.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C1.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C1.status === PsychoJS.Status.STARTED || sixth_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C1.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C2* updates
     if (t >= 0 && sixth_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C2.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C2.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C2.status === PsychoJS.Status.STARTED || sixth_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C2.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C3* updates
     if (t >= 0 && sixth_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C3.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C3.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C3.status === PsychoJS.Status.STARTED || sixth_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C3.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C4* updates
     if (t >= 0 && sixth_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C4.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C4.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C4.status === PsychoJS.Status.STARTED || sixth_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C4.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C5* updates
     if (t >= 0 && sixth_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C5.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C5.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C5.status === PsychoJS.Status.STARTED || sixth_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C5.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C6* updates
     if (t >= 0 && sixth_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C6.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C6.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C6.status === PsychoJS.Status.STARTED || sixth_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C6.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C7* updates
     if (t >= 0 && sixth_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C7.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C7.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C7.status === PsychoJS.Status.STARTED || sixth_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C7.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C8* updates
     if (t >= 0 && sixth_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C8.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C8.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C8.status === PsychoJS.Status.STARTED || sixth_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C8.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C9* updates
     if (t >= 0 && sixth_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C9.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C9.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C9.status === PsychoJS.Status.STARTED || sixth_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C9.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C10* updates
     if (t >= 0 && sixth_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C10.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C10.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C10.status === PsychoJS.Status.STARTED || sixth_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C10.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C11* updates
     if (t >= 0 && sixth_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C11.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C11.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C11.status === PsychoJS.Status.STARTED || sixth_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C11.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C12* updates
     if (t >= 0 && sixth_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C12.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C12.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C12.status === PsychoJS.Status.STARTED || sixth_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C12.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C13* updates
     if (t >= 0 && sixth_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C13.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C13.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C13.status === PsychoJS.Status.STARTED || sixth_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C13.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C14* updates
     if (t >= 0 && sixth_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C14.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C14.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C14.status === PsychoJS.Status.STARTED || sixth_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C14.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C15* updates
     if (t >= 0 && sixth_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C15.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C15.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C15.status === PsychoJS.Status.STARTED || sixth_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C15.setAutoDraw(false);
     }
     
     // *sixth_circle_pres_C16* updates
     if (t >= 0 && sixth_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
       sixth_circle_pres_C16.frameNStart = frameN;  // exact frame index
       
       sixth_circle_pres_C16.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((sixth_circle_pres_C16.status === PsychoJS.Status.STARTED || sixth_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       sixth_circle_pres_C16.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Sixth_Circle_PresentationComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Sixth_Circle_PresentationRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Sixth_Circle_Presentation'-------
     for (const thisComponent of Sixth_Circle_PresentationComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Seventh_Circle_PresentationComponents;
 function Seventh_Circle_PresentationRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Seventh_Circle_Presentation'-------
     t = 0;
     Seventh_Circle_PresentationClock.reset(); // clock
     frameN = -1;
     routineTimer.add(0.900000);
     // update component parameters for each repeat
     seventh_circle_pres_C1.setFillColor(new util.Color(circle1color_seventh_circle_shown));
     seventh_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C2.setFillColor(new util.Color(circle2color_seventh_circle_shown));
     seventh_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C3.setFillColor(new util.Color(circle3color_seventh_circle_shown));
     seventh_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C4.setFillColor(new util.Color(circle4color_seventh_circle_shown));
     seventh_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C5.setFillColor(new util.Color(circle5color_seventh_circle_shown));
     seventh_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C6.setFillColor(new util.Color(circle6color_seventh_circle_shown));
     seventh_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C7.setFillColor(new util.Color(circle7color_seventh_circle_shown));
     seventh_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C8.setFillColor(new util.Color(circle8color_seventh_circle_shown));
     seventh_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C9.setFillColor(new util.Color(circle9color_seventh_circle_shown));
     seventh_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C10.setFillColor(new util.Color(circle10color_seventh_circle_shown));
     seventh_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C11.setFillColor(new util.Color(circle11color_seventh_circle_shown));
     seventh_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C12.setFillColor(new util.Color(circle12color_seventh_circle_shown));
     seventh_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C13.setFillColor(new util.Color(circle13color_seventh_circle_shown));
     seventh_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C14.setFillColor(new util.Color(circle14color_seventh_circle_shown));
     seventh_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C15.setFillColor(new util.Color(circle15color_seventh_circle_shown));
     seventh_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     seventh_circle_pres_C16.setFillColor(new util.Color(circle16color_seventh_circle_shown));
     seventh_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     // keep track of which components have finished
     Seventh_Circle_PresentationComponents = [];
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C1);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C2);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C3);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C4);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C5);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C6);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C7);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C8);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C9);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C10);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C11);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C12);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C13);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C14);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C15);
     Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C16);
     
     for (const thisComponent of Seventh_Circle_PresentationComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Seventh_Circle_PresentationRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Seventh_Circle_Presentation'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Seventh_Circle_PresentationClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     if ((circle_loop > 6)) {
         continueRoutine = true;
     } else {
         continueRoutine = false;
     }
     
     
     // *seventh_circle_pres_C1* updates
     if (t >= 0 && seventh_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C1.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C1.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C1.status === PsychoJS.Status.STARTED || seventh_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C1.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C2* updates
     if (t >= 0 && seventh_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C2.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C2.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C2.status === PsychoJS.Status.STARTED || seventh_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C2.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C3* updates
     if (t >= 0 && seventh_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C3.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C3.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C3.status === PsychoJS.Status.STARTED || seventh_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C3.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C4* updates
     if (t >= 0 && seventh_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C4.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C4.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C4.status === PsychoJS.Status.STARTED || seventh_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C4.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C5* updates
     if (t >= 0 && seventh_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C5.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C5.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C5.status === PsychoJS.Status.STARTED || seventh_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C5.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C6* updates
     if (t >= 0 && seventh_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C6.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C6.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C6.status === PsychoJS.Status.STARTED || seventh_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C6.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C7* updates
     if (t >= 0 && seventh_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C7.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C7.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C7.status === PsychoJS.Status.STARTED || seventh_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C7.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C8* updates
     if (t >= 0 && seventh_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C8.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C8.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C8.status === PsychoJS.Status.STARTED || seventh_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C8.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C9* updates
     if (t >= 0 && seventh_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C9.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C9.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C9.status === PsychoJS.Status.STARTED || seventh_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C9.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C10* updates
     if (t >= 0 && seventh_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C10.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C10.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C10.status === PsychoJS.Status.STARTED || seventh_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C10.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C11* updates
     if (t >= 0 && seventh_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C11.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C11.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C11.status === PsychoJS.Status.STARTED || seventh_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C11.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C12* updates
     if (t >= 0 && seventh_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C12.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C12.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C12.status === PsychoJS.Status.STARTED || seventh_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C12.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C13* updates
     if (t >= 0 && seventh_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C13.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C13.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C13.status === PsychoJS.Status.STARTED || seventh_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C13.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C14* updates
     if (t >= 0 && seventh_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C14.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C14.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C14.status === PsychoJS.Status.STARTED || seventh_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C14.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C15* updates
     if (t >= 0 && seventh_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C15.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C15.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C15.status === PsychoJS.Status.STARTED || seventh_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C15.setAutoDraw(false);
     }
     
     // *seventh_circle_pres_C16* updates
     if (t >= 0 && seventh_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
       seventh_circle_pres_C16.frameNStart = frameN;  // exact frame index
       
       seventh_circle_pres_C16.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((seventh_circle_pres_C16.status === PsychoJS.Status.STARTED || seventh_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       seventh_circle_pres_C16.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Seventh_Circle_PresentationComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Seventh_Circle_PresentationRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Seventh_Circle_Presentation'-------
     for (const thisComponent of Seventh_Circle_PresentationComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Eighth_Circle_PresentationComponents;
 function Eighth_Circle_PresentationRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Eighth_Circle_Presentation'-------
     t = 0;
     Eighth_Circle_PresentationClock.reset(); // clock
     frameN = -1;
     routineTimer.add(0.900000);
     // update component parameters for each repeat
     eighth_circle_pres_C1.setFillColor(new util.Color(circle1color_eighth_circle_shown));
     eighth_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C2.setFillColor(new util.Color(circle2color_eighth_circle_shown));
     eighth_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C3.setFillColor(new util.Color(circle3color_eighth_circle_shown));
     eighth_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C4.setFillColor(new util.Color(circle4color_eighth_circle_shown));
     eighth_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C5.setFillColor(new util.Color(circle5color_eighth_circle_shown));
     eighth_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C6.setFillColor(new util.Color(circle6color_eighth_circle_shown));
     eighth_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C7.setFillColor(new util.Color(circle7color_eighth_circle_shown));
     eighth_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C8.setFillColor(new util.Color(circle8color_eighth_circle_shown));
     eighth_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C9.setFillColor(new util.Color(circle9color_eighth_circle_shown));
     eighth_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C10.setFillColor(new util.Color(circle10color_eighth_circle_shown));
     eighth_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C11.setFillColor(new util.Color(circle11color_eighth_circle_shown));
     eighth_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C12.setFillColor(new util.Color(circle12color_eighth_circle_shown));
     eighth_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C13.setFillColor(new util.Color(circle13color_eighth_circle_shown));
     eighth_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C14.setFillColor(new util.Color(circle14color_eighth_circle_shown));
     eighth_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C15.setFillColor(new util.Color(circle15color_eighth_circle_shown));
     eighth_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     eighth_circle_pres_C16.setFillColor(new util.Color(circle16color_eighth_circle_shown));
     eighth_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
     // keep track of which components have finished
     Eighth_Circle_PresentationComponents = [];
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C1);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C2);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C3);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C4);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C5);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C6);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C7);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C8);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C9);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C10);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C11);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C12);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C13);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C14);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C15);
     Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C16);
     
     for (const thisComponent of Eighth_Circle_PresentationComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Eighth_Circle_PresentationRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Eighth_Circle_Presentation'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Eighth_Circle_PresentationClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     if ((circle_loop > 7)) {
         continueRoutine = true;
     } else {
         continueRoutine = false;
     }
     
     
     // *eighth_circle_pres_C1* updates
     if (t >= 0 && eighth_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C1.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C1.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C1.status === PsychoJS.Status.STARTED || eighth_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C1.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C2* updates
     if (t >= 0 && eighth_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C2.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C2.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C2.status === PsychoJS.Status.STARTED || eighth_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C2.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C3* updates
     if (t >= 0 && eighth_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C3.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C3.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C3.status === PsychoJS.Status.STARTED || eighth_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C3.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C4* updates
     if (t >= 0 && eighth_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C4.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C4.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C4.status === PsychoJS.Status.STARTED || eighth_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C4.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C5* updates
     if (t >= 0 && eighth_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C5.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C5.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C5.status === PsychoJS.Status.STARTED || eighth_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C5.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C6* updates
     if (t >= 0 && eighth_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C6.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C6.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C6.status === PsychoJS.Status.STARTED || eighth_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C6.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C7* updates
     if (t >= 0 && eighth_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C7.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C7.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C7.status === PsychoJS.Status.STARTED || eighth_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C7.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C8* updates
     if (t >= 0 && eighth_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C8.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C8.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C8.status === PsychoJS.Status.STARTED || eighth_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C8.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C9* updates
     if (t >= 0 && eighth_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C9.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C9.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C9.status === PsychoJS.Status.STARTED || eighth_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C9.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C10* updates
     if (t >= 0 && eighth_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C10.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C10.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C10.status === PsychoJS.Status.STARTED || eighth_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C10.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C11* updates
     if (t >= 0 && eighth_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C11.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C11.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C11.status === PsychoJS.Status.STARTED || eighth_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C11.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C12* updates
     if (t >= 0 && eighth_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C12.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C12.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C12.status === PsychoJS.Status.STARTED || eighth_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C12.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C13* updates
     if (t >= 0 && eighth_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C13.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C13.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C13.status === PsychoJS.Status.STARTED || eighth_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C13.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C14* updates
     if (t >= 0 && eighth_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C14.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C14.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C14.status === PsychoJS.Status.STARTED || eighth_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C14.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C15* updates
     if (t >= 0 && eighth_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C15.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C15.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C15.status === PsychoJS.Status.STARTED || eighth_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C15.setAutoDraw(false);
     }
     
     // *eighth_circle_pres_C16* updates
     if (t >= 0 && eighth_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
       eighth_circle_pres_C16.frameNStart = frameN;  // exact frame index
       
       eighth_circle_pres_C16.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((eighth_circle_pres_C16.status === PsychoJS.Status.STARTED || eighth_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       eighth_circle_pres_C16.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Eighth_Circle_PresentationComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Eighth_Circle_PresentationRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Eighth_Circle_Presentation'-------
     for (const thisComponent of Eighth_Circle_PresentationComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Wait_for_First_responseComponents;
 function Wait_for_First_responseRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Wait_for_First_response'-------
     t = 0;
     Wait_for_First_responseClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the first_mouse_response
     // current position of the mouse:
     first_mouse_response.x = [];
     first_mouse_response.y = [];
     first_mouse_response.leftButton = [];
     first_mouse_response.midButton = [];
     first_mouse_response.rightButton = [];
     first_mouse_response.time = [];
     first_mouse_response.clicked_name = [];
     gotValidClick = false; // until a click is received
     first_mouse_response.mouseClock.reset();
     clicked_frame = null;
     
     // keep track of which components have finished
     Wait_for_First_responseComponents = [];
     Wait_for_First_responseComponents.push(first_response_C1);
     Wait_for_First_responseComponents.push(first_response_C2);
     Wait_for_First_responseComponents.push(first_response_C3);
     Wait_for_First_responseComponents.push(first_response_C4);
     Wait_for_First_responseComponents.push(first_response_C5);
     Wait_for_First_responseComponents.push(first_response_C6);
     Wait_for_First_responseComponents.push(first_response_C7);
     Wait_for_First_responseComponents.push(first_response_C8);
     Wait_for_First_responseComponents.push(first_response_C9);
     Wait_for_First_responseComponents.push(first_response_C10);
     Wait_for_First_responseComponents.push(first_response_C11);
     Wait_for_First_responseComponents.push(first_response_C12);
     Wait_for_First_responseComponents.push(first_response_C13);
     Wait_for_First_responseComponents.push(first_response_C14);
     Wait_for_First_responseComponents.push(first_response_C15);
     Wait_for_First_responseComponents.push(first_response_C16);
     Wait_for_First_responseComponents.push(first_mouse_response);
     
     for (const thisComponent of Wait_for_First_responseComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_for_First_responseRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Wait_for_First_response'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Wait_for_First_responseClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *first_response_C1* updates
     if (t >= 0 && first_response_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C1.tStart = t;  // (not accounting for frame time here)
       first_response_C1.frameNStart = frameN;  // exact frame index
       
       first_response_C1.setAutoDraw(true);
     }
 
     
     // *first_response_C2* updates
     if (t >= 0 && first_response_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C2.tStart = t;  // (not accounting for frame time here)
       first_response_C2.frameNStart = frameN;  // exact frame index
       
       first_response_C2.setAutoDraw(true);
     }
 
     
     // *first_response_C3* updates
     if (t >= 0 && first_response_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C3.tStart = t;  // (not accounting for frame time here)
       first_response_C3.frameNStart = frameN;  // exact frame index
       
       first_response_C3.setAutoDraw(true);
     }
 
     
     // *first_response_C4* updates
     if (t >= 0 && first_response_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C4.tStart = t;  // (not accounting for frame time here)
       first_response_C4.frameNStart = frameN;  // exact frame index
       
       first_response_C4.setAutoDraw(true);
     }
 
     
     // *first_response_C5* updates
     if (t >= 0 && first_response_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C5.tStart = t;  // (not accounting for frame time here)
       first_response_C5.frameNStart = frameN;  // exact frame index
       
       first_response_C5.setAutoDraw(true);
     }
 
     
     // *first_response_C6* updates
     if (t >= 0 && first_response_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C6.tStart = t;  // (not accounting for frame time here)
       first_response_C6.frameNStart = frameN;  // exact frame index
       
       first_response_C6.setAutoDraw(true);
     }
 
     
     // *first_response_C7* updates
     if (t >= 0 && first_response_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C7.tStart = t;  // (not accounting for frame time here)
       first_response_C7.frameNStart = frameN;  // exact frame index
       
       first_response_C7.setAutoDraw(true);
     }
 
     
     // *first_response_C8* updates
     if (t >= 0 && first_response_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C8.tStart = t;  // (not accounting for frame time here)
       first_response_C8.frameNStart = frameN;  // exact frame index
       
       first_response_C8.setAutoDraw(true);
     }
 
     
     // *first_response_C9* updates
     if (t >= 0 && first_response_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C9.tStart = t;  // (not accounting for frame time here)
       first_response_C9.frameNStart = frameN;  // exact frame index
       
       first_response_C9.setAutoDraw(true);
     }
 
     
     // *first_response_C10* updates
     if (t >= 0 && first_response_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C10.tStart = t;  // (not accounting for frame time here)
       first_response_C10.frameNStart = frameN;  // exact frame index
       
       first_response_C10.setAutoDraw(true);
     }
 
     
     // *first_response_C11* updates
     if (t >= 0 && first_response_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C11.tStart = t;  // (not accounting for frame time here)
       first_response_C11.frameNStart = frameN;  // exact frame index
       
       first_response_C11.setAutoDraw(true);
     }
 
     
     // *first_response_C12* updates
     if (t >= 0 && first_response_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C12.tStart = t;  // (not accounting for frame time here)
       first_response_C12.frameNStart = frameN;  // exact frame index
       
       first_response_C12.setAutoDraw(true);
     }
 
     
     // *first_response_C13* updates
     if (t >= 0 && first_response_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C13.tStart = t;  // (not accounting for frame time here)
       first_response_C13.frameNStart = frameN;  // exact frame index
       
       first_response_C13.setAutoDraw(true);
     }
 
     
     // *first_response_C14* updates
     if (t >= 0 && first_response_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C14.tStart = t;  // (not accounting for frame time here)
       first_response_C14.frameNStart = frameN;  // exact frame index
       
       first_response_C14.setAutoDraw(true);
     }
 
     
     // *first_response_C15* updates
     if (t >= 0 && first_response_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C15.tStart = t;  // (not accounting for frame time here)
       first_response_C15.frameNStart = frameN;  // exact frame index
       
       first_response_C15.setAutoDraw(true);
     }
 
     
     // *first_response_C16* updates
     if (t >= 0 && first_response_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_response_C16.tStart = t;  // (not accounting for frame time here)
       first_response_C16.frameNStart = frameN;  // exact frame index
       
       first_response_C16.setAutoDraw(true);
     }
 
     // *first_mouse_response* updates
     if (t >= 0.0 && first_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       first_mouse_response.tStart = t;  // (not accounting for frame time here)
       first_mouse_response.frameNStart = frameN;  // exact frame index
       
       first_mouse_response.status = PsychoJS.Status.STARTED;
       prevButtonState = first_mouse_response.getPressed();  // if button is down already this ISN'T a new click
       }
     if (first_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = first_mouse_response.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = first_mouse_response.getPos();
           first_mouse_response.x.push(_mouseXYs[0]);
           first_mouse_response.y.push(_mouseXYs[1]);
           first_mouse_response.leftButton.push(_mouseButtons[0]);
           first_mouse_response.midButton.push(_mouseButtons[1]);
           first_mouse_response.rightButton.push(_mouseButtons[2]);
           first_mouse_response.time.push(first_mouse_response.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [first_response_C1, first_response_C2, first_response_C3, first_response_C4, first_response_C5, first_response_C6, first_response_C7, first_response_C8, first_response_C9, first_response_C10, first_response_C11, first_response_C12, first_response_C13, first_response_C14, first_response_C15, first_response_C16]) {
             if (obj.contains(first_mouse_response)) {
               gotValidClick = true;
               first_mouse_response.clicked_name.push(obj.name)
             }
           }
         }
       }
     }
     if ((circle_loop < 3)) {
         if ((practice_correct === 1)) {
             continueRoutine = false;
         }
     }
     
     if (((first_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
         clicked_frame = frameN;
         clicked_circle = eval(first_mouse_response.clicked_name[0]);
         clicked_circle.setFillColor(new util.Color([1, 1, 1]));
     }
     if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
         clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
         continueRoutine = false;
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Wait_for_First_responseComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_for_First_responseRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Wait_for_First_response'-------
     for (const thisComponent of Wait_for_First_responseComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('first_mouse_response.x', first_mouse_response.x);
     psychoJS.experiment.addData('first_mouse_response.y', first_mouse_response.y);
     psychoJS.experiment.addData('first_mouse_response.leftButton', first_mouse_response.leftButton);
     psychoJS.experiment.addData('first_mouse_response.midButton', first_mouse_response.midButton);
     psychoJS.experiment.addData('first_mouse_response.rightButton', first_mouse_response.rightButton);
     psychoJS.experiment.addData('first_mouse_response.time', first_mouse_response.time);
     psychoJS.experiment.addData('first_mouse_response.clicked_name', first_mouse_response.clicked_name);
     
     /* Syntax Error: Fix Python code */
     // the Routine "Wait_for_First_response" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Wait_for_Second_responseComponents;
 function Wait_for_Second_responseRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Wait_for_Second_response'-------
     t = 0;
     Wait_for_Second_responseClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the second_mouse_response
     // current position of the mouse:
     second_mouse_response.x = [];
     second_mouse_response.y = [];
     second_mouse_response.leftButton = [];
     second_mouse_response.midButton = [];
     second_mouse_response.rightButton = [];
     second_mouse_response.time = [];
     second_mouse_response.clicked_name = [];
     gotValidClick = false; // until a click is received
     second_mouse_response.mouseClock.reset();
     clicked_frame = null;
     
     // keep track of which components have finished
     Wait_for_Second_responseComponents = [];
     Wait_for_Second_responseComponents.push(second_response_C1);
     Wait_for_Second_responseComponents.push(second_response_C2);
     Wait_for_Second_responseComponents.push(second_response_C3);
     Wait_for_Second_responseComponents.push(second_response_C4);
     Wait_for_Second_responseComponents.push(second_response_C5);
     Wait_for_Second_responseComponents.push(second_response_C6);
     Wait_for_Second_responseComponents.push(second_response_C7);
     Wait_for_Second_responseComponents.push(second_response_C8);
     Wait_for_Second_responseComponents.push(second_response_C9);
     Wait_for_Second_responseComponents.push(second_response_C10);
     Wait_for_Second_responseComponents.push(second_response_C11);
     Wait_for_Second_responseComponents.push(second_response_C12);
     Wait_for_Second_responseComponents.push(second_response_C13);
     Wait_for_Second_responseComponents.push(second_response_C14);
     Wait_for_Second_responseComponents.push(second_response_C15);
     Wait_for_Second_responseComponents.push(second_response_C16);
     Wait_for_Second_responseComponents.push(second_mouse_response);
     
     for (const thisComponent of Wait_for_Second_responseComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_for_Second_responseRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Wait_for_Second_response'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Wait_for_Second_responseClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *second_response_C1* updates
     if (t >= 0 && second_response_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C1.tStart = t;  // (not accounting for frame time here)
       second_response_C1.frameNStart = frameN;  // exact frame index
       
       second_response_C1.setAutoDraw(true);
     }
 
     
     // *second_response_C2* updates
     if (t >= 0 && second_response_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C2.tStart = t;  // (not accounting for frame time here)
       second_response_C2.frameNStart = frameN;  // exact frame index
       
       second_response_C2.setAutoDraw(true);
     }
 
     
     // *second_response_C3* updates
     if (t >= 0 && second_response_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C3.tStart = t;  // (not accounting for frame time here)
       second_response_C3.frameNStart = frameN;  // exact frame index
       
       second_response_C3.setAutoDraw(true);
     }
 
     
     // *second_response_C4* updates
     if (t >= 0 && second_response_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C4.tStart = t;  // (not accounting for frame time here)
       second_response_C4.frameNStart = frameN;  // exact frame index
       
       second_response_C4.setAutoDraw(true);
     }
 
     
     // *second_response_C5* updates
     if (t >= 0 && second_response_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C5.tStart = t;  // (not accounting for frame time here)
       second_response_C5.frameNStart = frameN;  // exact frame index
       
       second_response_C5.setAutoDraw(true);
     }
 
     
     // *second_response_C6* updates
     if (t >= 0 && second_response_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C6.tStart = t;  // (not accounting for frame time here)
       second_response_C6.frameNStart = frameN;  // exact frame index
       
       second_response_C6.setAutoDraw(true);
     }
 
     
     // *second_response_C7* updates
     if (t >= 0 && second_response_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C7.tStart = t;  // (not accounting for frame time here)
       second_response_C7.frameNStart = frameN;  // exact frame index
       
       second_response_C7.setAutoDraw(true);
     }
 
     
     // *second_response_C8* updates
     if (t >= 0 && second_response_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C8.tStart = t;  // (not accounting for frame time here)
       second_response_C8.frameNStart = frameN;  // exact frame index
       
       second_response_C8.setAutoDraw(true);
     }
 
     
     // *second_response_C9* updates
     if (t >= 0 && second_response_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C9.tStart = t;  // (not accounting for frame time here)
       second_response_C9.frameNStart = frameN;  // exact frame index
       
       second_response_C9.setAutoDraw(true);
     }
 
     
     // *second_response_C10* updates
     if (t >= 0 && second_response_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C10.tStart = t;  // (not accounting for frame time here)
       second_response_C10.frameNStart = frameN;  // exact frame index
       
       second_response_C10.setAutoDraw(true);
     }
 
     
     // *second_response_C11* updates
     if (t >= 0 && second_response_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C11.tStart = t;  // (not accounting for frame time here)
       second_response_C11.frameNStart = frameN;  // exact frame index
       
       second_response_C11.setAutoDraw(true);
     }
 
     
     // *second_response_C12* updates
     if (t >= 0 && second_response_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C12.tStart = t;  // (not accounting for frame time here)
       second_response_C12.frameNStart = frameN;  // exact frame index
       
       second_response_C12.setAutoDraw(true);
     }
 
     
     // *second_response_C13* updates
     if (t >= 0 && second_response_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C13.tStart = t;  // (not accounting for frame time here)
       second_response_C13.frameNStart = frameN;  // exact frame index
       
       second_response_C13.setAutoDraw(true);
     }
 
     
     // *second_response_C14* updates
     if (t >= 0 && second_response_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C14.tStart = t;  // (not accounting for frame time here)
       second_response_C14.frameNStart = frameN;  // exact frame index
       
       second_response_C14.setAutoDraw(true);
     }
 
     
     // *second_response_C15* updates
     if (t >= 0 && second_response_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C15.tStart = t;  // (not accounting for frame time here)
       second_response_C15.frameNStart = frameN;  // exact frame index
       
       second_response_C15.setAutoDraw(true);
     }
 
     
     // *second_response_C16* updates
     if (t >= 0 && second_response_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_response_C16.tStart = t;  // (not accounting for frame time here)
       second_response_C16.frameNStart = frameN;  // exact frame index
       
       second_response_C16.setAutoDraw(true);
     }
 
     // *second_mouse_response* updates
     if (t >= 0.0 && second_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       second_mouse_response.tStart = t;  // (not accounting for frame time here)
       second_mouse_response.frameNStart = frameN;  // exact frame index
       
       second_mouse_response.status = PsychoJS.Status.STARTED;
       prevButtonState = second_mouse_response.getPressed();  // if button is down already this ISN'T a new click
       }
     if (second_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = second_mouse_response.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = second_mouse_response.getPos();
           second_mouse_response.x.push(_mouseXYs[0]);
           second_mouse_response.y.push(_mouseXYs[1]);
           second_mouse_response.leftButton.push(_mouseButtons[0]);
           second_mouse_response.midButton.push(_mouseButtons[1]);
           second_mouse_response.rightButton.push(_mouseButtons[2]);
           second_mouse_response.time.push(second_mouse_response.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [second_response_C1, second_response_C2, second_response_C3, second_response_C4, second_response_C5, second_response_C6, second_response_C7, second_response_C8, second_response_C9, second_response_C10, second_response_C11, second_response_C12, second_response_C13, second_response_C14, second_response_C15, second_response_C16]) {
             if (obj.contains(second_mouse_response)) {
               gotValidClick = true;
               second_mouse_response.clicked_name.push(obj.name)
             }
           }
         }
       }
     }
     if ((circle_loop < 3)) {
         if ((practice_correct === 1)) {
             continueRoutine = false;
         }
     }
     if (((second_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
         clicked_frame = frameN;
         clicked_circle = eval(second_mouse_response.clicked_name[0]);
         clicked_circle.setFillColor(new util.Color([1, 1, 1]));
     }
     if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
         clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
         continueRoutine = false;
     }
     
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Wait_for_Second_responseComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_for_Second_responseRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Wait_for_Second_response'-------
     for (const thisComponent of Wait_for_Second_responseComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('second_mouse_response.x', second_mouse_response.x);
     psychoJS.experiment.addData('second_mouse_response.y', second_mouse_response.y);
     psychoJS.experiment.addData('second_mouse_response.leftButton', second_mouse_response.leftButton);
     psychoJS.experiment.addData('second_mouse_response.midButton', second_mouse_response.midButton);
     psychoJS.experiment.addData('second_mouse_response.rightButton', second_mouse_response.rightButton);
     psychoJS.experiment.addData('second_mouse_response.time', second_mouse_response.time);
     psychoJS.experiment.addData('second_mouse_response.clicked_name', second_mouse_response.clicked_name);
     
     /* Syntax Error: Fix Python code */
     // the Routine "Wait_for_Second_response" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Wait_for_Third_ResponseComponents;
 function Wait_for_Third_ResponseRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Wait_for_Third_Response'-------
     t = 0;
     Wait_for_Third_ResponseClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the third_mouse_response
     // current position of the mouse:
     third_mouse_response.x = [];
     third_mouse_response.y = [];
     third_mouse_response.leftButton = [];
     third_mouse_response.midButton = [];
     third_mouse_response.rightButton = [];
     third_mouse_response.time = [];
     third_mouse_response.clicked_name = [];
     gotValidClick = false; // until a click is received
     third_mouse_response.mouseClock.reset();
     clicked_frame = null;
     
     // keep track of which components have finished
     Wait_for_Third_ResponseComponents = [];
     Wait_for_Third_ResponseComponents.push(third_response_C1);
     Wait_for_Third_ResponseComponents.push(third_response_C2);
     Wait_for_Third_ResponseComponents.push(third_response_C3);
     Wait_for_Third_ResponseComponents.push(third_response_C4);
     Wait_for_Third_ResponseComponents.push(third_response_C5);
     Wait_for_Third_ResponseComponents.push(third_response_C6);
     Wait_for_Third_ResponseComponents.push(third_response_C7);
     Wait_for_Third_ResponseComponents.push(third_response_C8);
     Wait_for_Third_ResponseComponents.push(third_response_C9);
     Wait_for_Third_ResponseComponents.push(third_response_C10);
     Wait_for_Third_ResponseComponents.push(third_response_C11);
     Wait_for_Third_ResponseComponents.push(third_response_C12);
     Wait_for_Third_ResponseComponents.push(third_response_C13);
     Wait_for_Third_ResponseComponents.push(third_response_C14);
     Wait_for_Third_ResponseComponents.push(third_response_C15);
     Wait_for_Third_ResponseComponents.push(third_response_C16);
     Wait_for_Third_ResponseComponents.push(third_mouse_response);
     
     for (const thisComponent of Wait_for_Third_ResponseComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_for_Third_ResponseRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Wait_for_Third_Response'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Wait_for_Third_ResponseClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *third_response_C1* updates
     if (t >= 0 && third_response_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C1.tStart = t;  // (not accounting for frame time here)
       third_response_C1.frameNStart = frameN;  // exact frame index
       
       third_response_C1.setAutoDraw(true);
     }
 
     
     // *third_response_C2* updates
     if (t >= 0 && third_response_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C2.tStart = t;  // (not accounting for frame time here)
       third_response_C2.frameNStart = frameN;  // exact frame index
       
       third_response_C2.setAutoDraw(true);
     }
 
     
     // *third_response_C3* updates
     if (t >= 0 && third_response_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C3.tStart = t;  // (not accounting for frame time here)
       third_response_C3.frameNStart = frameN;  // exact frame index
       
       third_response_C3.setAutoDraw(true);
     }
 
     
     // *third_response_C4* updates
     if (t >= 0 && third_response_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C4.tStart = t;  // (not accounting for frame time here)
       third_response_C4.frameNStart = frameN;  // exact frame index
       
       third_response_C4.setAutoDraw(true);
     }
 
     
     // *third_response_C5* updates
     if (t >= 0 && third_response_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C5.tStart = t;  // (not accounting for frame time here)
       third_response_C5.frameNStart = frameN;  // exact frame index
       
       third_response_C5.setAutoDraw(true);
     }
 
     
     // *third_response_C6* updates
     if (t >= 0 && third_response_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C6.tStart = t;  // (not accounting for frame time here)
       third_response_C6.frameNStart = frameN;  // exact frame index
       
       third_response_C6.setAutoDraw(true);
     }
 
     
     // *third_response_C7* updates
     if (t >= 0 && third_response_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C7.tStart = t;  // (not accounting for frame time here)
       third_response_C7.frameNStart = frameN;  // exact frame index
       
       third_response_C7.setAutoDraw(true);
     }
 
     
     // *third_response_C8* updates
     if (t >= 0 && third_response_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C8.tStart = t;  // (not accounting for frame time here)
       third_response_C8.frameNStart = frameN;  // exact frame index
       
       third_response_C8.setAutoDraw(true);
     }
 
     
     // *third_response_C9* updates
     if (t >= 0 && third_response_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C9.tStart = t;  // (not accounting for frame time here)
       third_response_C9.frameNStart = frameN;  // exact frame index
       
       third_response_C9.setAutoDraw(true);
     }
 
     
     // *third_response_C10* updates
     if (t >= 0 && third_response_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C10.tStart = t;  // (not accounting for frame time here)
       third_response_C10.frameNStart = frameN;  // exact frame index
       
       third_response_C10.setAutoDraw(true);
     }
 
     
     // *third_response_C11* updates
     if (t >= 0 && third_response_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C11.tStart = t;  // (not accounting for frame time here)
       third_response_C11.frameNStart = frameN;  // exact frame index
       
       third_response_C11.setAutoDraw(true);
     }
 
     
     // *third_response_C12* updates
     if (t >= 0 && third_response_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C12.tStart = t;  // (not accounting for frame time here)
       third_response_C12.frameNStart = frameN;  // exact frame index
       
       third_response_C12.setAutoDraw(true);
     }
 
     
     // *third_response_C13* updates
     if (t >= 0 && third_response_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C13.tStart = t;  // (not accounting for frame time here)
       third_response_C13.frameNStart = frameN;  // exact frame index
       
       third_response_C13.setAutoDraw(true);
     }
 
     
     // *third_response_C14* updates
     if (t >= 0 && third_response_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C14.tStart = t;  // (not accounting for frame time here)
       third_response_C14.frameNStart = frameN;  // exact frame index
       
       third_response_C14.setAutoDraw(true);
     }
 
     
     // *third_response_C15* updates
     if (t >= 0 && third_response_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C15.tStart = t;  // (not accounting for frame time here)
       third_response_C15.frameNStart = frameN;  // exact frame index
       
       third_response_C15.setAutoDraw(true);
     }
 
     
     // *third_response_C16* updates
     if (t >= 0 && third_response_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_response_C16.tStart = t;  // (not accounting for frame time here)
       third_response_C16.frameNStart = frameN;  // exact frame index
       
       third_response_C16.setAutoDraw(true);
     }
 
     // *third_mouse_response* updates
     if (t >= 0.0 && third_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       third_mouse_response.tStart = t;  // (not accounting for frame time here)
       third_mouse_response.frameNStart = frameN;  // exact frame index
       
       third_mouse_response.status = PsychoJS.Status.STARTED;
       prevButtonState = third_mouse_response.getPressed();  // if button is down already this ISN'T a new click
       }
     if (third_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = third_mouse_response.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = third_mouse_response.getPos();
           third_mouse_response.x.push(_mouseXYs[0]);
           third_mouse_response.y.push(_mouseXYs[1]);
           third_mouse_response.leftButton.push(_mouseButtons[0]);
           third_mouse_response.midButton.push(_mouseButtons[1]);
           third_mouse_response.rightButton.push(_mouseButtons[2]);
           third_mouse_response.time.push(third_mouse_response.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [third_response_C1, third_response_C2, third_response_C3, third_response_C4, third_response_C5, third_response_C6, third_response_C7, third_response_C8, third_response_C9, third_response_C10, third_response_C11, third_response_C12, third_response_C13, third_response_C14, third_response_C15, third_response_C16]) {
             if (obj.contains(third_mouse_response)) {
               gotValidClick = true;
               third_mouse_response.clicked_name.push(obj.name)
             }
           }
         }
       }
     }
     if ((circle_loop < 3)) {
         if ((practice_correct === 1)) {
             continueRoutine = false;
         }
     }
     
     if (((third_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
         clicked_frame = frameN;
         clicked_circle = eval(third_mouse_response.clicked_name[0]);
         clicked_circle.setFillColor(new util.Color([1, 1, 1]));
     }
     if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
         clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
         continueRoutine = false;
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Wait_for_Third_ResponseComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_for_Third_ResponseRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Wait_for_Third_Response'-------
     for (const thisComponent of Wait_for_Third_ResponseComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('third_mouse_response.x', third_mouse_response.x);
     psychoJS.experiment.addData('third_mouse_response.y', third_mouse_response.y);
     psychoJS.experiment.addData('third_mouse_response.leftButton', third_mouse_response.leftButton);
     psychoJS.experiment.addData('third_mouse_response.midButton', third_mouse_response.midButton);
     psychoJS.experiment.addData('third_mouse_response.rightButton', third_mouse_response.rightButton);
     psychoJS.experiment.addData('third_mouse_response.time', third_mouse_response.time);
     psychoJS.experiment.addData('third_mouse_response.clicked_name', third_mouse_response.clicked_name);
     
     /* Syntax Error: Fix Python code */
     // the Routine "Wait_for_Third_Response" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Wait_for_Fourth_ResponseComponents;
 function Wait_for_Fourth_ResponseRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Wait_for_Fourth_Response'-------
     t = 0;
     Wait_for_Fourth_ResponseClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     
     
     // setup some python lists for storing info about the fourth_mouse_response
     // current position of the mouse:
     fourth_mouse_response.x = [];
     fourth_mouse_response.y = [];
     fourth_mouse_response.leftButton = [];
     fourth_mouse_response.midButton = [];
     fourth_mouse_response.rightButton = [];
     fourth_mouse_response.time = [];
     fourth_mouse_response.clicked_name = [];
     gotValidClick = false; // until a click is received
     fourth_mouse_response.mouseClock.reset();
     clicked_frame = null;
     
     // keep track of which components have finished
     Wait_for_Fourth_ResponseComponents = [];
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C1);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C2);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C3);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C4);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C5);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C6);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C7);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C8);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C9);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C10);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C11);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C12);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C13);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C14);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C15);
     Wait_for_Fourth_ResponseComponents.push(fourth_response_C16);
     Wait_for_Fourth_ResponseComponents.push(fourth_mouse_response);
     
     for (const thisComponent of Wait_for_Fourth_ResponseComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_for_Fourth_ResponseRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Wait_for_Fourth_Response'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Wait_for_Fourth_ResponseClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     if ((circle_loop > 3)) {
         continueRoutine = true;
     } else {
         continueRoutine = false;
     }
     
     // *fourth_response_C1* updates
     if (t >= 0 && fourth_response_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C1.tStart = t;  // (not accounting for frame time here)
       fourth_response_C1.frameNStart = frameN;  // exact frame index
       
       fourth_response_C1.setAutoDraw(true);
     }
 
     
     // *fourth_response_C2* updates
     if (t >= 0 && fourth_response_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C2.tStart = t;  // (not accounting for frame time here)
       fourth_response_C2.frameNStart = frameN;  // exact frame index
       
       fourth_response_C2.setAutoDraw(true);
     }
 
     
     // *fourth_response_C3* updates
     if (t >= 0 && fourth_response_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C3.tStart = t;  // (not accounting for frame time here)
       fourth_response_C3.frameNStart = frameN;  // exact frame index
       
       fourth_response_C3.setAutoDraw(true);
     }
 
     
     // *fourth_response_C4* updates
     if (t >= 0 && fourth_response_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C4.tStart = t;  // (not accounting for frame time here)
       fourth_response_C4.frameNStart = frameN;  // exact frame index
       
       fourth_response_C4.setAutoDraw(true);
     }
 
     
     // *fourth_response_C5* updates
     if (t >= 0 && fourth_response_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C5.tStart = t;  // (not accounting for frame time here)
       fourth_response_C5.frameNStart = frameN;  // exact frame index
       
       fourth_response_C5.setAutoDraw(true);
     }
 
     
     // *fourth_response_C6* updates
     if (t >= 0 && fourth_response_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C6.tStart = t;  // (not accounting for frame time here)
       fourth_response_C6.frameNStart = frameN;  // exact frame index
       
       fourth_response_C6.setAutoDraw(true);
     }
 
     
     // *fourth_response_C7* updates
     if (t >= 0 && fourth_response_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C7.tStart = t;  // (not accounting for frame time here)
       fourth_response_C7.frameNStart = frameN;  // exact frame index
       
       fourth_response_C7.setAutoDraw(true);
     }
 
     
     // *fourth_response_C8* updates
     if (t >= 0 && fourth_response_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C8.tStart = t;  // (not accounting for frame time here)
       fourth_response_C8.frameNStart = frameN;  // exact frame index
       
       fourth_response_C8.setAutoDraw(true);
     }
 
     
     // *fourth_response_C9* updates
     if (t >= 0 && fourth_response_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C9.tStart = t;  // (not accounting for frame time here)
       fourth_response_C9.frameNStart = frameN;  // exact frame index
       
       fourth_response_C9.setAutoDraw(true);
     }
 
     
     // *fourth_response_C10* updates
     if (t >= 0 && fourth_response_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C10.tStart = t;  // (not accounting for frame time here)
       fourth_response_C10.frameNStart = frameN;  // exact frame index
       
       fourth_response_C10.setAutoDraw(true);
     }
 
     
     // *fourth_response_C11* updates
     if (t >= 0 && fourth_response_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C11.tStart = t;  // (not accounting for frame time here)
       fourth_response_C11.frameNStart = frameN;  // exact frame index
       
       fourth_response_C11.setAutoDraw(true);
     }
 
     
     // *fourth_response_C12* updates
     if (t >= 0 && fourth_response_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C12.tStart = t;  // (not accounting for frame time here)
       fourth_response_C12.frameNStart = frameN;  // exact frame index
       
       fourth_response_C12.setAutoDraw(true);
     }
 
     
     // *fourth_response_C13* updates
     if (t >= 0 && fourth_response_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C13.tStart = t;  // (not accounting for frame time here)
       fourth_response_C13.frameNStart = frameN;  // exact frame index
       
       fourth_response_C13.setAutoDraw(true);
     }
 
     
     // *fourth_response_C14* updates
     if (t >= 0 && fourth_response_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C14.tStart = t;  // (not accounting for frame time here)
       fourth_response_C14.frameNStart = frameN;  // exact frame index
       
       fourth_response_C14.setAutoDraw(true);
     }
 
     
     // *fourth_response_C15* updates
     if (t >= 0 && fourth_response_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C15.tStart = t;  // (not accounting for frame time here)
       fourth_response_C15.frameNStart = frameN;  // exact frame index
       
       fourth_response_C15.setAutoDraw(true);
     }
 
     
     // *fourth_response_C16* updates
     if (t >= 0 && fourth_response_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_response_C16.tStart = t;  // (not accounting for frame time here)
       fourth_response_C16.frameNStart = frameN;  // exact frame index
       
       fourth_response_C16.setAutoDraw(true);
     }
 
     // *fourth_mouse_response* updates
     if (t >= 0.0 && fourth_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fourth_mouse_response.tStart = t;  // (not accounting for frame time here)
       fourth_mouse_response.frameNStart = frameN;  // exact frame index
       
       fourth_mouse_response.status = PsychoJS.Status.STARTED;
       prevButtonState = fourth_mouse_response.getPressed();  // if button is down already this ISN'T a new click
       }
     if (fourth_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = fourth_mouse_response.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = fourth_mouse_response.getPos();
           fourth_mouse_response.x.push(_mouseXYs[0]);
           fourth_mouse_response.y.push(_mouseXYs[1]);
           fourth_mouse_response.leftButton.push(_mouseButtons[0]);
           fourth_mouse_response.midButton.push(_mouseButtons[1]);
           fourth_mouse_response.rightButton.push(_mouseButtons[2]);
           fourth_mouse_response.time.push(fourth_mouse_response.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [fourth_response_C1, fourth_response_C2, fourth_response_C3, fourth_response_C4, fourth_response_C5, fourth_response_C6, fourth_response_C7, fourth_response_C8, fourth_response_C9, fourth_response_C10, fourth_response_C11, fourth_response_C12, fourth_response_C13, fourth_response_C14, fourth_response_C15, fourth_response_C16]) {
             if (obj.contains(fourth_mouse_response)) {
               gotValidClick = true;
               fourth_mouse_response.clicked_name.push(obj.name)
             }
           }
         }
       }
     }
     if (((fourth_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
         clicked_frame = frameN;
         clicked_circle = eval(fourth_mouse_response.clicked_name[0]);
         clicked_circle.setFillColor(new util.Color([1, 1, 1]));
     }
     if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
         clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
         continueRoutine = false;
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Wait_for_Fourth_ResponseComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_for_Fourth_ResponseRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Wait_for_Fourth_Response'-------
     for (const thisComponent of Wait_for_Fourth_ResponseComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('fourth_mouse_response.x', fourth_mouse_response.x);
     psychoJS.experiment.addData('fourth_mouse_response.y', fourth_mouse_response.y);
     psychoJS.experiment.addData('fourth_mouse_response.leftButton', fourth_mouse_response.leftButton);
     psychoJS.experiment.addData('fourth_mouse_response.midButton', fourth_mouse_response.midButton);
     psychoJS.experiment.addData('fourth_mouse_response.rightButton', fourth_mouse_response.rightButton);
     psychoJS.experiment.addData('fourth_mouse_response.time', fourth_mouse_response.time);
     psychoJS.experiment.addData('fourth_mouse_response.clicked_name', fourth_mouse_response.clicked_name);
     
     /* Syntax Error: Fix Python code */
     // the Routine "Wait_for_Fourth_Response" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Wait_for_Fifth_ResponseComponents;
 function Wait_for_Fifth_ResponseRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Wait_for_Fifth_Response'-------
     t = 0;
     Wait_for_Fifth_ResponseClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the fifth_mouse_response
     // current position of the mouse:
     fifth_mouse_response.x = [];
     fifth_mouse_response.y = [];
     fifth_mouse_response.leftButton = [];
     fifth_mouse_response.midButton = [];
     fifth_mouse_response.rightButton = [];
     fifth_mouse_response.time = [];
     fifth_mouse_response.clicked_name = [];
     gotValidClick = false; // until a click is received
     fifth_mouse_response.mouseClock.reset();
     clicked_frame = null;
     
     // keep track of which components have finished
     Wait_for_Fifth_ResponseComponents = [];
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C1);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C2);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C3);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C4);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C5);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C6);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C7);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C8);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C9);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C10);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C11);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C12);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C13);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C14);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C15);
     Wait_for_Fifth_ResponseComponents.push(fifth_response_C16);
     Wait_for_Fifth_ResponseComponents.push(fifth_mouse_response);
     
     for (const thisComponent of Wait_for_Fifth_ResponseComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_for_Fifth_ResponseRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Wait_for_Fifth_Response'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Wait_for_Fifth_ResponseClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     if ((circle_loop > 4)) {
         continueRoutine = true;
     } else {
         continueRoutine = false;
     }
     
     
     // *fifth_response_C1* updates
     if (t >= 0 && fifth_response_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C1.tStart = t;  // (not accounting for frame time here)
       fifth_response_C1.frameNStart = frameN;  // exact frame index
       
       fifth_response_C1.setAutoDraw(true);
     }
 
     
     // *fifth_response_C2* updates
     if (t >= 0 && fifth_response_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C2.tStart = t;  // (not accounting for frame time here)
       fifth_response_C2.frameNStart = frameN;  // exact frame index
       
       fifth_response_C2.setAutoDraw(true);
     }
 
     
     // *fifth_response_C3* updates
     if (t >= 0 && fifth_response_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C3.tStart = t;  // (not accounting for frame time here)
       fifth_response_C3.frameNStart = frameN;  // exact frame index
       
       fifth_response_C3.setAutoDraw(true);
     }
 
     
     // *fifth_response_C4* updates
     if (t >= 0 && fifth_response_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C4.tStart = t;  // (not accounting for frame time here)
       fifth_response_C4.frameNStart = frameN;  // exact frame index
       
       fifth_response_C4.setAutoDraw(true);
     }
 
     
     // *fifth_response_C5* updates
     if (t >= 0 && fifth_response_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C5.tStart = t;  // (not accounting for frame time here)
       fifth_response_C5.frameNStart = frameN;  // exact frame index
       
       fifth_response_C5.setAutoDraw(true);
     }
 
     
     // *fifth_response_C6* updates
     if (t >= 0 && fifth_response_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C6.tStart = t;  // (not accounting for frame time here)
       fifth_response_C6.frameNStart = frameN;  // exact frame index
       
       fifth_response_C6.setAutoDraw(true);
     }
 
     
     // *fifth_response_C7* updates
     if (t >= 0 && fifth_response_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C7.tStart = t;  // (not accounting for frame time here)
       fifth_response_C7.frameNStart = frameN;  // exact frame index
       
       fifth_response_C7.setAutoDraw(true);
     }
 
     
     // *fifth_response_C8* updates
     if (t >= 0 && fifth_response_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C8.tStart = t;  // (not accounting for frame time here)
       fifth_response_C8.frameNStart = frameN;  // exact frame index
       
       fifth_response_C8.setAutoDraw(true);
     }
 
     
     // *fifth_response_C9* updates
     if (t >= 0 && fifth_response_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C9.tStart = t;  // (not accounting for frame time here)
       fifth_response_C9.frameNStart = frameN;  // exact frame index
       
       fifth_response_C9.setAutoDraw(true);
     }
 
     
     // *fifth_response_C10* updates
     if (t >= 0 && fifth_response_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C10.tStart = t;  // (not accounting for frame time here)
       fifth_response_C10.frameNStart = frameN;  // exact frame index
       
       fifth_response_C10.setAutoDraw(true);
     }
 
     
     // *fifth_response_C11* updates
     if (t >= 0 && fifth_response_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C11.tStart = t;  // (not accounting for frame time here)
       fifth_response_C11.frameNStart = frameN;  // exact frame index
       
       fifth_response_C11.setAutoDraw(true);
     }
 
     
     // *fifth_response_C12* updates
     if (t >= 0 && fifth_response_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C12.tStart = t;  // (not accounting for frame time here)
       fifth_response_C12.frameNStart = frameN;  // exact frame index
       
       fifth_response_C12.setAutoDraw(true);
     }
 
     
     // *fifth_response_C13* updates
     if (t >= 0 && fifth_response_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C13.tStart = t;  // (not accounting for frame time here)
       fifth_response_C13.frameNStart = frameN;  // exact frame index
       
       fifth_response_C13.setAutoDraw(true);
     }
 
     
     // *fifth_response_C14* updates
     if (t >= 0 && fifth_response_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C14.tStart = t;  // (not accounting for frame time here)
       fifth_response_C14.frameNStart = frameN;  // exact frame index
       
       fifth_response_C14.setAutoDraw(true);
     }
 
     
     // *fifth_response_C15* updates
     if (t >= 0 && fifth_response_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C15.tStart = t;  // (not accounting for frame time here)
       fifth_response_C15.frameNStart = frameN;  // exact frame index
       
       fifth_response_C15.setAutoDraw(true);
     }
 
     
     // *fifth_response_C16* updates
     if (t >= 0 && fifth_response_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_response_C16.tStart = t;  // (not accounting for frame time here)
       fifth_response_C16.frameNStart = frameN;  // exact frame index
       
       fifth_response_C16.setAutoDraw(true);
     }
 
     // *fifth_mouse_response* updates
     if (t >= 0.0 && fifth_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fifth_mouse_response.tStart = t;  // (not accounting for frame time here)
       fifth_mouse_response.frameNStart = frameN;  // exact frame index
       
       fifth_mouse_response.status = PsychoJS.Status.STARTED;
       prevButtonState = fifth_mouse_response.getPressed();  // if button is down already this ISN'T a new click
       }
     if (fifth_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = fifth_mouse_response.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = fifth_mouse_response.getPos();
           fifth_mouse_response.x.push(_mouseXYs[0]);
           fifth_mouse_response.y.push(_mouseXYs[1]);
           fifth_mouse_response.leftButton.push(_mouseButtons[0]);
           fifth_mouse_response.midButton.push(_mouseButtons[1]);
           fifth_mouse_response.rightButton.push(_mouseButtons[2]);
           fifth_mouse_response.time.push(fifth_mouse_response.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [fifth_response_C1, fifth_response_C2, fifth_response_C3, fifth_response_C4, fifth_response_C5, fifth_response_C6, fifth_response_C7, fifth_response_C8, fifth_response_C9, fifth_response_C10, fifth_response_C11, fifth_response_C12, fifth_response_C13, fifth_response_C14, fifth_response_C15, fifth_response_C16]) {
             if (obj.contains(fifth_mouse_response)) {
               gotValidClick = true;
               fifth_mouse_response.clicked_name.push(obj.name)
             }
           }
         }
       }
     }
     if (((fifth_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
         clicked_frame = frameN;
         clicked_circle = eval(fifth_mouse_response.clicked_name[0]);
         clicked_circle.setFillColor(new util.Color([1, 1, 1]));
     }
     if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
         clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
         continueRoutine = false;
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Wait_for_Fifth_ResponseComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_for_Fifth_ResponseRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Wait_for_Fifth_Response'-------
     for (const thisComponent of Wait_for_Fifth_ResponseComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('fifth_mouse_response.x', fifth_mouse_response.x);
     psychoJS.experiment.addData('fifth_mouse_response.y', fifth_mouse_response.y);
     psychoJS.experiment.addData('fifth_mouse_response.leftButton', fifth_mouse_response.leftButton);
     psychoJS.experiment.addData('fifth_mouse_response.midButton', fifth_mouse_response.midButton);
     psychoJS.experiment.addData('fifth_mouse_response.rightButton', fifth_mouse_response.rightButton);
     psychoJS.experiment.addData('fifth_mouse_response.time', fifth_mouse_response.time);
     psychoJS.experiment.addData('fifth_mouse_response.clicked_name', fifth_mouse_response.clicked_name);
     
     // the Routine "Wait_for_Fifth_Response" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Wait_For_Sixth_ResponseComponents;
 function Wait_For_Sixth_ResponseRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Wait_For_Sixth_Response'-------
     t = 0;
     Wait_For_Sixth_ResponseClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the sixth_mouse_response
     // current position of the mouse:
     sixth_mouse_response.x = [];
     sixth_mouse_response.y = [];
     sixth_mouse_response.leftButton = [];
     sixth_mouse_response.midButton = [];
     sixth_mouse_response.rightButton = [];
     sixth_mouse_response.time = [];
     sixth_mouse_response.clicked_name = [];
     gotValidClick = false; // until a click is received
     sixth_mouse_response.mouseClock.reset();
     clicked_frame = null;
     
     // keep track of which components have finished
     Wait_For_Sixth_ResponseComponents = [];
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C1);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C2);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C3);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C4);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C5);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C6);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C7);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C8);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C9);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C10);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C11);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C12);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C13);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C14);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C15);
     Wait_For_Sixth_ResponseComponents.push(sixth_response_C16);
     Wait_For_Sixth_ResponseComponents.push(sixth_mouse_response);
     
     for (const thisComponent of Wait_For_Sixth_ResponseComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_For_Sixth_ResponseRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Wait_For_Sixth_Response'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Wait_For_Sixth_ResponseClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     if ((circle_loop > 5)) {
         continueRoutine = true;
     } else {
         continueRoutine = false;
     }
     
     
     // *sixth_response_C1* updates
     if (t >= 0 && sixth_response_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C1.tStart = t;  // (not accounting for frame time here)
       sixth_response_C1.frameNStart = frameN;  // exact frame index
       
       sixth_response_C1.setAutoDraw(true);
     }
 
     
     // *sixth_response_C2* updates
     if (t >= 0 && sixth_response_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C2.tStart = t;  // (not accounting for frame time here)
       sixth_response_C2.frameNStart = frameN;  // exact frame index
       
       sixth_response_C2.setAutoDraw(true);
     }
 
     
     // *sixth_response_C3* updates
     if (t >= 0 && sixth_response_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C3.tStart = t;  // (not accounting for frame time here)
       sixth_response_C3.frameNStart = frameN;  // exact frame index
       
       sixth_response_C3.setAutoDraw(true);
     }
 
     
     // *sixth_response_C4* updates
     if (t >= 0 && sixth_response_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C4.tStart = t;  // (not accounting for frame time here)
       sixth_response_C4.frameNStart = frameN;  // exact frame index
       
       sixth_response_C4.setAutoDraw(true);
     }
 
     
     // *sixth_response_C5* updates
     if (t >= 0 && sixth_response_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C5.tStart = t;  // (not accounting for frame time here)
       sixth_response_C5.frameNStart = frameN;  // exact frame index
       
       sixth_response_C5.setAutoDraw(true);
     }
 
     
     // *sixth_response_C6* updates
     if (t >= 0 && sixth_response_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C6.tStart = t;  // (not accounting for frame time here)
       sixth_response_C6.frameNStart = frameN;  // exact frame index
       
       sixth_response_C6.setAutoDraw(true);
     }
 
     
     // *sixth_response_C7* updates
     if (t >= 0 && sixth_response_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C7.tStart = t;  // (not accounting for frame time here)
       sixth_response_C7.frameNStart = frameN;  // exact frame index
       
       sixth_response_C7.setAutoDraw(true);
     }
 
     
     // *sixth_response_C8* updates
     if (t >= 0 && sixth_response_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C8.tStart = t;  // (not accounting for frame time here)
       sixth_response_C8.frameNStart = frameN;  // exact frame index
       
       sixth_response_C8.setAutoDraw(true);
     }
 
     
     // *sixth_response_C9* updates
     if (t >= 0 && sixth_response_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C9.tStart = t;  // (not accounting for frame time here)
       sixth_response_C9.frameNStart = frameN;  // exact frame index
       
       sixth_response_C9.setAutoDraw(true);
     }
 
     
     // *sixth_response_C10* updates
     if (t >= 0 && sixth_response_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C10.tStart = t;  // (not accounting for frame time here)
       sixth_response_C10.frameNStart = frameN;  // exact frame index
       
       sixth_response_C10.setAutoDraw(true);
     }
 
     
     // *sixth_response_C11* updates
     if (t >= 0 && sixth_response_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C11.tStart = t;  // (not accounting for frame time here)
       sixth_response_C11.frameNStart = frameN;  // exact frame index
       
       sixth_response_C11.setAutoDraw(true);
     }
 
     
     // *sixth_response_C12* updates
     if (t >= 0 && sixth_response_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C12.tStart = t;  // (not accounting for frame time here)
       sixth_response_C12.frameNStart = frameN;  // exact frame index
       
       sixth_response_C12.setAutoDraw(true);
     }
 
     
     // *sixth_response_C13* updates
     if (t >= 0 && sixth_response_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C13.tStart = t;  // (not accounting for frame time here)
       sixth_response_C13.frameNStart = frameN;  // exact frame index
       
       sixth_response_C13.setAutoDraw(true);
     }
 
     
     // *sixth_response_C14* updates
     if (t >= 0 && sixth_response_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C14.tStart = t;  // (not accounting for frame time here)
       sixth_response_C14.frameNStart = frameN;  // exact frame index
       
       sixth_response_C14.setAutoDraw(true);
     }
 
     
     // *sixth_response_C15* updates
     if (t >= 0 && sixth_response_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C15.tStart = t;  // (not accounting for frame time here)
       sixth_response_C15.frameNStart = frameN;  // exact frame index
       
       sixth_response_C15.setAutoDraw(true);
     }
 
     
     // *sixth_response_C16* updates
     if (t >= 0 && sixth_response_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_response_C16.tStart = t;  // (not accounting for frame time here)
       sixth_response_C16.frameNStart = frameN;  // exact frame index
       
       sixth_response_C16.setAutoDraw(true);
     }
 
     // *sixth_mouse_response* updates
     if (t >= 0.0 && sixth_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       sixth_mouse_response.tStart = t;  // (not accounting for frame time here)
       sixth_mouse_response.frameNStart = frameN;  // exact frame index
       
       sixth_mouse_response.status = PsychoJS.Status.STARTED;
       prevButtonState = sixth_mouse_response.getPressed();  // if button is down already this ISN'T a new click
       }
     if (sixth_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = sixth_mouse_response.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = sixth_mouse_response.getPos();
           sixth_mouse_response.x.push(_mouseXYs[0]);
           sixth_mouse_response.y.push(_mouseXYs[1]);
           sixth_mouse_response.leftButton.push(_mouseButtons[0]);
           sixth_mouse_response.midButton.push(_mouseButtons[1]);
           sixth_mouse_response.rightButton.push(_mouseButtons[2]);
           sixth_mouse_response.time.push(sixth_mouse_response.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [sixth_response_C1, sixth_response_C2, sixth_response_C3, sixth_response_C4, sixth_response_C5, sixth_response_C6, sixth_response_C7, sixth_response_C8, sixth_response_C9, sixth_response_C10, sixth_response_C11, sixth_response_C12, sixth_response_C13, sixth_response_C14, sixth_response_C15, sixth_response_C16]) {
             if (obj.contains(sixth_mouse_response)) {
               gotValidClick = true;
               sixth_mouse_response.clicked_name.push(obj.name)
             }
           }
         }
       }
     }
     if (((sixth_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
         clicked_frame = frameN;
         clicked_circle = eval(sixth_mouse_response.clicked_name[0]);
         clicked_circle.setFillColor(new util.Color([1, 1, 1]));
     }
     if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
         clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
         continueRoutine = false;
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Wait_For_Sixth_ResponseComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_For_Sixth_ResponseRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Wait_For_Sixth_Response'-------
     for (const thisComponent of Wait_For_Sixth_ResponseComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('sixth_mouse_response.x', sixth_mouse_response.x);
     psychoJS.experiment.addData('sixth_mouse_response.y', sixth_mouse_response.y);
     psychoJS.experiment.addData('sixth_mouse_response.leftButton', sixth_mouse_response.leftButton);
     psychoJS.experiment.addData('sixth_mouse_response.midButton', sixth_mouse_response.midButton);
     psychoJS.experiment.addData('sixth_mouse_response.rightButton', sixth_mouse_response.rightButton);
     psychoJS.experiment.addData('sixth_mouse_response.time', sixth_mouse_response.time);
     psychoJS.experiment.addData('sixth_mouse_response.clicked_name', sixth_mouse_response.clicked_name);
     
     /* Syntax Error: Fix Python code */
     // the Routine "Wait_For_Sixth_Response" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Wait_For_Seventh_ResponseComponents;
 function Wait_For_Seventh_ResponseRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Wait_For_Seventh_Response'-------
     t = 0;
     Wait_For_Seventh_ResponseClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the seventh_mouse_response
     // current position of the mouse:
     seventh_mouse_response.x = [];
     seventh_mouse_response.y = [];
     seventh_mouse_response.leftButton = [];
     seventh_mouse_response.midButton = [];
     seventh_mouse_response.rightButton = [];
     seventh_mouse_response.time = [];
     seventh_mouse_response.clicked_name = [];
     gotValidClick = false; // until a click is received
     seventh_mouse_response.mouseClock.reset();
     clicked_frame = null;
     
     // keep track of which components have finished
     Wait_For_Seventh_ResponseComponents = [];
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C1);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C2);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C3);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C4);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C5);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C6);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C7);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C8);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C9);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C10);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C11);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C12);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C13);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C14);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C15);
     Wait_For_Seventh_ResponseComponents.push(seventh_response_C16);
     Wait_For_Seventh_ResponseComponents.push(seventh_mouse_response);
     
     for (const thisComponent of Wait_For_Seventh_ResponseComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_For_Seventh_ResponseRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Wait_For_Seventh_Response'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Wait_For_Seventh_ResponseClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     if ((circle_loop > 6)) {
         continueRoutine = true;
     } else {
         continueRoutine = false;
     }
     
     
     // *seventh_response_C1* updates
     if (t >= 0 && seventh_response_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C1.tStart = t;  // (not accounting for frame time here)
       seventh_response_C1.frameNStart = frameN;  // exact frame index
       
       seventh_response_C1.setAutoDraw(true);
     }
 
     
     // *seventh_response_C2* updates
     if (t >= 0 && seventh_response_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C2.tStart = t;  // (not accounting for frame time here)
       seventh_response_C2.frameNStart = frameN;  // exact frame index
       
       seventh_response_C2.setAutoDraw(true);
     }
 
     
     // *seventh_response_C3* updates
     if (t >= 0 && seventh_response_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C3.tStart = t;  // (not accounting for frame time here)
       seventh_response_C3.frameNStart = frameN;  // exact frame index
       
       seventh_response_C3.setAutoDraw(true);
     }
 
     
     // *seventh_response_C4* updates
     if (t >= 0 && seventh_response_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C4.tStart = t;  // (not accounting for frame time here)
       seventh_response_C4.frameNStart = frameN;  // exact frame index
       
       seventh_response_C4.setAutoDraw(true);
     }
 
     
     // *seventh_response_C5* updates
     if (t >= 0 && seventh_response_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C5.tStart = t;  // (not accounting for frame time here)
       seventh_response_C5.frameNStart = frameN;  // exact frame index
       
       seventh_response_C5.setAutoDraw(true);
     }
 
     
     // *seventh_response_C6* updates
     if (t >= 0 && seventh_response_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C6.tStart = t;  // (not accounting for frame time here)
       seventh_response_C6.frameNStart = frameN;  // exact frame index
       
       seventh_response_C6.setAutoDraw(true);
     }
 
     
     // *seventh_response_C7* updates
     if (t >= 0 && seventh_response_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C7.tStart = t;  // (not accounting for frame time here)
       seventh_response_C7.frameNStart = frameN;  // exact frame index
       
       seventh_response_C7.setAutoDraw(true);
     }
 
     
     // *seventh_response_C8* updates
     if (t >= 0 && seventh_response_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C8.tStart = t;  // (not accounting for frame time here)
       seventh_response_C8.frameNStart = frameN;  // exact frame index
       
       seventh_response_C8.setAutoDraw(true);
     }
 
     
     // *seventh_response_C9* updates
     if (t >= 0 && seventh_response_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C9.tStart = t;  // (not accounting for frame time here)
       seventh_response_C9.frameNStart = frameN;  // exact frame index
       
       seventh_response_C9.setAutoDraw(true);
     }
 
     
     // *seventh_response_C10* updates
     if (t >= 0 && seventh_response_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C10.tStart = t;  // (not accounting for frame time here)
       seventh_response_C10.frameNStart = frameN;  // exact frame index
       
       seventh_response_C10.setAutoDraw(true);
     }
 
     
     // *seventh_response_C11* updates
     if (t >= 0 && seventh_response_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C11.tStart = t;  // (not accounting for frame time here)
       seventh_response_C11.frameNStart = frameN;  // exact frame index
       
       seventh_response_C11.setAutoDraw(true);
     }
 
     
     // *seventh_response_C12* updates
     if (t >= 0 && seventh_response_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C12.tStart = t;  // (not accounting for frame time here)
       seventh_response_C12.frameNStart = frameN;  // exact frame index
       
       seventh_response_C12.setAutoDraw(true);
     }
 
     
     // *seventh_response_C13* updates
     if (t >= 0 && seventh_response_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C13.tStart = t;  // (not accounting for frame time here)
       seventh_response_C13.frameNStart = frameN;  // exact frame index
       
       seventh_response_C13.setAutoDraw(true);
     }
 
     
     // *seventh_response_C14* updates
     if (t >= 0 && seventh_response_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C14.tStart = t;  // (not accounting for frame time here)
       seventh_response_C14.frameNStart = frameN;  // exact frame index
       
       seventh_response_C14.setAutoDraw(true);
     }
 
     
     // *seventh_response_C15* updates
     if (t >= 0 && seventh_response_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C15.tStart = t;  // (not accounting for frame time here)
       seventh_response_C15.frameNStart = frameN;  // exact frame index
       
       seventh_response_C15.setAutoDraw(true);
     }
 
     
     // *seventh_response_C16* updates
     if (t >= 0 && seventh_response_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_response_C16.tStart = t;  // (not accounting for frame time here)
       seventh_response_C16.frameNStart = frameN;  // exact frame index
       
       seventh_response_C16.setAutoDraw(true);
     }
 
     // *seventh_mouse_response* updates
     if (t >= 0.0 && seventh_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       seventh_mouse_response.tStart = t;  // (not accounting for frame time here)
       seventh_mouse_response.frameNStart = frameN;  // exact frame index
       
       seventh_mouse_response.status = PsychoJS.Status.STARTED;
       prevButtonState = seventh_mouse_response.getPressed();  // if button is down already this ISN'T a new click
       }
     if (seventh_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = seventh_mouse_response.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = seventh_mouse_response.getPos();
           seventh_mouse_response.x.push(_mouseXYs[0]);
           seventh_mouse_response.y.push(_mouseXYs[1]);
           seventh_mouse_response.leftButton.push(_mouseButtons[0]);
           seventh_mouse_response.midButton.push(_mouseButtons[1]);
           seventh_mouse_response.rightButton.push(_mouseButtons[2]);
           seventh_mouse_response.time.push(seventh_mouse_response.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [seventh_response_C1, seventh_response_C2, seventh_response_C3, seventh_response_C4, seventh_response_C5, seventh_response_C6, seventh_response_C7, seventh_response_C8, seventh_response_C9, seventh_response_C10, seventh_response_C11, seventh_response_C12, seventh_response_C13, seventh_response_C14, seventh_response_C15, seventh_response_C16]) {
             if (obj.contains(seventh_mouse_response)) {
               gotValidClick = true;
               seventh_mouse_response.clicked_name.push(obj.name)
             }
           }
         }
       }
     }
     if (((seventh_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
         clicked_frame = frameN;
         clicked_circle = eval(seventh_mouse_response.clicked_name[0]);
         clicked_circle.setFillColor(new util.Color([1, 1, 1]));
     }
     if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
         clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
         continueRoutine = false;
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Wait_For_Seventh_ResponseComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_For_Seventh_ResponseRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Wait_For_Seventh_Response'-------
     for (const thisComponent of Wait_For_Seventh_ResponseComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('seventh_mouse_response.x', seventh_mouse_response.x);
     psychoJS.experiment.addData('seventh_mouse_response.y', seventh_mouse_response.y);
     psychoJS.experiment.addData('seventh_mouse_response.leftButton', seventh_mouse_response.leftButton);
     psychoJS.experiment.addData('seventh_mouse_response.midButton', seventh_mouse_response.midButton);
     psychoJS.experiment.addData('seventh_mouse_response.rightButton', seventh_mouse_response.rightButton);
     psychoJS.experiment.addData('seventh_mouse_response.time', seventh_mouse_response.time);
     psychoJS.experiment.addData('seventh_mouse_response.clicked_name', seventh_mouse_response.clicked_name);
     
     /* Syntax Error: Fix Python code */
     // the Routine "Wait_For_Seventh_Response" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Wait_For_Eighth_ResponseComponents;
 function Wait_For_Eighth_ResponseRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Wait_For_Eighth_Response'-------
     t = 0;
     Wait_For_Eighth_ResponseClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the eighth_mouse_response
     // current position of the mouse:
     eighth_mouse_response.x = [];
     eighth_mouse_response.y = [];
     eighth_mouse_response.leftButton = [];
     eighth_mouse_response.midButton = [];
     eighth_mouse_response.rightButton = [];
     eighth_mouse_response.time = [];
     eighth_mouse_response.clicked_name = [];
     gotValidClick = false; // until a click is received
     eighth_mouse_response.mouseClock.reset();
     clicked_frame = null;
     
     // keep track of which components have finished
     Wait_For_Eighth_ResponseComponents = [];
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C1);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C2);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C3);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C4);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C5);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C6);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C7);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C8);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C9);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C10);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C11);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C12);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C13);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C14);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C15);
     Wait_For_Eighth_ResponseComponents.push(eighth_response_C16);
     Wait_For_Eighth_ResponseComponents.push(eighth_mouse_response);
     
     for (const thisComponent of Wait_For_Eighth_ResponseComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_For_Eighth_ResponseRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Wait_For_Eighth_Response'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Wait_For_Eighth_ResponseClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     if ((circle_loop > 7)) {
         continueRoutine = true;
     } else {
         continueRoutine = false;
     }
     
     
     // *eighth_response_C1* updates
     if (t >= 0 && eighth_response_C1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C1.tStart = t;  // (not accounting for frame time here)
       eighth_response_C1.frameNStart = frameN;  // exact frame index
       
       eighth_response_C1.setAutoDraw(true);
     }
 
     
     // *eighth_response_C2* updates
     if (t >= 0 && eighth_response_C2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C2.tStart = t;  // (not accounting for frame time here)
       eighth_response_C2.frameNStart = frameN;  // exact frame index
       
       eighth_response_C2.setAutoDraw(true);
     }
 
     
     // *eighth_response_C3* updates
     if (t >= 0 && eighth_response_C3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C3.tStart = t;  // (not accounting for frame time here)
       eighth_response_C3.frameNStart = frameN;  // exact frame index
       
       eighth_response_C3.setAutoDraw(true);
     }
 
     
     // *eighth_response_C4* updates
     if (t >= 0 && eighth_response_C4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C4.tStart = t;  // (not accounting for frame time here)
       eighth_response_C4.frameNStart = frameN;  // exact frame index
       
       eighth_response_C4.setAutoDraw(true);
     }
 
     
     // *eighth_response_C5* updates
     if (t >= 0 && eighth_response_C5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C5.tStart = t;  // (not accounting for frame time here)
       eighth_response_C5.frameNStart = frameN;  // exact frame index
       
       eighth_response_C5.setAutoDraw(true);
     }
 
     
     // *eighth_response_C6* updates
     if (t >= 0 && eighth_response_C6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C6.tStart = t;  // (not accounting for frame time here)
       eighth_response_C6.frameNStart = frameN;  // exact frame index
       
       eighth_response_C6.setAutoDraw(true);
     }
 
     
     // *eighth_response_C7* updates
     if (t >= 0 && eighth_response_C7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C7.tStart = t;  // (not accounting for frame time here)
       eighth_response_C7.frameNStart = frameN;  // exact frame index
       
       eighth_response_C7.setAutoDraw(true);
     }
 
     
     // *eighth_response_C8* updates
     if (t >= 0 && eighth_response_C8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C8.tStart = t;  // (not accounting for frame time here)
       eighth_response_C8.frameNStart = frameN;  // exact frame index
       
       eighth_response_C8.setAutoDraw(true);
     }
 
     
     // *eighth_response_C9* updates
     if (t >= 0 && eighth_response_C9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C9.tStart = t;  // (not accounting for frame time here)
       eighth_response_C9.frameNStart = frameN;  // exact frame index
       
       eighth_response_C9.setAutoDraw(true);
     }
 
     
     // *eighth_response_C10* updates
     if (t >= 0 && eighth_response_C10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C10.tStart = t;  // (not accounting for frame time here)
       eighth_response_C10.frameNStart = frameN;  // exact frame index
       
       eighth_response_C10.setAutoDraw(true);
     }
 
     
     // *eighth_response_C11* updates
     if (t >= 0 && eighth_response_C11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C11.tStart = t;  // (not accounting for frame time here)
       eighth_response_C11.frameNStart = frameN;  // exact frame index
       
       eighth_response_C11.setAutoDraw(true);
     }
 
     
     // *eighth_response_C12* updates
     if (t >= 0 && eighth_response_C12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C12.tStart = t;  // (not accounting for frame time here)
       eighth_response_C12.frameNStart = frameN;  // exact frame index
       
       eighth_response_C12.setAutoDraw(true);
     }
 
     
     // *eighth_response_C13* updates
     if (t >= 0 && eighth_response_C13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C13.tStart = t;  // (not accounting for frame time here)
       eighth_response_C13.frameNStart = frameN;  // exact frame index
       
       eighth_response_C13.setAutoDraw(true);
     }
 
     
     // *eighth_response_C14* updates
     if (t >= 0 && eighth_response_C14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C14.tStart = t;  // (not accounting for frame time here)
       eighth_response_C14.frameNStart = frameN;  // exact frame index
       
       eighth_response_C14.setAutoDraw(true);
     }
 
     
     // *eighth_response_C15* updates
     if (t >= 0 && eighth_response_C15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C15.tStart = t;  // (not accounting for frame time here)
       eighth_response_C15.frameNStart = frameN;  // exact frame index
       
       eighth_response_C15.setAutoDraw(true);
     }
 
     
     // *eighth_response_C16* updates
     if (t >= 0 && eighth_response_C16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_response_C16.tStart = t;  // (not accounting for frame time here)
       eighth_response_C16.frameNStart = frameN;  // exact frame index
       
       eighth_response_C16.setAutoDraw(true);
     }
 
     // *eighth_mouse_response* updates
     if (t >= 0.0 && eighth_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       eighth_mouse_response.tStart = t;  // (not accounting for frame time here)
       eighth_mouse_response.frameNStart = frameN;  // exact frame index
       
       eighth_mouse_response.status = PsychoJS.Status.STARTED;
       prevButtonState = eighth_mouse_response.getPressed();  // if button is down already this ISN'T a new click
       }
     if (eighth_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = eighth_mouse_response.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = eighth_mouse_response.getPos();
           eighth_mouse_response.x.push(_mouseXYs[0]);
           eighth_mouse_response.y.push(_mouseXYs[1]);
           eighth_mouse_response.leftButton.push(_mouseButtons[0]);
           eighth_mouse_response.midButton.push(_mouseButtons[1]);
           eighth_mouse_response.rightButton.push(_mouseButtons[2]);
           eighth_mouse_response.time.push(eighth_mouse_response.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [eighth_response_C1, eighth_response_C2, eighth_response_C3, eighth_response_C4, eighth_response_C5, eighth_response_C6, eighth_response_C7, eighth_response_C8, eighth_response_C9, eighth_response_C10, eighth_response_C11, eighth_response_C12, eighth_response_C13, eighth_response_C14, eighth_response_C15, eighth_response_C16]) {
             if (obj.contains(eighth_mouse_response)) {
               gotValidClick = true;
               eighth_mouse_response.clicked_name.push(obj.name)
             }
           }
         }
       }
     }
     if (((eighth_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
         clicked_frame = frameN;
         clicked_circle = eval(eighth_mouse_response.clicked_name[0]);
         clicked_circle.setFillColor(new util.Color([1, 1, 1]));
     }
     if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
         clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
         continueRoutine = false;
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Wait_For_Eighth_ResponseComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Wait_For_Eighth_ResponseRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Wait_For_Eighth_Response'-------
     for (const thisComponent of Wait_For_Eighth_ResponseComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('eighth_mouse_response.x', eighth_mouse_response.x);
     psychoJS.experiment.addData('eighth_mouse_response.y', eighth_mouse_response.y);
     psychoJS.experiment.addData('eighth_mouse_response.leftButton', eighth_mouse_response.leftButton);
     psychoJS.experiment.addData('eighth_mouse_response.midButton', eighth_mouse_response.midButton);
     psychoJS.experiment.addData('eighth_mouse_response.rightButton', eighth_mouse_response.rightButton);
     psychoJS.experiment.addData('eighth_mouse_response.time', eighth_mouse_response.time);
     psychoJS.experiment.addData('eighth_mouse_response.clicked_name', eighth_mouse_response.clicked_name);
     
     /* Syntax Error: Fix Python code */
     // the Routine "Wait_For_Eighth_Response" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Check_outcomeComponents;
 function Check_outcomeRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Check_outcome'-------
     t = 0;
     Check_outcomeClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     corr = 0;
     trial_counter = (trial_counter + 1);
     if ((circle_loop === 3)) {
         if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
             if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                 if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                     trials_correct = (trials_correct + 1);
                 }
             }
         }
     }
     if ((circle_loop === 4)) {
         if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
             if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                 if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                     if ((fourth_mouse_response.clicked_name[0] === Correct_response_circle4)) {
                         trials_correct = (trials_correct + 1);
                     }
                 }
             }
         }
     }
     if ((circle_loop === 5)) {
         if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
             if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                 if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                     if ((fourth_mouse_response.clicked_name[0] === Correct_response_circle4)) {
                         if ((fifth_mouse_response.clicked_name[0] === Correct_response_circle5)) {
                             trials_correct = (trials_correct + 1);
                         }
                     }
                 }
             }
         }
     }
     if ((circle_loop === 6)) {
         if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
             if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                 if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                     if ((fourth_mouse_response.clicked_name[0] === Correct_response_circle4)) {
                         if ((fifth_mouse_response.clicked_name[0] === Correct_response_circle5)) {
                             if ((sixth_mouse_response.clicked_name[0] === Correct_response_circle6)) {
                                 trials_correct = (trials_correct + 1);
                             }
                         }
                     }
                 }
             }
         }
     }
     if ((circle_loop === 7)) {
         if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
             if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                 if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                     if ((fourth_mouse_response.clicked_name[0] === Correct_response_circle4)) {
                         if ((fifth_mouse_response.clicked_name[0] === Correct_response_circle5)) {
                             if ((sixth_mouse_response.clicked_name[0] === Correct_response_circle6)) {
                                 if ((seventh_mouse_response.clicked_name[0] === Correct_response_circle7)) {
                                     trials_correct = (trials_correct + 1);
                                 }
                             }
                         }
                     }
                 }
             }
         }
     }
     if ((circle_loop === 8)) {
         if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
             if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                 if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                     if ((fourth_mouse_response.clicked_name[0] === Correct_response_circle4)) {
                         if ((fifth_mouse_response.clicked_name[0] === Correct_response_circle5)) {
                             if ((sixth_mouse_response.clicked_name[0] === Correct_response_circle6)) {
                                 if ((seventh_mouse_response.clicked_name[0] === Correct_response_circle7)) {
                                     if ((eighth_mouse_response.clicked_name[0] === Correct_response_circle8)) {
                                         trials_correct = (trials_correct + 1);
                                     }
                                 }
                             }
                         }
                     }
                 }
             }
         }
     }
     if ((circle_loop > 2)) {
         if (((trial_counter === 2) && (trials_correct === 2))) {
             Circle_Blocks.finished = true;
         }
         if (((trial_counter === 2) && (trials_correct === 0))) {
             end_experiment = 1;
             Circle_Blocks.finished = true;
         }
         if (((trial_counter === 3) && (trials_correct === 1))) {
             end_experiment = 1;
             Circle_Blocks.finished = true;
         }
         if (((trial_counter === 3) && (trials_correct > 1))) {
             Circle_Blocks.finished = true;
         }
     }
     
     console.log(trials_correct)
     console.log(trial_counter)
     
     
     // keep track of which components have finished
     Check_outcomeComponents = [];
     
     for (const thisComponent of Check_outcomeComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Check_outcomeRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Check_outcome'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Check_outcomeClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     if ((circle_loop < 3)) {
         if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
             if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                 if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                     corr = 1;
                 }
             }
         }
     } else {
         corr = 0;
         }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Check_outcomeComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Check_outcomeRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Check_outcome'-------
     for (const thisComponent of Check_outcomeComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     console.log(corr)
     console.log(circle_loop)
     if ((corr === 1)) {
         msg = "Correct!";
     } else {
         msg = "Incorrect";
         }
     
     console.log(msg)
     
     if ((circle_loop < 3)) {
         if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
             if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                 if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                     trials_correct = (trials_correct + 1);
                 }
             }
         }
     }
     
     console.log(trials_correct)
     
     if ((circle_loop === 2)) {
         if ((trial_counter === 2) && (trials_correct === 2)) {
             Circle_Blocks.finished = true;
         }
         if ((trial_counter === 4)) {
             Circle_Blocks.finished = true;
         }
     }
     
     // the Routine "Check_outcome" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Blank_ScreenComponents;
 function Blank_ScreenRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Blank_Screen'-------
     t = 0;
     Blank_ScreenClock.reset(); // clock
     frameN = -1;
     routineTimer.add(0.500000);
     // update component parameters for each repeat
     // keep track of which components have finished
     Blank_ScreenComponents = [];
     Blank_ScreenComponents.push(text);
     
     for (const thisComponent of Blank_ScreenComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Blank_ScreenRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Blank_Screen'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Blank_ScreenClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *text* updates
     if (t >= 0.0 && text.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text.tStart = t;  // (not accounting for frame time here)
       text.frameNStart = frameN;  // exact frame index
       
       text.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text.status === PsychoJS.Status.STARTED || text.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Blank_ScreenComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Blank_ScreenRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Blank_Screen'-------
     for (const thisComponent of Blank_ScreenComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var feedbackComponents;
 function feedbackRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'feedback'-------
     t = 0;
     feedbackClock.reset(); // clock
     frameN = -1;
     routineTimer.add(1.000000);
     // update component parameters for each repeat
     text_4.setText(msg);
     // keep track of which components have finished
     feedbackComponents = [];
     feedbackComponents.push(text_4);
     
     for (const thisComponent of feedbackComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedbackRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'feedback'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = feedbackClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *text_4* updates
     if (t >= 0.0 && text_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_4.tStart = t;  // (not accounting for frame time here)
       text_4.frameNStart = frameN;  // exact frame index
       
       text_4.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_4.status === PsychoJS.Status.STARTED || text_4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_4.setAutoDraw(false);
     }
     if ((circle_loop < 3)) {
         continueRoutine = true;
     } else {
         continueRoutine = false;
     }
     
     if ((circle_loop < 3)) {
         if ((practice_correct === 1)) {
             continueRoutine = false;
         }
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of feedbackComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedbackRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'feedback'-------
     for (const thisComponent of feedbackComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_allKeys;
 var Repeat_InstructionsComponents;
 function Repeat_InstructionsRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Repeat_Instructions'-------
     t = 0;
     Repeat_InstructionsClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp.keys = undefined;
     key_resp.rt = undefined;
     _key_resp_allKeys = [];
     // keep track of which components have finished
     Repeat_InstructionsComponents = [];
     Repeat_InstructionsComponents.push(repeat_inst);
     Repeat_InstructionsComponents.push(key_resp);
     Repeat_InstructionsComponents.push(text_5);
     
     for (const thisComponent of Repeat_InstructionsComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Repeat_InstructionsRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Repeat_Instructions'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Repeat_InstructionsClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *repeat_inst* updates
     if (t >= 0.0 && repeat_inst.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       repeat_inst.tStart = t;  // (not accounting for frame time here)
       repeat_inst.frameNStart = frameN;  // exact frame index
       
       repeat_inst.setAutoDraw(true);
     }
 
     console.log(trials_correct)
     console.log(trial_counter)
     if ((circle_loop < 3)) {
         if ((trial_counter < 2)) {
             continueRoutine = false;
         } else if ((trial_counter === 2)) {
             if (trials_correct ===2){
                 continueRoutine = false;
                 practice_correct = 1;
                 }
             else {
                 continueRoutine = true;
                 }
         } else if ((trial_counter === 3)) {
             continueRoutine = false;
         } else if ((trial_counter === 4) && (trials_correct > 2)) {
             continueRoutine = false;
         } else {
             continueRoutine = false;
             } 
     }else {
         continueRoutine = false;
     }
     
     if ((circle_loop < 3)) {
         if ((practice_correct === 1)) {
             continueRoutine = false;
         }
     }
     
     console.log(practice_correct);
     
     // *key_resp* updates
     if (t >= 0.0 && key_resp.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp.tStart = t;  // (not accounting for frame time here)
       key_resp.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp.clearEvents(); });
     }
 
     if (key_resp.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_allKeys = _key_resp_allKeys.concat(theseKeys);
       if (_key_resp_allKeys.length > 0) {
         key_resp.keys = _key_resp_allKeys[_key_resp_allKeys.length - 1].name;  // just the last key pressed
         key_resp.rt = _key_resp_allKeys[_key_resp_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_5* updates
     if (t >= 0.0 && text_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_5.tStart = t;  // (not accounting for frame time here)
       text_5.frameNStart = frameN;  // exact frame index
       
       text_5.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Repeat_InstructionsComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Repeat_InstructionsRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Repeat_Instructions'-------
     for (const thisComponent of Repeat_InstructionsComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp.keys', key_resp.keys);
     if (typeof key_resp.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp.rt', key_resp.rt);
         routineTimer.reset();
         }
     
     key_resp.stop();
     // the Routine "Repeat_Instructions" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var check_end_experimentComponents;
 function check_end_experimentRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'check_end_experiment'-------
     t = 0;
     check_end_experimentClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     if ((end_experiment === 1)) {
         Meta_Loop.finished = true;
     }
     
     // keep track of which components have finished
     check_end_experimentComponents = [];
     
     for (const thisComponent of check_end_experimentComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function check_end_experimentRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'check_end_experiment'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = check_end_experimentClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of check_end_experimentComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function check_end_experimentRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'check_end_experiment'-------
     for (const thisComponent of check_end_experimentComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // the Routine "check_end_experiment" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Get_ExperimenterComponents;
 function Get_ExperimenterRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Get_Experimenter'-------
     t = 0;
     Get_ExperimenterClock.reset(); // clock
     frameN = -1;
     routineTimer.add(2.000000);
     // update component parameters for each repeat
     // keep track of which components have finished
     Get_ExperimenterComponents = [];
     Get_ExperimenterComponents.push(text_11);
     Get_ExperimenterComponents.push(b_text_15);
     
     for (const thisComponent of Get_ExperimenterComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Get_ExperimenterRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Get_Experimenter'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Get_ExperimenterClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *text_11* updates
     if (t >= 0.0 && text_11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_11.tStart = t;  // (not accounting for frame time here)
       text_11.frameNStart = frameN;  // exact frame index
       
       text_11.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_11.status === PsychoJS.Status.STARTED || text_11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_11.setAutoDraw(false);
     }
     
     // *b_text_15* updates
     if (t >= 0.0 && b_text_15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       b_text_15.tStart = t;  // (not accounting for frame time here)
       b_text_15.frameNStart = frameN;  // exact frame index
       
       b_text_15.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((b_text_15.status === PsychoJS.Status.STARTED || b_text_15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       b_text_15.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Get_ExperimenterComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Get_ExperimenterRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Get_Experimenter'-------
     for (const thisComponent of Get_ExperimenterComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_2_allKeys;
 var InstructionsComponents;
 function InstructionsRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Instructions'-------
     t = 0;
     InstructionsClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_2.keys = undefined;
     key_resp_2.rt = undefined;
     _key_resp_2_allKeys = [];
     // keep track of which components have finished
     InstructionsComponents = [];
     InstructionsComponents.push(instructions);
     InstructionsComponents.push(key_resp_2);
     
     for (const thisComponent of InstructionsComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function InstructionsRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Instructions'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = InstructionsClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *instructions* updates
     if (t >= 0.0 && instructions.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       instructions.tStart = t;  // (not accounting for frame time here)
       instructions.frameNStart = frameN;  // exact frame index
       
       instructions.setAutoDraw(true);
     }
 
     
     // *key_resp_2* updates
     if (t >= 0.0 && key_resp_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_2.tStart = t;  // (not accounting for frame time here)
       key_resp_2.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_2.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_2.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_2.clearEvents(); });
     }
 
     if (key_resp_2.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_2.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_2_allKeys = _key_resp_2_allKeys.concat(theseKeys);
       if (_key_resp_2_allKeys.length > 0) {
         key_resp_2.keys = _key_resp_2_allKeys[_key_resp_2_allKeys.length - 1].name;  // just the last key pressed
         key_resp_2.rt = _key_resp_2_allKeys[_key_resp_2_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of InstructionsComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function InstructionsRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Instructions'-------
     for (const thisComponent of InstructionsComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_2.keys', key_resp_2.keys);
     if (typeof key_resp_2.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_2.rt', key_resp_2.rt);
         routineTimer.reset();
         }
     
     key_resp_2.stop();
     // the Routine "Instructions" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_3_allKeys;
 var get_readyComponents;
 function get_readyRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'get_ready'-------
     t = 0;
     get_readyClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_3.keys = undefined;
     key_resp_3.rt = undefined;
     _key_resp_3_allKeys = [];
     // keep track of which components have finished
     get_readyComponents = [];
     get_readyComponents.push(text_6);
     get_readyComponents.push(key_resp_3);
     get_readyComponents.push(text_7);
     
     for (const thisComponent of get_readyComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function get_readyRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'get_ready'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = get_readyClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *text_6* updates
     if (t >= 0.0 && text_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_6.tStart = t;  // (not accounting for frame time here)
       text_6.frameNStart = frameN;  // exact frame index
       
       text_6.setAutoDraw(true);
     }
 
     
     // *key_resp_3* updates
     if (t >= 0.0 && key_resp_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_3.tStart = t;  // (not accounting for frame time here)
       key_resp_3.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_3.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_3.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_3.clearEvents(); });
     }
 
     if (key_resp_3.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_3.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_3_allKeys = _key_resp_3_allKeys.concat(theseKeys);
       if (_key_resp_3_allKeys.length > 0) {
         key_resp_3.keys = _key_resp_3_allKeys[_key_resp_3_allKeys.length - 1].name;  // just the last key pressed
         key_resp_3.rt = _key_resp_3_allKeys[_key_resp_3_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_7* updates
     if (t >= 0.0 && text_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_7.tStart = t;  // (not accounting for frame time here)
       text_7.frameNStart = frameN;  // exact frame index
       
       text_7.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of get_readyComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function get_readyRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'get_ready'-------
     for (const thisComponent of get_readyComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_3.keys', key_resp_3.keys);
     if (typeof key_resp_3.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_3.rt', key_resp_3.rt);
         routineTimer.reset();
         }
     
     key_resp_3.stop();
     // the Routine "get_ready" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var code_metaComponents;
 function code_metaRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'code_meta'-------
     t = 0;
     code_metaClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // keep track of which components have finished
     code_metaComponents = [];
     
     for (const thisComponent of code_metaComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function code_metaRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'code_meta'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = code_metaClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of code_metaComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function code_metaRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'code_meta'-------
     for (const thisComponent of code_metaComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // the Routine "code_meta" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var nList;
 var Presentation_practiceComponents;
 function Presentation_practiceRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Presentation_practice'-------
     t = 0;
     Presentation_practiceClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // Convert sequence to list
     var output = [],
         sNumber = digits.toString();
     
     for (var i = 0, len = sNumber.length; i < len; i += 1) {
         output.push(+sNumber.charAt(i));
     }
     
     nList = digits.toString().split('').map((i)=>Number(i))
     // keep track of which components have finished
     Presentation_practiceComponents = [];
     Presentation_practiceComponents.push(fixation_2);
     Presentation_practiceComponents.push(pres_text_2);
     
     for (const thisComponent of Presentation_practiceComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 var i;
 function Presentation_practiceRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Presentation_practice'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Presentation_practiceClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *fixation_2* updates
     if (t >= 0.0 && fixation_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixation_2.tStart = t;  // (not accounting for frame time here)
       fixation_2.frameNStart = frameN;  // exact frame index
       
       fixation_2.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fixation_2.status === PsychoJS.Status.STARTED || fixation_2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fixation_2.setAutoDraw(false);
     }
     
     // *pres_text_2* updates
     if (t >= 1 && pres_text_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pres_text_2.tStart = t;  // (not accounting for frame time here)
       pres_text_2.frameNStart = frameN;  // exact frame index
       
       pres_text_2.setAutoDraw(true);
     }
 
     // Convert time ti a list index
     i = Math.floor(t-1);
     // console.log(i)
     // console.log(nList.length)
     // console.log(fixation_2)
     // console.log(pres_text_2.text)
     // pres_text_2.text = 'a'
     // console.log(pres_text_2.text)
     
     // Index current number in the list
     // or end routine if all numbers presented
     if (i === nList.length) {
         continueRoutine = false;
     } else if (i < 0){
         pres_text_2.text = ' '
     } else {
         console.log(pres_text_2.text)
         pres_text_2.text = nList[i]
     }
     
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Presentation_practiceComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Presentation_practiceRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Presentation_practice'-------
     for (const thisComponent of Presentation_practiceComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // the Routine "Presentation_practice" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_4_allKeys;
 var n;
 var modify;
 var textAdd;
 var Recall_practiceComponents;
 function Recall_practiceRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Recall_practice'-------
     t = 0;
     Recall_practiceClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_4.keys = undefined;
     key_resp_4.rt = undefined;
     _key_resp_4_allKeys = [];
     n = 0;
     modify = false;
     textAdd = '';
     pts_response_2.text = '';
     current_resp = '';
     console.log(pts_response_2.text)
     console.log(current_resp)
     if (pts_response_2.text === 'space'){
         pts_response_2.text = '';
         }
     // keep track of which components have finished
     Recall_practiceComponents = [];
     Recall_practiceComponents.push(recall_text_2);
     Recall_practiceComponents.push(key_resp_4);
     Recall_practiceComponents.push(pts_response_2);
     
     for (const thisComponent of Recall_practiceComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Recall_practiceRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Recall_practice'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Recall_practiceClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *recall_text_2* updates
     if (t >= 0 && recall_text_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       recall_text_2.tStart = t;  // (not accounting for frame time here)
       recall_text_2.frameNStart = frameN;  // exact frame index
       
       recall_text_2.setAutoDraw(true);
     }
 
     
     // *key_resp_4* updates
     if (t >= 0 && key_resp_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_4.tStart = t;  // (not accounting for frame time here)
       key_resp_4.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_4.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_4.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_4.clearEvents(); });
     }
 
     if (key_resp_4.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_4.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'return', 'backspace'], waitRelease: false});
       _key_resp_4_allKeys = _key_resp_4_allKeys.concat(theseKeys);
       if (_key_resp_4_allKeys.length > 0) {
         key_resp_4.keys = _key_resp_4_allKeys.map((key) => key.name);  // storing all keys
         key_resp_4.rt = _key_resp_4_allKeys.map((key) => key.rt);
       }
     }
     
     console.log(current_resp)
     console.log(pts_response_2.text)
     console.log(n)
     
     
     let theseKeys = psychoJS.eventManager.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'return'], waitRelease: false});
     if (theseKeys.length > 0) {  // at least one key was pressed
       textAdd = theseKeys[theseKeys.length-1]; 
       }
     
     if (n < 1){
         textAdd = ''
     }
     
     
     if (textAdd === 'return') {
         textAdd = '';  // Add nothing
         continueRoutine = false;  // End routine (if that is what you want)
     } else if (textAdd === 'backspace') {
         pts_response_2.text = pts_response_2.text.slice(0, -1);
         textAdd = undefined;
     } else if (['lshift', 'rshift'].includes(textAdd)) {
             modify = true;
     } else if (textAdd !== undefined) {
         if (modify) {
             pts_response_2.text = pts_response_2.text + textAdd.toUpperCase();
             modify = false;
         } else {
             pts_response_2.text = pts_response_2.text + textAdd
         }
         textAdd = undefined;
     }
      
     
     current_resp = pts_response_2.text
     n = n + 1
     console.log(n)
     
     // *pts_response_2* updates
     if (t >= 0 && pts_response_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pts_response_2.tStart = t;  // (not accounting for frame time here)
       pts_response_2.frameNStart = frameN;  // exact frame index
       
       pts_response_2.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Recall_practiceComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 var correct;
 function Recall_practiceRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Recall_practice'-------
     for (const thisComponent of Recall_practiceComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_4.keys', key_resp_4.keys);
     if (typeof key_resp_4.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_4.rt', key_resp_4.rt);
         }
     
     key_resp_4.stop();
     correct = 0;
     
     if (Number(current_resp) === digits_corr) {
         correct = 1;
         msg = "Correct";
         psychoJS.experiment.addData("correct", correct)
     } else {
         msg = "Incorrect";
         psychoJS.experiment.addData("Incorrect", correct)
     }
     psychoJS.experiment.addData("response", current_resp);
     
     allResponses_p.push(correct)
     pts_response_2.text = '';
     
     console.log(allResponses_p)
     // the Routine "Recall_practice" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var feedback_practiceComponents;
 function feedback_practiceRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'feedback_practice'-------
     t = 0;
     feedback_practiceClock.reset(); // clock
     frameN = -1;
     routineTimer.add(1.000000);
     // update component parameters for each repeat
     text_8.setText(msg);
     // keep track of which components have finished
     feedback_practiceComponents = [];
     feedback_practiceComponents.push(text_8);
     
     for (const thisComponent of feedback_practiceComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_practiceRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'feedback_practice'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = feedback_practiceClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *text_8* updates
     if (t >= 0.0 && text_8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_8.tStart = t;  // (not accounting for frame time here)
       text_8.frameNStart = frameN;  // exact frame index
       
       text_8.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_8.status === PsychoJS.Status.STARTED || text_8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_8.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of feedback_practiceComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_practiceRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'feedback_practice'-------
     for (const thisComponent of feedback_practiceComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     
     
     
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var code_endComponents;
 function code_endRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'code_end'-------
     t = 0;
     code_endClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     console.log(allResponses_p)
     
     if (allResponses_p.length === 2 && allResponses_p.slice(-2).reduce((a,b)=>a+b) > 1) {
         trials_2.finished = true;
     } else if (allResponses_p.length === 2 && allResponses_p.slice(-2).reduce((a,b)=>a+b) < 2) {
         //trials.finished = true;
         allResponses_p = [];
         condition_counter = condition_counter + 1 
     }
     
     console.log(allResponses_p)
     // keep track of which components have finished
     code_endComponents = [];
     
     for (const thisComponent of code_endComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function code_endRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'code_end'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = code_endClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of code_endComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function code_endRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'code_end'-------
     for (const thisComponent of code_endComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // the Routine "code_end" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_6_allKeys;
 var repeat_instructionsComponents;
 function repeat_instructionsRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'repeat_instructions'-------
     t = 0;
     repeat_instructionsClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_6.keys = undefined;
     key_resp_6.rt = undefined;
     _key_resp_6_allKeys = [];
     // keep track of which components have finished
     repeat_instructionsComponents = [];
     repeat_instructionsComponents.push(text_9);
     repeat_instructionsComponents.push(key_resp_6);
     repeat_instructionsComponents.push(text_10);
     
     for (const thisComponent of repeat_instructionsComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function repeat_instructionsRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'repeat_instructions'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = repeat_instructionsClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *text_9* updates
     if (t >= 0.0 && text_9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_9.tStart = t;  // (not accounting for frame time here)
       text_9.frameNStart = frameN;  // exact frame index
       
       text_9.setAutoDraw(true);
     }
 
     console.log(condition_counter);
     console.log(allResponses_p.length);
     
     if (condition_counter === 0) {
         continueRoutine = false;
     } else if (condition_counter > 1){
         continueRoutine = false;
         } else if (condition_counter === 1 && allResponses_p.length < 2){
             continueRoutine = true;
             }else if (condition_counter === 1 && allResponses_p.slice(-2).reduce((a,b)=>a+b) > 1){
                 continueRoutine = false;
                 } else if (key_resp_6.keys === 'space') {
                     continueRoutine = false;
                     }
     
     
     
     // *key_resp_6* updates
     if (t >= 0.0 && key_resp_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_6.tStart = t;  // (not accounting for frame time here)
       key_resp_6.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_6.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_6.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_6.clearEvents(); });
     }
 
     if (key_resp_6.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_6.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_6_allKeys = _key_resp_6_allKeys.concat(theseKeys);
       if (_key_resp_6_allKeys.length > 0) {
         key_resp_6.keys = _key_resp_6_allKeys[_key_resp_6_allKeys.length - 1].name;  // just the last key pressed
         key_resp_6.rt = _key_resp_6_allKeys[_key_resp_6_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_10* updates
     if (t >= 0.0 && text_10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_10.tStart = t;  // (not accounting for frame time here)
       text_10.frameNStart = frameN;  // exact frame index
       
       text_10.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of repeat_instructionsComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function repeat_instructionsRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'repeat_instructions'-------
     for (const thisComponent of repeat_instructionsComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_6.keys', key_resp_6.keys);
     if (typeof key_resp_6.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_6.rt', key_resp_6.rt);
         routineTimer.reset();
         }
     
     key_resp_6.stop();
     // the Routine "repeat_instructions" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_5_allKeys;
 var real_trialsComponents;
 function real_trialsRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'real_trials'-------
     t = 0;
     real_trialsClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_5.keys = undefined;
     key_resp_5.rt = undefined;
     _key_resp_5_allKeys = [];
     // keep track of which components have finished
     real_trialsComponents = [];
     real_trialsComponents.push(get_ready_real_trial);
     real_trialsComponents.push(press_space);
     real_trialsComponents.push(key_resp_5);
     
     for (const thisComponent of real_trialsComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function real_trialsRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'real_trials'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = real_trialsClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *get_ready_real_trial* updates
     if (t >= 0.0 && get_ready_real_trial.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       get_ready_real_trial.tStart = t;  // (not accounting for frame time here)
       get_ready_real_trial.frameNStart = frameN;  // exact frame index
       
       get_ready_real_trial.setAutoDraw(true);
     }
 
     
     // *press_space* updates
     if (t >= 0.0 && press_space.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       press_space.tStart = t;  // (not accounting for frame time here)
       press_space.frameNStart = frameN;  // exact frame index
       
       press_space.setAutoDraw(true);
     }
 
     
     // *key_resp_5* updates
     if (t >= 0.0 && key_resp_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_5.tStart = t;  // (not accounting for frame time here)
       key_resp_5.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_5.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_5.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_5.clearEvents(); });
     }
 
     if (key_resp_5.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_5.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_5_allKeys = _key_resp_5_allKeys.concat(theseKeys);
       if (_key_resp_5_allKeys.length > 0) {
         key_resp_5.keys = _key_resp_5_allKeys[_key_resp_5_allKeys.length - 1].name;  // just the last key pressed
         key_resp_5.rt = _key_resp_5_allKeys[_key_resp_5_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of real_trialsComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function real_trialsRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'real_trials'-------
     for (const thisComponent of real_trialsComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_5.keys', key_resp_5.keys);
     if (typeof key_resp_5.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_5.rt', key_resp_5.rt);
         routineTimer.reset();
         }
     
     key_resp_5.stop();
     // the Routine "real_trials" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var PresentationComponents;
 function PresentationRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Presentation'-------
     t = 0;
     PresentationClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // Convert sequence to list
     nList = digits.toString().split('').map((i)=>Number(i))
     // keep track of which components have finished
     PresentationComponents = [];
     PresentationComponents.push(fixation);
     PresentationComponents.push(pres_text);
     
     for (const thisComponent of PresentationComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function PresentationRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Presentation'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = PresentationClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *fixation* updates
     if (t >= 0.0 && fixation.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixation.tStart = t;  // (not accounting for frame time here)
       fixation.frameNStart = frameN;  // exact frame index
       
       fixation.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fixation.status === PsychoJS.Status.STARTED || fixation.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fixation.setAutoDraw(false);
     }
     
     // *pres_text* updates
     if (t >= 1 && pres_text.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pres_text.tStart = t;  // (not accounting for frame time here)
       pres_text.frameNStart = frameN;  // exact frame index
       
       pres_text.setAutoDraw(true);
     }
 
     // Convert time ti a list index
     i = Math.floor(t-1);
     
     // Index current number in the list
     // or end routine if all numbers presented
     
     if (i === nList.length) {
         continueRoutine = false;
     } else if (i < 0){
         pres_text.text = ' '
     } else {
         pres_text.text = nList[i]
     }
     
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of PresentationComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function PresentationRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Presentation'-------
     for (const thisComponent of PresentationComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     pres_text.text = ''
     // the Routine "Presentation" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_7_allKeys;
 var nn;
 var RecallComponents;
 function RecallRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Recall'-------
     t = 0;
     RecallClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_7.keys = undefined;
     key_resp_7.rt = undefined;
     _key_resp_7_allKeys = [];
     nn = 0;
     // keep track of which components have finished
     RecallComponents = [];
     RecallComponents.push(recall_text);
     RecallComponents.push(key_resp_7);
     RecallComponents.push(pts_response);
     
     for (const thisComponent of RecallComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function RecallRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Recall'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = RecallClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *recall_text* updates
     if (t >= 0 && recall_text.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       recall_text.tStart = t;  // (not accounting for frame time here)
       recall_text.frameNStart = frameN;  // exact frame index
       
       recall_text.setAutoDraw(true);
     }
 
     
     // *key_resp_7* updates
     if (t >= 0 && key_resp_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_7.tStart = t;  // (not accounting for frame time here)
       key_resp_7.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_7.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_7.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_7.clearEvents(); });
     }
 
     if (key_resp_7.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_7.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'return', 'backspace'], waitRelease: false});
       _key_resp_7_allKeys = _key_resp_7_allKeys.concat(theseKeys);
       if (_key_resp_7_allKeys.length > 0) {
         key_resp_7.keys = _key_resp_7_allKeys.map((key) => key.name);  // storing all keys
         key_resp_7.rt = _key_resp_7_allKeys.map((key) => key.rt);
       }
     }
     
     let theseKeys = psychoJS.eventManager.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'return'], waitRelease: false});
     if (theseKeys.length > 0) {  // at least one key was pressed
       textAdd = theseKeys[theseKeys.length-1]; 
       }
     
     if (nn < 1){
         textAdd = '';
     }
     
     
     
     if (textAdd === 'return') {
         textAdd = '';  // Add nothing
         continueRoutine = false;  // End routine (if that is what you want)
     } else if (textAdd === 'backspace') {
         pts_response.text = pts_response.text.slice(0, -1);
         textAdd = undefined;
     } else if (['lshift', 'rshift'].includes(textAdd)) {
             modify = true;
     } else if (textAdd !== undefined) {
         if (modify) {
             pts_response.text = pts_response.text + textAdd.toUpperCase();
             modify = false;
         } else {
             pts_response.text = pts_response.text + textAdd
         }
         textAdd = undefined;
     }
      
     nn = nn + 1;
     current_resp = pts_response.text
     
     // *pts_response* updates
     if (t >= 0 && pts_response.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pts_response.tStart = t;  // (not accounting for frame time here)
       pts_response.frameNStart = frameN;  // exact frame index
       
       pts_response.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of RecallComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function RecallRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Recall'-------
     for (const thisComponent of RecallComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_7.keys', key_resp_7.keys);
     if (typeof key_resp_7.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_7.rt', key_resp_7.rt);
         }
     
     key_resp_7.stop();
     correct = 0;
     
     if (Number(current_resp) === digits_corr) {
         correct = 1;
         msg = "Correct";
         psychoJS.experiment.addData("correct", correct)
     } else {
         msg = "Incorrect";
         psychoJS.experiment.addData("Incorrect", correct)
     }
     psychoJS.experiment.addData("response", current_resp);
     
     allResponses.push(correct)
     pts_response.text = '';
     // the Routine "Recall" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var FeedbackComponents;
 function FeedbackRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Feedback'-------
     t = 0;
     FeedbackClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // keep track of which components have finished
     FeedbackComponents = [];
     
     for (const thisComponent of FeedbackComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function FeedbackRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Feedback'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = FeedbackClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of FeedbackComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function FeedbackRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Feedback'-------
     for (const thisComponent of FeedbackComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // Original logic:
     // for incorrect, check that two responses exist
     // and that their sum of last two responses is zero
     
     
     //Changing logic from original code
     //Now, when allResponses == 2
     //If sum of the 2 responses == 0, end experiment
     //If sum of the 2 responses is > 0 (i.e., 1 or 2), then keep going with the experiment
     
     console.log(allResponses.length);
     if (allResponses.length === 2 && allResponses.slice(-2).reduce((a,b)=>a+b) === 2) {
         trials.finished = true;
         allResponses = [];
     } else if (allResponses.length === 2 && allResponses.slice(-2).reduce((a,b)=>a+b) === 0) {
         trials.finished = true;
         blocks.finished = true;
     } else if (allResponses.length === 2 && allResponses.slice(-2).reduce((a,b)=>a+b) === 1) {
         trials.finished = false;
     } else if (allResponses.length === 3 && allResponses.slice(-2).reduce((a,b)=>a+b) === 2) {
         trials.finished = true;
         allResponses = [];
     } else if (allResponses.length === 3 && allResponses.slice(-2).reduce((a,b)=>a+b) < 2) {
         trials.finished = true;
         blocks.finished = true;
         }
     
     //var sum = 0;
     //for (var i = 0; i < allResponses.length; i++){
     //  sum += allResponses[i];
     //}
     
     //if (allResponses.length === 2 && sum === 0) {
     //    trials.finished = true;
     //    blocks.finished = true;
     //} else if (allResponses.length === 2 && sum > 0) {
     //    //trials.finished = true;
     //    allResponses = [];
     //}
     
     
     // the Routine "Feedback" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var EndComponents;
 function EndRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'End'-------
     t = 0;
     EndClock.reset(); // clock
     frameN = -1;
     routineTimer.add(3.000000);
     // update component parameters for each repeat
     // keep track of which components have finished
     EndComponents = [];
     EndComponents.push(thank_you);
     EndComponents.push(before_closing);
     
     for (const thisComponent of EndComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function EndRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'End'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = EndClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *thank_you* updates
     if (t >= 0.0 && thank_you.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       thank_you.tStart = t;  // (not accounting for frame time here)
       thank_you.frameNStart = frameN;  // exact frame index
       
       thank_you.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((thank_you.status === PsychoJS.Status.STARTED || thank_you.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       thank_you.setAutoDraw(false);
     }
     
     // *before_closing* updates
     if (t >= 0.0 && before_closing.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       before_closing.tStart = t;  // (not accounting for frame time here)
       before_closing.frameNStart = frameN;  // exact frame index
       
       before_closing.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((before_closing.status === PsychoJS.Status.STARTED || before_closing.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       before_closing.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of EndComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function EndRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'End'-------
     for (const thisComponent of EndComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_10_allKeys;
 var Welcome_2Components;
 function Welcome_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Welcome_2'-------
     t = 0;
     Welcome_2Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_10.keys = undefined;
     key_resp_10.rt = undefined;
     _key_resp_10_allKeys = [];
     // keep track of which components have finished
     Welcome_2Components = [];
     Welcome_2Components.push(white_background_10);
     Welcome_2Components.push(text_15);
     Welcome_2Components.push(text_17);
     Welcome_2Components.push(key_resp_10);
     
     for (const thisComponent of Welcome_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Welcome_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Welcome_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Welcome_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_10* updates
     if (t >= 0.0 && white_background_10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_10.tStart = t;  // (not accounting for frame time here)
       white_background_10.frameNStart = frameN;  // exact frame index
       
       white_background_10.setAutoDraw(true);
     }
 
     
     // *text_15* updates
     if (t >= 0.0 && text_15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_15.tStart = t;  // (not accounting for frame time here)
       text_15.frameNStart = frameN;  // exact frame index
       
       text_15.setAutoDraw(true);
     }
 
     
     // *text_17* updates
     if (t >= 0.0 && text_17.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_17.tStart = t;  // (not accounting for frame time here)
       text_17.frameNStart = frameN;  // exact frame index
       
       text_17.setAutoDraw(true);
     }
 
     
     // *key_resp_10* updates
     if (t >= 0.0 && key_resp_10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_10.tStart = t;  // (not accounting for frame time here)
       key_resp_10.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_10.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_10.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_10.clearEvents(); });
     }
 
     if (key_resp_10.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_10.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_10_allKeys = _key_resp_10_allKeys.concat(theseKeys);
       if (_key_resp_10_allKeys.length > 0) {
         key_resp_10.keys = _key_resp_10_allKeys[_key_resp_10_allKeys.length - 1].name;  // just the last key pressed
         key_resp_10.rt = _key_resp_10_allKeys[_key_resp_10_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Welcome_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Welcome_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Welcome_2'-------
     for (const thisComponent of Welcome_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_10.keys', key_resp_10.keys);
     if (typeof key_resp_10.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_10.rt', key_resp_10.rt);
         routineTimer.reset();
         }
     
     key_resp_10.stop();
     // the Routine "Welcome_2" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_27_allKeys;
 var IntroA_2Components;
 function IntroA_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'IntroA_2'-------
     t = 0;
     IntroA_2Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_27.keys = undefined;
     key_resp_27.rt = undefined;
     _key_resp_27_allKeys = [];
     // keep track of which components have finished
     IntroA_2Components = [];
     IntroA_2Components.push(white_background_25);
     IntroA_2Components.push(image_11);
     IntroA_2Components.push(text_40);
     IntroA_2Components.push(text_46);
     IntroA_2Components.push(key_resp_27);
     
     for (const thisComponent of IntroA_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroA_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'IntroA_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = IntroA_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_25* updates
     if (t >= 0.0 && white_background_25.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_25.tStart = t;  // (not accounting for frame time here)
       white_background_25.frameNStart = frameN;  // exact frame index
       
       white_background_25.setAutoDraw(true);
     }
 
     
     // *image_11* updates
     if (t >= 0.0 && image_11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_11.tStart = t;  // (not accounting for frame time here)
       image_11.frameNStart = frameN;  // exact frame index
       
       image_11.setAutoDraw(true);
     }
 
     
     // *text_40* updates
     if (t >= 0.0 && text_40.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_40.tStart = t;  // (not accounting for frame time here)
       text_40.frameNStart = frameN;  // exact frame index
       
       text_40.setAutoDraw(true);
     }
 
     
     // *text_46* updates
     if (t >= 0.0 && text_46.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_46.tStart = t;  // (not accounting for frame time here)
       text_46.frameNStart = frameN;  // exact frame index
       
       text_46.setAutoDraw(true);
     }
 
     
     // *key_resp_27* updates
     if (t >= 0.0 && key_resp_27.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_27.tStart = t;  // (not accounting for frame time here)
       key_resp_27.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       key_resp_27.clock.reset();
       key_resp_27.start();
     }
 
     if (key_resp_27.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_27.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_27_allKeys = _key_resp_27_allKeys.concat(theseKeys);
       if (_key_resp_27_allKeys.length > 0) {
         key_resp_27.keys = _key_resp_27_allKeys[_key_resp_27_allKeys.length - 1].name;  // just the last key pressed
         key_resp_27.rt = _key_resp_27_allKeys[_key_resp_27_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of IntroA_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroA_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'IntroA_2'-------
     for (const thisComponent of IntroA_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // the Routine "IntroA_2" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_28_allKeys;
 var IntroB_2Components;
 function IntroB_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'IntroB_2'-------
     t = 0;
     IntroB_2Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_28.keys = undefined;
     key_resp_28.rt = undefined;
     _key_resp_28_allKeys = [];
     // keep track of which components have finished
     IntroB_2Components = [];
     IntroB_2Components.push(white_background_21);
     IntroB_2Components.push(text_52);
     IntroB_2Components.push(text_53);
     IntroB_2Components.push(key_resp_28);
     
     for (const thisComponent of IntroB_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroB_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'IntroB_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = IntroB_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_21* updates
     if (t >= 0.0 && white_background_21.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_21.tStart = t;  // (not accounting for frame time here)
       white_background_21.frameNStart = frameN;  // exact frame index
       
       white_background_21.setAutoDraw(true);
     }
 
     
     // *text_52* updates
     if (t >= 0.0 && text_52.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_52.tStart = t;  // (not accounting for frame time here)
       text_52.frameNStart = frameN;  // exact frame index
       
       text_52.setAutoDraw(true);
     }
 
     
     // *text_53* updates
     if (t >= 0.0 && text_53.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_53.tStart = t;  // (not accounting for frame time here)
       text_53.frameNStart = frameN;  // exact frame index
       
       text_53.setAutoDraw(true);
     }
 
     
     // *key_resp_28* updates
     if (t >= 0.0 && key_resp_28.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_28.tStart = t;  // (not accounting for frame time here)
       key_resp_28.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_28.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_28.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_28.clearEvents(); });
     }
 
     if (key_resp_28.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_28.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_28_allKeys = _key_resp_28_allKeys.concat(theseKeys);
       if (_key_resp_28_allKeys.length > 0) {
         key_resp_28.keys = _key_resp_28_allKeys[_key_resp_28_allKeys.length - 1].name;  // just the last key pressed
         key_resp_28.rt = _key_resp_28_allKeys[_key_resp_28_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of IntroB_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroB_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'IntroB_2'-------
     for (const thisComponent of IntroB_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // the Routine "IntroB_2" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_11_allKeys;
 var Example1Components;
 function Example1RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Example1'-------
     t = 0;
     Example1Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_11.keys = undefined;
     key_resp_11.rt = undefined;
     _key_resp_11_allKeys = [];
     // keep track of which components have finished
     Example1Components = [];
     Example1Components.push(white_background_14);
     Example1Components.push(text_18);
     Example1Components.push(image_3);
     Example1Components.push(key_resp_11);
     Example1Components.push(text_60);
     
     for (const thisComponent of Example1Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Example1RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Example1'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Example1Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_14* updates
     if (t >= 0.0 && white_background_14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_14.tStart = t;  // (not accounting for frame time here)
       white_background_14.frameNStart = frameN;  // exact frame index
       
       white_background_14.setAutoDraw(true);
     }
 
     
     // *text_18* updates
     if (t >= 0.0 && text_18.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_18.tStart = t;  // (not accounting for frame time here)
       text_18.frameNStart = frameN;  // exact frame index
       
       text_18.setAutoDraw(true);
     }
 
     
     // *image_3* updates
     if (t >= 0.0 && image_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_3.tStart = t;  // (not accounting for frame time here)
       image_3.frameNStart = frameN;  // exact frame index
       
       image_3.setAutoDraw(true);
     }
 
     
     // *key_resp_11* updates
     if (t >= 0.0 && key_resp_11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_11.tStart = t;  // (not accounting for frame time here)
       key_resp_11.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_11.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_11.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_11.clearEvents(); });
     }
 
     if (key_resp_11.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_11.getKeys({keyList: ['m'], waitRelease: false});
       _key_resp_11_allKeys = _key_resp_11_allKeys.concat(theseKeys);
       if (_key_resp_11_allKeys.length > 0) {
         key_resp_11.keys = _key_resp_11_allKeys[_key_resp_11_allKeys.length - 1].name;  // just the last key pressed
         key_resp_11.rt = _key_resp_11_allKeys[_key_resp_11_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_60* updates
     if (t >= 0.0 && text_60.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_60.tStart = t;  // (not accounting for frame time here)
       text_60.frameNStart = frameN;  // exact frame index
       
       text_60.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Example1Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Example1RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Example1'-------
     for (const thisComponent of Example1Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_11.keys', key_resp_11.keys);
     if (typeof key_resp_11.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_11.rt', key_resp_11.rt);
         routineTimer.reset();
         }
     
     key_resp_11.stop();
     // the Routine "Example1" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_12_allKeys;
 var Example2Components;
 function Example2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Example2'-------
     t = 0;
     Example2Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_12.keys = undefined;
     key_resp_12.rt = undefined;
     _key_resp_12_allKeys = [];
     // keep track of which components have finished
     Example2Components = [];
     Example2Components.push(white_background_12);
     Example2Components.push(text_19);
     Example2Components.push(image_4);
     Example2Components.push(key_resp_12);
     Example2Components.push(text_61);
     
     for (const thisComponent of Example2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Example2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Example2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Example2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_12* updates
     if (t >= 0.0 && white_background_12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_12.tStart = t;  // (not accounting for frame time here)
       white_background_12.frameNStart = frameN;  // exact frame index
       
       white_background_12.setAutoDraw(true);
     }
 
     
     // *text_19* updates
     if (t >= 0.0 && text_19.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_19.tStart = t;  // (not accounting for frame time here)
       text_19.frameNStart = frameN;  // exact frame index
       
       text_19.setAutoDraw(true);
     }
 
     
     // *image_4* updates
     if (t >= 0.0 && image_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_4.tStart = t;  // (not accounting for frame time here)
       image_4.frameNStart = frameN;  // exact frame index
       
       image_4.setAutoDraw(true);
     }
 
     
     // *key_resp_12* updates
     if (t >= 0.0 && key_resp_12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_12.tStart = t;  // (not accounting for frame time here)
       key_resp_12.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_12.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_12.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_12.clearEvents(); });
     }
 
     if (key_resp_12.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_12.getKeys({keyList: ['z'], waitRelease: false});
       _key_resp_12_allKeys = _key_resp_12_allKeys.concat(theseKeys);
       if (_key_resp_12_allKeys.length > 0) {
         key_resp_12.keys = _key_resp_12_allKeys[_key_resp_12_allKeys.length - 1].name;  // just the last key pressed
         key_resp_12.rt = _key_resp_12_allKeys[_key_resp_12_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_61* updates
     if (t >= 0.0 && text_61.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_61.tStart = t;  // (not accounting for frame time here)
       text_61.frameNStart = frameN;  // exact frame index
       
       text_61.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Example2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Example2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Example2'-------
     for (const thisComponent of Example2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_12.keys', key_resp_12.keys);
     if (typeof key_resp_12.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_12.rt', key_resp_12.rt);
         routineTimer.reset();
         }
     
     key_resp_12.stop();
     // the Routine "Example2" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_32_allKeys;
 var Quick_ReminderComponents;
 function Quick_ReminderRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Quick_Reminder'-------
     t = 0;
     Quick_ReminderClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_32.keys = undefined;
     key_resp_32.rt = undefined;
     _key_resp_32_allKeys = [];
     // keep track of which components have finished
     Quick_ReminderComponents = [];
     Quick_ReminderComponents.push(white_background_19);
     Quick_ReminderComponents.push(text_71);
     Quick_ReminderComponents.push(key_resp_32);
     Quick_ReminderComponents.push(text_72);
     
     for (const thisComponent of Quick_ReminderComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Quick_ReminderRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Quick_Reminder'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Quick_ReminderClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_19* updates
     if (t >= 0.0 && white_background_19.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_19.tStart = t;  // (not accounting for frame time here)
       white_background_19.frameNStart = frameN;  // exact frame index
       
       white_background_19.setAutoDraw(true);
     }
 
     
     // *text_71* updates
     if (t >= 0.0 && text_71.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_71.tStart = t;  // (not accounting for frame time here)
       text_71.frameNStart = frameN;  // exact frame index
       
       text_71.setAutoDraw(true);
     }
 
     
     // *key_resp_32* updates
     if (t >= 0.0 && key_resp_32.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_32.tStart = t;  // (not accounting for frame time here)
       key_resp_32.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_32.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_32.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_32.clearEvents(); });
     }
 
     if (key_resp_32.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_32.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_32_allKeys = _key_resp_32_allKeys.concat(theseKeys);
       if (_key_resp_32_allKeys.length > 0) {
         key_resp_32.keys = _key_resp_32_allKeys[_key_resp_32_allKeys.length - 1].name;  // just the last key pressed
         key_resp_32.rt = _key_resp_32_allKeys[_key_resp_32_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_72* updates
     if (t >= 0.0 && text_72.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_72.tStart = t;  // (not accounting for frame time here)
       text_72.frameNStart = frameN;  // exact frame index
       
       text_72.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Quick_ReminderComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Quick_ReminderRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Quick_Reminder'-------
     for (const thisComponent of Quick_ReminderComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_32.keys', key_resp_32.keys);
     if (typeof key_resp_32.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_32.rt', key_resp_32.rt);
         routineTimer.reset();
         }
     
     key_resp_32.stop();
     // the Routine "Quick_Reminder" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_13_allKeys;
 var Practice_congruentComponents;
 function Practice_congruentRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Practice_congruent'-------
     t = 0;
     Practice_congruentClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_13.keys = undefined;
     key_resp_13.rt = undefined;
     _key_resp_13_allKeys = [];
     // keep track of which components have finished
     Practice_congruentComponents = [];
     Practice_congruentComponents.push(white_background_7);
     Practice_congruentComponents.push(text_20);
     Practice_congruentComponents.push(text_21);
     Practice_congruentComponents.push(key_resp_13);
     
     for (const thisComponent of Practice_congruentComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Practice_congruentRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Practice_congruent'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Practice_congruentClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_7* updates
     if (t >= 0.0 && white_background_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_7.tStart = t;  // (not accounting for frame time here)
       white_background_7.frameNStart = frameN;  // exact frame index
       
       white_background_7.setAutoDraw(true);
     }
 
     
     // *text_20* updates
     if (t >= 0.0 && text_20.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_20.tStart = t;  // (not accounting for frame time here)
       text_20.frameNStart = frameN;  // exact frame index
       
       text_20.setAutoDraw(true);
     }
 
     
     // *text_21* updates
     if (t >= 0.0 && text_21.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_21.tStart = t;  // (not accounting for frame time here)
       text_21.frameNStart = frameN;  // exact frame index
       
       text_21.setAutoDraw(true);
     }
 
     
     // *key_resp_13* updates
     if (t >= 0.0 && key_resp_13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_13.tStart = t;  // (not accounting for frame time here)
       key_resp_13.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_13.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_13.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_13.clearEvents(); });
     }
 
     if (key_resp_13.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_13.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_13_allKeys = _key_resp_13_allKeys.concat(theseKeys);
       if (_key_resp_13_allKeys.length > 0) {
         key_resp_13.keys = _key_resp_13_allKeys[_key_resp_13_allKeys.length - 1].name;  // just the last key pressed
         key_resp_13.rt = _key_resp_13_allKeys[_key_resp_13_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Practice_congruentComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Practice_congruentRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Practice_congruent'-------
     for (const thisComponent of Practice_congruentComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_13.keys', key_resp_13.keys);
     if (typeof key_resp_13.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_13.rt', key_resp_13.rt);
         routineTimer.reset();
         }
     
     key_resp_13.stop();
     // the Routine "Practice_congruent" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_14_allKeys;
 var Practice_trial_congruentComponents;
 function Practice_trial_congruentRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Practice_trial_congruent'-------
     t = 0;
     Practice_trial_congruentClock.reset(); // clock
     frameN = -1;
     routineTimer.add(2.250000);
     // update component parameters for each repeat
     image_5.setImage(Heart);
     key_resp_14.keys = undefined;
     key_resp_14.rt = undefined;
     _key_resp_14_allKeys = [];
     var color_msg_incongruent01;
     var msg_incongruent01;
     // keep track of which components have finished
     Practice_trial_congruentComponents = [];
     Practice_trial_congruentComponents.push(white_background_17);
     Practice_trial_congruentComponents.push(text_22);
     Practice_trial_congruentComponents.push(text_64);
     Practice_trial_congruentComponents.push(image_5);
     Practice_trial_congruentComponents.push(text_28);
     Practice_trial_congruentComponents.push(key_resp_14);
     
     for (const thisComponent of Practice_trial_congruentComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Practice_trial_congruentRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Practice_trial_congruent'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Practice_trial_congruentClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_17* updates
     if (t >= 0.0 && white_background_17.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_17.tStart = t;  // (not accounting for frame time here)
       white_background_17.frameNStart = frameN;  // exact frame index
       
       white_background_17.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_17.status === PsychoJS.Status.STARTED || white_background_17.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_17.setAutoDraw(false);
     }
     
     // *text_22* updates
     if (t >= 0.0 && text_22.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_22.tStart = t;  // (not accounting for frame time here)
       text_22.frameNStart = frameN;  // exact frame index
       
       text_22.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_22.status === PsychoJS.Status.STARTED || text_22.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_22.setAutoDraw(false);
     }
     
     // *text_64* updates
     if (t >= 0.5 && text_64.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_64.tStart = t;  // (not accounting for frame time here)
       text_64.frameNStart = frameN;  // exact frame index
       
       text_64.setAutoDraw(true);
     }
 
     frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_64.status === PsychoJS.Status.STARTED || text_64.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_64.setAutoDraw(false);
     }
     
     // *image_5* updates
     if (t >= 1.0 && image_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_5.tStart = t;  // (not accounting for frame time here)
       image_5.frameNStart = frameN;  // exact frame index
       
       image_5.setAutoDraw(true);
     }
 
     frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((image_5.status === PsychoJS.Status.STARTED || image_5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       image_5.setAutoDraw(false);
     }
     
     // *text_28* updates
     if (t >= 1.75 && text_28.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_28.tStart = t;  // (not accounting for frame time here)
       text_28.frameNStart = frameN;  // exact frame index
       
       text_28.setAutoDraw(true);
     }
 
     frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_28.status === PsychoJS.Status.STARTED || text_28.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_28.setAutoDraw(false);
     }
     
     // *key_resp_14* updates
     if (t >= 1.0 && key_resp_14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_14.tStart = t;  // (not accounting for frame time here)
       key_resp_14.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_14.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_14.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_14.clearEvents(); });
     }
 
     frameRemains = 1.0 + 1.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((key_resp_14.status === PsychoJS.Status.STARTED || key_resp_14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       key_resp_14.status = PsychoJS.Status.FINISHED;
   }
 
     if (key_resp_14.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_14.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_14_allKeys = _key_resp_14_allKeys.concat(theseKeys);
       if (_key_resp_14_allKeys.length > 0) {
         key_resp_14.keys = _key_resp_14_allKeys[_key_resp_14_allKeys.length - 1].name;  // just the last key pressed
         key_resp_14.rt = _key_resp_14_allKeys[_key_resp_14_allKeys.length - 1].rt;
         // was this correct?
         if (key_resp_14.keys == corAns) {
             key_resp_14.corr = 1;
         } else {
             key_resp_14.corr = 0;
         }
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Practice_trial_congruentComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 var msg_incongruent01;
 var color_msg_incongruent01;
 function Practice_trial_congruentRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Practice_trial_congruent'-------
     for (const thisComponent of Practice_trial_congruentComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // was no response the correct answer?!
     if (key_resp_14.keys === undefined) {
       if (['None','none',undefined].includes(corAns)) {
          key_resp_14.corr = 1;  // correct non-response
       } else {
          key_resp_14.corr = 0;  // failed to respond (incorrectly)
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('key_resp_14.keys', key_resp_14.keys);
     psychoJS.experiment.addData('key_resp_14.corr', key_resp_14.corr);
     if (typeof key_resp_14.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_14.rt', key_resp_14.rt);
         routineTimer.reset();
         }
     
     key_resp_14.stop();
       if (key_resp_14.keys === undefined) {
           msg_incongruent01 = 'No response'
           color_msg_incongruent01 = 'black'
           } else {
           if (key_resp_14.corr > 0){
               msg_incongruent01 = 'Correct'
               color_msg_incongruent01 = 'green'
           } else {
               msg_incongruent01 = 'Incorrect'
               color_msg_incongruent01 = 'red'
           }
           }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var feedback_hf_congruent_1Components;
 function feedback_hf_congruent_1RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'feedback_hf_congruent_1'-------
     t = 0;
     feedback_hf_congruent_1Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(1.500000);
     // update component parameters for each repeat
     text_108.setColor(new util.Color(color_msg_incongruent01));
     text_108.setText(msg_incongruent01);
     // keep track of which components have finished
     feedback_hf_congruent_1Components = [];
     feedback_hf_congruent_1Components.push(white_background_33);
     feedback_hf_congruent_1Components.push(text_108);
     
     for (const thisComponent of feedback_hf_congruent_1Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_hf_congruent_1RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'feedback_hf_congruent_1'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = feedback_hf_congruent_1Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_33* updates
     if (t >= 0.0 && white_background_33.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_33.tStart = t;  // (not accounting for frame time here)
       white_background_33.frameNStart = frameN;  // exact frame index
       
       white_background_33.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_33.status === PsychoJS.Status.STARTED || white_background_33.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_33.setAutoDraw(false);
     }
     
     // *text_108* updates
     if (t >= 0.0 && text_108.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_108.tStart = t;  // (not accounting for frame time here)
       text_108.frameNStart = frameN;  // exact frame index
       
       text_108.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_108.status === PsychoJS.Status.STARTED || text_108.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_108.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of feedback_hf_congruent_1Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_hf_congruent_1RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'feedback_hf_congruent_1'-------
     for (const thisComponent of feedback_hf_congruent_1Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_37_allKeys;
 var nCorrhf01;
 var congruent_reminderComponents;
 function congruent_reminderRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'congruent_reminder'-------
     t = 0;
     congruent_reminderClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_37.keys = undefined;
     key_resp_37.rt = undefined;
     _key_resp_37_allKeys = [];
     nCorrhf01 = 0;
     console.log("hf_congruent02")
     console.log(nCorrhf01)
       for (eachResp=0; eachResp<psychoJS.experiment._trialsData.length; eachResp++){
         if ('key_resp_14.corr' in psychoJS.experiment._trialsData[eachResp]) {
         nCorrhf01 += psychoJS.experiment._trialsData[eachResp]['key_resp_14.corr'];
         }
       }
     
     
     console.log("hf_congruent02")
     console.log(nCorrhf01)
     
     // keep track of which components have finished
     congruent_reminderComponents = [];
     congruent_reminderComponents.push(white_background_41);
     congruent_reminderComponents.push(text_102);
     congruent_reminderComponents.push(text_103);
     congruent_reminderComponents.push(key_resp_37);
     
     for (const thisComponent of congruent_reminderComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function congruent_reminderRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'congruent_reminder'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = congruent_reminderClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_41* updates
     if (t >= 0.0 && white_background_41.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_41.tStart = t;  // (not accounting for frame time here)
       white_background_41.frameNStart = frameN;  // exact frame index
       
       white_background_41.setAutoDraw(true);
     }
 
     
     // *text_102* updates
     if (t >= 0.0 && text_102.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_102.tStart = t;  // (not accounting for frame time here)
       text_102.frameNStart = frameN;  // exact frame index
       
       text_102.setAutoDraw(true);
     }
 
     
     // *text_103* updates
     if (t >= 0.0 && text_103.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_103.tStart = t;  // (not accounting for frame time here)
       text_103.frameNStart = frameN;  // exact frame index
       
       text_103.setAutoDraw(true);
     }
 
     
     // *key_resp_37* updates
     if (t >= 0.0 && key_resp_37.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_37.tStart = t;  // (not accounting for frame time here)
       key_resp_37.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_37.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_37.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_37.clearEvents(); });
     }
 
     if (key_resp_37.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_37.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_37_allKeys = _key_resp_37_allKeys.concat(theseKeys);
       if (_key_resp_37_allKeys.length > 0) {
         key_resp_37.keys = _key_resp_37_allKeys[_key_resp_37_allKeys.length - 1].name;  // just the last key pressed
         key_resp_37.rt = _key_resp_37_allKeys[_key_resp_37_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     if (nCorrhf01 > 2) {
         console.log("true")
         continueRoutine = false; // until we're told otherwise
         } 
     else if (key_resp_37.keys === 'space') {
         continueRoutine = false;
         }
     else {
         console.log("false")
         continueRoutine = true;
         }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of congruent_reminderComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function congruent_reminderRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'congruent_reminder'-------
     for (const thisComponent of congruent_reminderComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // the Routine "congruent_reminder" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_21_allKeys;
 var Practice_trial_congruent_2Components;
 function Practice_trial_congruent_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Practice_trial_congruent_2'-------
     t = 0;
     Practice_trial_congruent_2Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(2.250000);
     // update component parameters for each repeat
     image_13.setImage(Heart);
     key_resp_21.keys = undefined;
     key_resp_21.rt = undefined;
     _key_resp_21_allKeys = [];
     var msg_incongruent02;
     var color_msg_incongruent02;
     
     console.log("hf_congruent02")
     console.log(nCorrhf01)
     // keep track of which components have finished
     Practice_trial_congruent_2Components = [];
     Practice_trial_congruent_2Components.push(white_background_32);
     Practice_trial_congruent_2Components.push(text_93);
     Practice_trial_congruent_2Components.push(text_94);
     Practice_trial_congruent_2Components.push(image_13);
     Practice_trial_congruent_2Components.push(text_95);
     Practice_trial_congruent_2Components.push(key_resp_21);
     
     for (const thisComponent of Practice_trial_congruent_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Practice_trial_congruent_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Practice_trial_congruent_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Practice_trial_congruent_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_32* updates
     if (t >= 0.0 && white_background_32.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_32.tStart = t;  // (not accounting for frame time here)
       white_background_32.frameNStart = frameN;  // exact frame index
       
       white_background_32.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_32.status === PsychoJS.Status.STARTED || white_background_32.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_32.setAutoDraw(false);
     }
     
     // *text_93* updates
     if (t >= 0.0 && text_93.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_93.tStart = t;  // (not accounting for frame time here)
       text_93.frameNStart = frameN;  // exact frame index
       
       text_93.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_93.status === PsychoJS.Status.STARTED || text_93.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_93.setAutoDraw(false);
     }
     
     // *text_94* updates
     if (t >= 0.5 && text_94.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_94.tStart = t;  // (not accounting for frame time here)
       text_94.frameNStart = frameN;  // exact frame index
       
       text_94.setAutoDraw(true);
     }
 
     frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_94.status === PsychoJS.Status.STARTED || text_94.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_94.setAutoDraw(false);
     }
     
     // *image_13* updates
     if (t >= 1.0 && image_13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_13.tStart = t;  // (not accounting for frame time here)
       image_13.frameNStart = frameN;  // exact frame index
       
       image_13.setAutoDraw(true);
     }
 
     frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((image_13.status === PsychoJS.Status.STARTED || image_13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       image_13.setAutoDraw(false);
     }
     
     // *text_95* updates
     if (t >= 1.75 && text_95.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_95.tStart = t;  // (not accounting for frame time here)
       text_95.frameNStart = frameN;  // exact frame index
       
       text_95.setAutoDraw(true);
     }
 
     frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_95.status === PsychoJS.Status.STARTED || text_95.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_95.setAutoDraw(false);
     }
     
     // *key_resp_21* updates
     if (t >= 1.0 && key_resp_21.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_21.tStart = t;  // (not accounting for frame time here)
       key_resp_21.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_21.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_21.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_21.clearEvents(); });
     }
 
     frameRemains = 1.0 + 1.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((key_resp_21.status === PsychoJS.Status.STARTED || key_resp_21.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       key_resp_21.status = PsychoJS.Status.FINISHED;
   }
 
     if (key_resp_21.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_21.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_21_allKeys = _key_resp_21_allKeys.concat(theseKeys);
       if (_key_resp_21_allKeys.length > 0) {
         key_resp_21.keys = _key_resp_21_allKeys[_key_resp_21_allKeys.length - 1].name;  // just the last key pressed
         key_resp_21.rt = _key_resp_21_allKeys[_key_resp_21_allKeys.length - 1].rt;
         // was this correct?
         if (key_resp_21.keys == corAns) {
             key_resp_21.corr = 1;
         } else {
             key_resp_21.corr = 0;
         }
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     var msg_incongruent02;
     var color_msg_incongruent02;
     
     console.log("hf_congruent02")
     console.log(nCorrhf01)
     if (nCorrhf01 > 2) {
         console.log("true")
         continueRoutine = false; // until we're told otherwise
         } else {
             console.log("false")
             continueRoutine = true;
             }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Practice_trial_congruent_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 var msg_incongruent02;
 var color_msg_incongruent02;
 function Practice_trial_congruent_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Practice_trial_congruent_2'-------
     for (const thisComponent of Practice_trial_congruent_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // was no response the correct answer?!
     if (key_resp_21.keys === undefined) {
       if (['None','none',undefined].includes(corAns)) {
          key_resp_21.corr = 1;  // correct non-response
       } else {
          key_resp_21.corr = 0;  // failed to respond (incorrectly)
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('key_resp_21.keys', key_resp_21.keys);
     psychoJS.experiment.addData('key_resp_21.corr', key_resp_21.corr);
     if (typeof key_resp_21.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_21.rt', key_resp_21.rt);
         routineTimer.reset();
         }
     
     key_resp_21.stop();
       if (key_resp_21.keys === undefined) {
           msg_incongruent02 = 'No Response'
           color_msg_incongruent02 = 'black'
           } else {
           if (key_resp_21.corr > 0){
               msg_incongruent02 = 'Correct'
               color_msg_incongruent02 = 'green'
           } else {
               msg_incongruent02 = 'Incorrect'
               color_msg_incongruent02 = 'red'
           }
           }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var feedback_hf_congruent_2Components;
 function feedback_hf_congruent_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'feedback_hf_congruent_2'-------
     t = 0;
     feedback_hf_congruent_2Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(1.500000);
     // update component parameters for each repeat
     text_114.setColor(new util.Color(color_msg_incongruent02));
     text_114.setText(msg_incongruent02);
     // keep track of which components have finished
     feedback_hf_congruent_2Components = [];
     feedback_hf_congruent_2Components.push(white_background_34);
     feedback_hf_congruent_2Components.push(text_114);
     
     for (const thisComponent of feedback_hf_congruent_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_hf_congruent_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'feedback_hf_congruent_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = feedback_hf_congruent_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_34* updates
     if (t >= 0.0 && white_background_34.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_34.tStart = t;  // (not accounting for frame time here)
       white_background_34.frameNStart = frameN;  // exact frame index
       
       white_background_34.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_34.status === PsychoJS.Status.STARTED || white_background_34.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_34.setAutoDraw(false);
     }
     
     // *text_114* updates
     if (t >= 0.0 && text_114.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_114.tStart = t;  // (not accounting for frame time here)
       text_114.frameNStart = frameN;  // exact frame index
       
       text_114.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_114.status === PsychoJS.Status.STARTED || text_114.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_114.setAutoDraw(false);
     }
     console.log("hf_congruent02")
     console.log(nCorrhf01)
     if (nCorrhf01 > 2) {
         console.log("true")
         continueRoutine = false; // until we're told otherwise
         } else {
             console.log("false")
             continueRoutine = true;
             }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of feedback_hf_congruent_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_hf_congruent_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'feedback_hf_congruent_2'-------
     for (const thisComponent of feedback_hf_congruent_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_15_allKeys;
 var ReadyComponents;
 function ReadyRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Ready'-------
     t = 0;
     ReadyClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_15.keys = undefined;
     key_resp_15.rt = undefined;
     _key_resp_15_allKeys = [];
     // keep track of which components have finished
     ReadyComponents = [];
     ReadyComponents.push(white_background_30);
     ReadyComponents.push(text_29);
     ReadyComponents.push(key_resp_15);
     ReadyComponents.push(text_30);
     
     for (const thisComponent of ReadyComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function ReadyRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Ready'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = ReadyClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_30* updates
     if (t >= 0.0 && white_background_30.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_30.tStart = t;  // (not accounting for frame time here)
       white_background_30.frameNStart = frameN;  // exact frame index
       
       white_background_30.setAutoDraw(true);
     }
 
     
     // *text_29* updates
     if (t >= 0.0 && text_29.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_29.tStart = t;  // (not accounting for frame time here)
       text_29.frameNStart = frameN;  // exact frame index
       
       text_29.setAutoDraw(true);
     }
 
     
     // *key_resp_15* updates
     if (t >= 0.0 && key_resp_15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_15.tStart = t;  // (not accounting for frame time here)
       key_resp_15.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_15.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_15.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_15.clearEvents(); });
     }
 
     if (key_resp_15.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_15.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_15_allKeys = _key_resp_15_allKeys.concat(theseKeys);
       if (_key_resp_15_allKeys.length > 0) {
         key_resp_15.keys = _key_resp_15_allKeys[_key_resp_15_allKeys.length - 1].name;  // just the last key pressed
         key_resp_15.rt = _key_resp_15_allKeys[_key_resp_15_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_30* updates
     if (t >= 0.0 && text_30.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_30.tStart = t;  // (not accounting for frame time here)
       text_30.frameNStart = frameN;  // exact frame index
       
       text_30.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of ReadyComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function ReadyRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Ready'-------
     for (const thisComponent of ReadyComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_15.keys', key_resp_15.keys);
     if (typeof key_resp_15.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_15.rt', key_resp_15.rt);
         routineTimer.reset();
         }
     
     key_resp_15.stop();
     // the Routine "Ready" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _heart_resp_allKeys;
 var HeartsComponents;
 function HeartsRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Hearts'-------
     t = 0;
     HeartsClock.reset(); // clock
     frameN = -1;
     routineTimer.add(2.250000);
     // update component parameters for each repeat
     hearts.setImage(Hearts);
     heart_resp.keys = undefined;
     heart_resp.rt = undefined;
     _heart_resp_allKeys = [];
     // keep track of which components have finished
     HeartsComponents = [];
     HeartsComponents.push(white_background_6);
     HeartsComponents.push(text_23);
     HeartsComponents.push(text_65);
     HeartsComponents.push(hearts);
     HeartsComponents.push(text_31);
     HeartsComponents.push(heart_resp);
     
     for (const thisComponent of HeartsComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function HeartsRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Hearts'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = HeartsClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_6* updates
     if (t >= 0.0 && white_background_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_6.tStart = t;  // (not accounting for frame time here)
       white_background_6.frameNStart = frameN;  // exact frame index
       
       white_background_6.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_6.status === PsychoJS.Status.STARTED || white_background_6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_6.setAutoDraw(false);
     }
     
     // *text_23* updates
     if (t >= 0 && text_23.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_23.tStart = t;  // (not accounting for frame time here)
       text_23.frameNStart = frameN;  // exact frame index
       
       text_23.setAutoDraw(true);
     }
 
     frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_23.status === PsychoJS.Status.STARTED || text_23.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_23.setAutoDraw(false);
     }
     
     // *text_65* updates
     if (t >= 0.5 && text_65.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_65.tStart = t;  // (not accounting for frame time here)
       text_65.frameNStart = frameN;  // exact frame index
       
       text_65.setAutoDraw(true);
     }
 
     frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_65.status === PsychoJS.Status.STARTED || text_65.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_65.setAutoDraw(false);
     }
     
     // *hearts* updates
     if (t >= 1.0 && hearts.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       hearts.tStart = t;  // (not accounting for frame time here)
       hearts.frameNStart = frameN;  // exact frame index
       
       hearts.setAutoDraw(true);
     }
 
     frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((hearts.status === PsychoJS.Status.STARTED || hearts.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       hearts.setAutoDraw(false);
     }
     
     // *text_31* updates
     if (t >= 1.75 && text_31.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_31.tStart = t;  // (not accounting for frame time here)
       text_31.frameNStart = frameN;  // exact frame index
       
       text_31.setAutoDraw(true);
     }
 
     frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_31.status === PsychoJS.Status.STARTED || text_31.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_31.setAutoDraw(false);
     }
     
     // *heart_resp* updates
     if (t >= 1.0 && heart_resp.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       heart_resp.tStart = t;  // (not accounting for frame time here)
       heart_resp.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { heart_resp.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { heart_resp.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { heart_resp.clearEvents(); });
     }
 
     frameRemains = 1.0 + 1.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((heart_resp.status === PsychoJS.Status.STARTED || heart_resp.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       heart_resp.status = PsychoJS.Status.FINISHED;
   }
 
     if (heart_resp.status === PsychoJS.Status.STARTED) {
       let theseKeys = heart_resp.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _heart_resp_allKeys = _heart_resp_allKeys.concat(theseKeys);
       if (_heart_resp_allKeys.length > 0) {
         heart_resp.keys = _heart_resp_allKeys[_heart_resp_allKeys.length - 1].name;  // just the last key pressed
         heart_resp.rt = _heart_resp_allKeys[_heart_resp_allKeys.length - 1].rt;
         // was this correct?
         if (heart_resp.keys == corAns) {
             heart_resp.corr = 1;
         } else {
             heart_resp.corr = 0;
         }
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of HeartsComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function HeartsRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Hearts'-------
     for (const thisComponent of HeartsComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // was no response the correct answer?!
     if (heart_resp.keys === undefined) {
       if (['None','none',undefined].includes(corAns)) {
          heart_resp.corr = 1;  // correct non-response
       } else {
          heart_resp.corr = 0;  // failed to respond (incorrectly)
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('heart_resp.keys', heart_resp.keys);
     psychoJS.experiment.addData('heart_resp.corr', heart_resp.corr);
     if (typeof heart_resp.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('heart_resp.rt', heart_resp.rt);
         routineTimer.reset();
         }
     
     heart_resp.stop();
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_16_allKeys;
 var IntroA_3Components;
 function IntroA_3RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'IntroA_3'-------
     t = 0;
     IntroA_3Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_16.keys = undefined;
     key_resp_16.rt = undefined;
     _key_resp_16_allKeys = [];
     // keep track of which components have finished
     IntroA_3Components = [];
     IntroA_3Components.push(white_background_26);
     IntroA_3Components.push(text_32);
     IntroA_3Components.push(key_resp_16);
     IntroA_3Components.push(text_33);
     IntroA_3Components.push(image_12);
     
     for (const thisComponent of IntroA_3Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroA_3RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'IntroA_3'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = IntroA_3Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_26* updates
     if (t >= 0.0 && white_background_26.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_26.tStart = t;  // (not accounting for frame time here)
       white_background_26.frameNStart = frameN;  // exact frame index
       
       white_background_26.setAutoDraw(true);
     }
 
     
     // *text_32* updates
     if (t >= 0.0 && text_32.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_32.tStart = t;  // (not accounting for frame time here)
       text_32.frameNStart = frameN;  // exact frame index
       
       text_32.setAutoDraw(true);
     }
 
     
     // *key_resp_16* updates
     if (t >= 0.0 && key_resp_16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_16.tStart = t;  // (not accounting for frame time here)
       key_resp_16.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_16.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_16.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_16.clearEvents(); });
     }
 
     if (key_resp_16.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_16.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_16_allKeys = _key_resp_16_allKeys.concat(theseKeys);
       if (_key_resp_16_allKeys.length > 0) {
         key_resp_16.keys = _key_resp_16_allKeys[_key_resp_16_allKeys.length - 1].name;  // just the last key pressed
         key_resp_16.rt = _key_resp_16_allKeys[_key_resp_16_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_33* updates
     if (t >= 0.0 && text_33.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_33.tStart = t;  // (not accounting for frame time here)
       text_33.frameNStart = frameN;  // exact frame index
       
       text_33.setAutoDraw(true);
     }
 
     
     // *image_12* updates
     if (t >= 0.0 && image_12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_12.tStart = t;  // (not accounting for frame time here)
       image_12.frameNStart = frameN;  // exact frame index
       
       image_12.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of IntroA_3Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroA_3RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'IntroA_3'-------
     for (const thisComponent of IntroA_3Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_16.keys', key_resp_16.keys);
     if (typeof key_resp_16.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_16.rt', key_resp_16.rt);
         routineTimer.reset();
         }
     
     key_resp_16.stop();
     // the Routine "IntroA_3" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_17_allKeys;
 var IntroB_3Components;
 function IntroB_3RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'IntroB_3'-------
     t = 0;
     IntroB_3Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_17.keys = undefined;
     key_resp_17.rt = undefined;
     _key_resp_17_allKeys = [];
     // keep track of which components have finished
     IntroB_3Components = [];
     IntroB_3Components.push(white_background_20);
     IntroB_3Components.push(text_47);
     IntroB_3Components.push(text_34);
     IntroB_3Components.push(key_resp_17);
     
     for (const thisComponent of IntroB_3Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroB_3RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'IntroB_3'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = IntroB_3Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_20* updates
     if (t >= 0.0 && white_background_20.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_20.tStart = t;  // (not accounting for frame time here)
       white_background_20.frameNStart = frameN;  // exact frame index
       
       white_background_20.setAutoDraw(true);
     }
 
     
     // *text_47* updates
     if (t >= 0.0 && text_47.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_47.tStart = t;  // (not accounting for frame time here)
       text_47.frameNStart = frameN;  // exact frame index
       
       text_47.setAutoDraw(true);
     }
 
     
     // *text_34* updates
     if (t >= 0.0 && text_34.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_34.tStart = t;  // (not accounting for frame time here)
       text_34.frameNStart = frameN;  // exact frame index
       
       text_34.setAutoDraw(true);
     }
 
     
     // *key_resp_17* updates
     if (t >= 0.0 && key_resp_17.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_17.tStart = t;  // (not accounting for frame time here)
       key_resp_17.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_17.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_17.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_17.clearEvents(); });
     }
 
     if (key_resp_17.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_17.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_17_allKeys = _key_resp_17_allKeys.concat(theseKeys);
       if (_key_resp_17_allKeys.length > 0) {
         key_resp_17.keys = _key_resp_17_allKeys[_key_resp_17_allKeys.length - 1].name;  // just the last key pressed
         key_resp_17.rt = _key_resp_17_allKeys[_key_resp_17_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of IntroB_3Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroB_3RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'IntroB_3'-------
     for (const thisComponent of IntroB_3Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_17.keys', key_resp_17.keys);
     if (typeof key_resp_17.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_17.rt', key_resp_17.rt);
         routineTimer.reset();
         }
     
     key_resp_17.stop();
     // the Routine "IntroB_3" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_18_allKeys;
 var Example3Components;
 function Example3RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Example3'-------
     t = 0;
     Example3Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_18.keys = undefined;
     key_resp_18.rt = undefined;
     _key_resp_18_allKeys = [];
     // keep track of which components have finished
     Example3Components = [];
     Example3Components.push(white_background_13);
     Example3Components.push(text_35);
     Example3Components.push(image_6);
     Example3Components.push(key_resp_18);
     Example3Components.push(text_62);
     
     for (const thisComponent of Example3Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Example3RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Example3'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Example3Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_13* updates
     if (t >= 0.0 && white_background_13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_13.tStart = t;  // (not accounting for frame time here)
       white_background_13.frameNStart = frameN;  // exact frame index
       
       white_background_13.setAutoDraw(true);
     }
 
     
     // *text_35* updates
     if (t >= 0.0 && text_35.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_35.tStart = t;  // (not accounting for frame time here)
       text_35.frameNStart = frameN;  // exact frame index
       
       text_35.setAutoDraw(true);
     }
 
     
     // *image_6* updates
     if (t >= 0.0 && image_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_6.tStart = t;  // (not accounting for frame time here)
       image_6.frameNStart = frameN;  // exact frame index
       
       image_6.setAutoDraw(true);
     }
 
     
     // *key_resp_18* updates
     if (t >= 0.0 && key_resp_18.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_18.tStart = t;  // (not accounting for frame time here)
       key_resp_18.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_18.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_18.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_18.clearEvents(); });
     }
 
     if (key_resp_18.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_18.getKeys({keyList: ['z'], waitRelease: false});
       _key_resp_18_allKeys = _key_resp_18_allKeys.concat(theseKeys);
       if (_key_resp_18_allKeys.length > 0) {
         key_resp_18.keys = _key_resp_18_allKeys[_key_resp_18_allKeys.length - 1].name;  // just the last key pressed
         key_resp_18.rt = _key_resp_18_allKeys[_key_resp_18_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_62* updates
     if (t >= 0.0 && text_62.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_62.tStart = t;  // (not accounting for frame time here)
       text_62.frameNStart = frameN;  // exact frame index
       
       text_62.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Example3Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Example3RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Example3'-------
     for (const thisComponent of Example3Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_18.keys', key_resp_18.keys);
     if (typeof key_resp_18.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_18.rt', key_resp_18.rt);
         routineTimer.reset();
         }
     
     key_resp_18.stop();
     // the Routine "Example3" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_19_allKeys;
 var Example4Components;
 function Example4RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Example4'-------
     t = 0;
     Example4Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_19.keys = undefined;
     key_resp_19.rt = undefined;
     _key_resp_19_allKeys = [];
     // keep track of which components have finished
     Example4Components = [];
     Example4Components.push(white_background_11);
     Example4Components.push(text_36);
     Example4Components.push(image_7);
     Example4Components.push(key_resp_19);
     Example4Components.push(text_63);
     
     for (const thisComponent of Example4Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Example4RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Example4'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Example4Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_11* updates
     if (t >= 0.0 && white_background_11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_11.tStart = t;  // (not accounting for frame time here)
       white_background_11.frameNStart = frameN;  // exact frame index
       
       white_background_11.setAutoDraw(true);
     }
 
     
     // *text_36* updates
     if (t >= 0.0 && text_36.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_36.tStart = t;  // (not accounting for frame time here)
       text_36.frameNStart = frameN;  // exact frame index
       
       text_36.setAutoDraw(true);
     }
 
     
     // *image_7* updates
     if (t >= 0.0 && image_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_7.tStart = t;  // (not accounting for frame time here)
       image_7.frameNStart = frameN;  // exact frame index
       
       image_7.setAutoDraw(true);
     }
 
     
     // *key_resp_19* updates
     if (t >= 0.0 && key_resp_19.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_19.tStart = t;  // (not accounting for frame time here)
       key_resp_19.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_19.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_19.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_19.clearEvents(); });
     }
 
     if (key_resp_19.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_19.getKeys({keyList: ['m'], waitRelease: false});
       _key_resp_19_allKeys = _key_resp_19_allKeys.concat(theseKeys);
       if (_key_resp_19_allKeys.length > 0) {
         key_resp_19.keys = _key_resp_19_allKeys[_key_resp_19_allKeys.length - 1].name;  // just the last key pressed
         key_resp_19.rt = _key_resp_19_allKeys[_key_resp_19_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_63* updates
     if (t >= 0.0 && text_63.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_63.tStart = t;  // (not accounting for frame time here)
       text_63.frameNStart = frameN;  // exact frame index
       
       text_63.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Example4Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Example4RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Example4'-------
     for (const thisComponent of Example4Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_19.keys', key_resp_19.keys);
     if (typeof key_resp_19.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_19.rt', key_resp_19.rt);
         routineTimer.reset();
         }
     
     key_resp_19.stop();
     // the Routine "Example4" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_34_allKeys;
 var Quick_Reminder_IncongruentComponents;
 function Quick_Reminder_IncongruentRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Quick_Reminder_Incongruent'-------
     t = 0;
     Quick_Reminder_IncongruentClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_34.keys = undefined;
     key_resp_34.rt = undefined;
     _key_resp_34_allKeys = [];
     // keep track of which components have finished
     Quick_Reminder_IncongruentComponents = [];
     Quick_Reminder_IncongruentComponents.push(white_background_28);
     Quick_Reminder_IncongruentComponents.push(text_75);
     Quick_Reminder_IncongruentComponents.push(key_resp_34);
     Quick_Reminder_IncongruentComponents.push(text_76);
     
     for (const thisComponent of Quick_Reminder_IncongruentComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Quick_Reminder_IncongruentRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Quick_Reminder_Incongruent'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Quick_Reminder_IncongruentClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_28* updates
     if (t >= 0.0 && white_background_28.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_28.tStart = t;  // (not accounting for frame time here)
       white_background_28.frameNStart = frameN;  // exact frame index
       
       white_background_28.setAutoDraw(true);
     }
 
     
     // *text_75* updates
     if (t >= 0.0 && text_75.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_75.tStart = t;  // (not accounting for frame time here)
       text_75.frameNStart = frameN;  // exact frame index
       
       text_75.setAutoDraw(true);
     }
 
     
     // *key_resp_34* updates
     if (t >= 0.0 && key_resp_34.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_34.tStart = t;  // (not accounting for frame time here)
       key_resp_34.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_34.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_34.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_34.clearEvents(); });
     }
 
     if (key_resp_34.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_34.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_34_allKeys = _key_resp_34_allKeys.concat(theseKeys);
       if (_key_resp_34_allKeys.length > 0) {
         key_resp_34.keys = _key_resp_34_allKeys[_key_resp_34_allKeys.length - 1].name;  // just the last key pressed
         key_resp_34.rt = _key_resp_34_allKeys[_key_resp_34_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_76* updates
     if (t >= 0.0 && text_76.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_76.tStart = t;  // (not accounting for frame time here)
       text_76.frameNStart = frameN;  // exact frame index
       
       text_76.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Quick_Reminder_IncongruentComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Quick_Reminder_IncongruentRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Quick_Reminder_Incongruent'-------
     for (const thisComponent of Quick_Reminder_IncongruentComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_34.keys', key_resp_34.keys);
     if (typeof key_resp_34.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_34.rt', key_resp_34.rt);
         routineTimer.reset();
         }
     
     key_resp_34.stop();
     // the Routine "Quick_Reminder_Incongruent" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_20_allKeys;
 var Practice_IncongruentComponents;
 function Practice_IncongruentRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Practice_Incongruent'-------
     t = 0;
     Practice_IncongruentClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_20.keys = undefined;
     key_resp_20.rt = undefined;
     _key_resp_20_allKeys = [];
     // keep track of which components have finished
     Practice_IncongruentComponents = [];
     Practice_IncongruentComponents.push(white_background_8);
     Practice_IncongruentComponents.push(text_37);
     Practice_IncongruentComponents.push(text_38);
     Practice_IncongruentComponents.push(key_resp_20);
     
     for (const thisComponent of Practice_IncongruentComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Practice_IncongruentRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Practice_Incongruent'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Practice_IncongruentClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_8* updates
     if (t >= 0.0 && white_background_8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_8.tStart = t;  // (not accounting for frame time here)
       white_background_8.frameNStart = frameN;  // exact frame index
       
       white_background_8.setAutoDraw(true);
     }
 
     
     // *text_37* updates
     if (t >= 0.0 && text_37.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_37.tStart = t;  // (not accounting for frame time here)
       text_37.frameNStart = frameN;  // exact frame index
       
       text_37.setAutoDraw(true);
     }
 
     
     // *text_38* updates
     if (t >= 0.0 && text_38.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_38.tStart = t;  // (not accounting for frame time here)
       text_38.frameNStart = frameN;  // exact frame index
       
       text_38.setAutoDraw(true);
     }
 
     
     // *key_resp_20* updates
     if (t >= 0.0 && key_resp_20.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_20.tStart = t;  // (not accounting for frame time here)
       key_resp_20.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_20.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_20.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_20.clearEvents(); });
     }
 
     if (key_resp_20.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_20.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_20_allKeys = _key_resp_20_allKeys.concat(theseKeys);
       if (_key_resp_20_allKeys.length > 0) {
         key_resp_20.keys = _key_resp_20_allKeys[_key_resp_20_allKeys.length - 1].name;  // just the last key pressed
         key_resp_20.rt = _key_resp_20_allKeys[_key_resp_20_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Practice_IncongruentComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Practice_IncongruentRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Practice_Incongruent'-------
     for (const thisComponent of Practice_IncongruentComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_20.keys', key_resp_20.keys);
     if (typeof key_resp_20.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_20.rt', key_resp_20.rt);
         routineTimer.reset();
         }
     
     key_resp_20.stop();
     // the Routine "Practice_Incongruent" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_22_allKeys;
 var Practice_trial_incongruentComponents;
 function Practice_trial_incongruentRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Practice_trial_incongruent'-------
     t = 0;
     Practice_trial_incongruentClock.reset(); // clock
     frameN = -1;
     routineTimer.add(2.250000);
     // update component parameters for each repeat
     image_8.setImage(Flowers);
     key_resp_22.keys = undefined;
     key_resp_22.rt = undefined;
     _key_resp_22_allKeys = [];
     var msg_incongruent01;
     var color_msg_incongruent01;
     
     // keep track of which components have finished
     Practice_trial_incongruentComponents = [];
     Practice_trial_incongruentComponents.push(white_background_22);
     Practice_trial_incongruentComponents.push(text_39);
     Practice_trial_incongruentComponents.push(text_66);
     Practice_trial_incongruentComponents.push(image_8);
     Practice_trial_incongruentComponents.push(text_48);
     Practice_trial_incongruentComponents.push(key_resp_22);
     
     for (const thisComponent of Practice_trial_incongruentComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Practice_trial_incongruentRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Practice_trial_incongruent'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Practice_trial_incongruentClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_22* updates
     if (t >= 0.0 && white_background_22.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_22.tStart = t;  // (not accounting for frame time here)
       white_background_22.frameNStart = frameN;  // exact frame index
       
       white_background_22.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_22.status === PsychoJS.Status.STARTED || white_background_22.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_22.setAutoDraw(false);
     }
     
     // *text_39* updates
     if (t >= 0.0 && text_39.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_39.tStart = t;  // (not accounting for frame time here)
       text_39.frameNStart = frameN;  // exact frame index
       
       text_39.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_39.status === PsychoJS.Status.STARTED || text_39.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_39.setAutoDraw(false);
     }
     
     // *text_66* updates
     if (t >= 0.5 && text_66.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_66.tStart = t;  // (not accounting for frame time here)
       text_66.frameNStart = frameN;  // exact frame index
       
       text_66.setAutoDraw(true);
     }
 
     frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_66.status === PsychoJS.Status.STARTED || text_66.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_66.setAutoDraw(false);
     }
     
     // *image_8* updates
     if (t >= 1.0 && image_8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_8.tStart = t;  // (not accounting for frame time here)
       image_8.frameNStart = frameN;  // exact frame index
       
       image_8.setAutoDraw(true);
     }
 
     frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((image_8.status === PsychoJS.Status.STARTED || image_8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       image_8.setAutoDraw(false);
     }
     
     // *text_48* updates
     if (t >= 1.75 && text_48.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_48.tStart = t;  // (not accounting for frame time here)
       text_48.frameNStart = frameN;  // exact frame index
       
       text_48.setAutoDraw(true);
     }
 
     frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_48.status === PsychoJS.Status.STARTED || text_48.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_48.setAutoDraw(false);
     }
     
     // *key_resp_22* updates
     if (t >= 1.0 && key_resp_22.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_22.tStart = t;  // (not accounting for frame time here)
       key_resp_22.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_22.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_22.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_22.clearEvents(); });
     }
 
     frameRemains = 1.0 + 1.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((key_resp_22.status === PsychoJS.Status.STARTED || key_resp_22.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       key_resp_22.status = PsychoJS.Status.FINISHED;
   }
 
     if (key_resp_22.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_22.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_22_allKeys = _key_resp_22_allKeys.concat(theseKeys);
       if (_key_resp_22_allKeys.length > 0) {
         key_resp_22.keys = _key_resp_22_allKeys[_key_resp_22_allKeys.length - 1].name;  // just the last key pressed
         key_resp_22.rt = _key_resp_22_allKeys[_key_resp_22_allKeys.length - 1].rt;
         // was this correct?
         if (key_resp_22.keys == corAns) {
             key_resp_22.corr = 1;
         } else {
             key_resp_22.corr = 0;
         }
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Practice_trial_incongruentComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Practice_trial_incongruentRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Practice_trial_incongruent'-------
     for (const thisComponent of Practice_trial_incongruentComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // was no response the correct answer?!
     if (key_resp_22.keys === undefined) {
       if (['None','none',undefined].includes(corAns)) {
          key_resp_22.corr = 1;  // correct non-response
       } else {
          key_resp_22.corr = 0;  // failed to respond (incorrectly)
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('key_resp_22.keys', key_resp_22.keys);
     psychoJS.experiment.addData('key_resp_22.corr', key_resp_22.corr);
     if (typeof key_resp_22.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_22.rt', key_resp_22.rt);
         routineTimer.reset();
         }
     
     key_resp_22.stop();
       if (key_resp_22.keys === undefined) {
           msg_incongruent01 = 'No Response'
           color_msg_incongruent01 = 'black'
           } else {
           if (key_resp_22.corr > 0){
               msg_incongruent01 = 'Correct'
               color_msg_incongruent01 = 'green'
           } else {
               msg_incongruent01 = 'Incorrect'
               color_msg_incongruent01 = 'red'
           }
           }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var feedback_hf_incongruent_1Components;
 function feedback_hf_incongruent_1RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'feedback_hf_incongruent_1'-------
     t = 0;
     feedback_hf_incongruent_1Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(1.500000);
     // update component parameters for each repeat
     text_113.setColor(new util.Color(color_msg_incongruent01));
     text_113.setText(msg_incongruent01);
     // keep track of which components have finished
     feedback_hf_incongruent_1Components = [];
     feedback_hf_incongruent_1Components.push(white_background_38);
     feedback_hf_incongruent_1Components.push(text_113);
     
     for (const thisComponent of feedback_hf_incongruent_1Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_hf_incongruent_1RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'feedback_hf_incongruent_1'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = feedback_hf_incongruent_1Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_38* updates
     if (t >= 0.0 && white_background_38.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_38.tStart = t;  // (not accounting for frame time here)
       white_background_38.frameNStart = frameN;  // exact frame index
       
       white_background_38.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_38.status === PsychoJS.Status.STARTED || white_background_38.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_38.setAutoDraw(false);
     }
     
     // *text_113* updates
     if (t >= 0.0 && text_113.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_113.tStart = t;  // (not accounting for frame time here)
       text_113.frameNStart = frameN;  // exact frame index
       
       text_113.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_113.status === PsychoJS.Status.STARTED || text_113.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_113.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of feedback_hf_incongruent_1Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_hf_incongruent_1RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'feedback_hf_incongruent_1'-------
     for (const thisComponent of feedback_hf_incongruent_1Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_38_allKeys;
 var nCorrhf02;
 var incongruent_reminderComponents;
 function incongruent_reminderRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'incongruent_reminder'-------
     t = 0;
     incongruent_reminderClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_38.keys = undefined;
     key_resp_38.rt = undefined;
     _key_resp_38_allKeys = [];
     nCorrhf02 = 0;
     console.log("hf_incongruent02")
     console.log(nCorrhf02)
       for (eachResp=0; eachResp<psychoJS.experiment._trialsData.length; eachResp++){
         if ('key_resp_22.corr' in psychoJS.experiment._trialsData[eachResp]) {
         nCorrhf02 += psychoJS.experiment._trialsData[eachResp]['key_resp_22.corr'];
         }
       }
     
     
     
     // keep track of which components have finished
     incongruent_reminderComponents = [];
     incongruent_reminderComponents.push(white_background_42);
     incongruent_reminderComponents.push(text_104);
     incongruent_reminderComponents.push(text_105);
     incongruent_reminderComponents.push(key_resp_38);
     
     for (const thisComponent of incongruent_reminderComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function incongruent_reminderRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'incongruent_reminder'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = incongruent_reminderClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_42* updates
     if (t >= 0.0 && white_background_42.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_42.tStart = t;  // (not accounting for frame time here)
       white_background_42.frameNStart = frameN;  // exact frame index
       
       white_background_42.setAutoDraw(true);
     }
 
     
     // *text_104* updates
     if (t >= 0.0 && text_104.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_104.tStart = t;  // (not accounting for frame time here)
       text_104.frameNStart = frameN;  // exact frame index
       
       text_104.setAutoDraw(true);
     }
 
     
     // *text_105* updates
     if (t >= 0.0 && text_105.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_105.tStart = t;  // (not accounting for frame time here)
       text_105.frameNStart = frameN;  // exact frame index
       
       text_105.setAutoDraw(true);
     }
 
     
     // *key_resp_38* updates
     if (t >= 0.0 && key_resp_38.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_38.tStart = t;  // (not accounting for frame time here)
       key_resp_38.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_38.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_38.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_38.clearEvents(); });
     }
 
     if (key_resp_38.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_38.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_38_allKeys = _key_resp_38_allKeys.concat(theseKeys);
       if (_key_resp_38_allKeys.length > 0) {
         key_resp_38.keys = _key_resp_38_allKeys[_key_resp_38_allKeys.length - 1].name;  // just the last key pressed
         key_resp_38.rt = _key_resp_38_allKeys[_key_resp_38_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     console.log("hf_incongruent02")
     console.log(nCorrhf02)
     if (nCorrhf02 > 2) {
         console.log("true")
         continueRoutine = false; // until we're told otherwise
         } 
     else if (key_resp_38.keys === 'space') {
         continueRoutine = false; // until we're told otherwise
             }
     else {
         console.log("false")
         continueRoutine = true;
         }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of incongruent_reminderComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function incongruent_reminderRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'incongruent_reminder'-------
     for (const thisComponent of incongruent_reminderComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_38.keys', key_resp_38.keys);
     if (typeof key_resp_38.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_38.rt', key_resp_38.rt);
         routineTimer.reset();
         }
     
     key_resp_38.stop();
     if (key_resp_38.keys === 'space') {
         continueRoutine = false; // until we're told otherwise
             }
     // the Routine "incongruent_reminder" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_23_allKeys;
 var Practice_trial_incongruent_2Components;
 function Practice_trial_incongruent_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Practice_trial_incongruent_2'-------
     t = 0;
     Practice_trial_incongruent_2Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(2.250000);
     // update component parameters for each repeat
     image_14.setImage(Flowers);
     key_resp_23.keys = undefined;
     key_resp_23.rt = undefined;
     _key_resp_23_allKeys = [];
     var msg_incongruent02; 
     var color_msg_incongruent02 ;
     
     console.log("hf_incongruent02")
     console.log(nCorrhf02)
     
     // keep track of which components have finished
     Practice_trial_incongruent_2Components = [];
     Practice_trial_incongruent_2Components.push(white_background_35);
     Practice_trial_incongruent_2Components.push(text_96);
     Practice_trial_incongruent_2Components.push(text_97);
     Practice_trial_incongruent_2Components.push(image_14);
     Practice_trial_incongruent_2Components.push(text_98);
     Practice_trial_incongruent_2Components.push(key_resp_23);
     
     for (const thisComponent of Practice_trial_incongruent_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Practice_trial_incongruent_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Practice_trial_incongruent_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Practice_trial_incongruent_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_35* updates
     if (t >= 0.0 && white_background_35.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_35.tStart = t;  // (not accounting for frame time here)
       white_background_35.frameNStart = frameN;  // exact frame index
       
       white_background_35.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_35.status === PsychoJS.Status.STARTED || white_background_35.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_35.setAutoDraw(false);
     }
     
     // *text_96* updates
     if (t >= 0.0 && text_96.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_96.tStart = t;  // (not accounting for frame time here)
       text_96.frameNStart = frameN;  // exact frame index
       
       text_96.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_96.status === PsychoJS.Status.STARTED || text_96.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_96.setAutoDraw(false);
     }
     
     // *text_97* updates
     if (t >= 0.5 && text_97.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_97.tStart = t;  // (not accounting for frame time here)
       text_97.frameNStart = frameN;  // exact frame index
       
       text_97.setAutoDraw(true);
     }
 
     frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_97.status === PsychoJS.Status.STARTED || text_97.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_97.setAutoDraw(false);
     }
     
     // *image_14* updates
     if (t >= 1.0 && image_14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_14.tStart = t;  // (not accounting for frame time here)
       image_14.frameNStart = frameN;  // exact frame index
       
       image_14.setAutoDraw(true);
     }
 
     frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((image_14.status === PsychoJS.Status.STARTED || image_14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       image_14.setAutoDraw(false);
     }
     
     // *text_98* updates
     if (t >= 1.75 && text_98.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_98.tStart = t;  // (not accounting for frame time here)
       text_98.frameNStart = frameN;  // exact frame index
       
       text_98.setAutoDraw(true);
     }
 
     frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_98.status === PsychoJS.Status.STARTED || text_98.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_98.setAutoDraw(false);
     }
     
     // *key_resp_23* updates
     if (t >= 1.0 && key_resp_23.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_23.tStart = t;  // (not accounting for frame time here)
       key_resp_23.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_23.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_23.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_23.clearEvents(); });
     }
 
     frameRemains = 1.0 + 1.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((key_resp_23.status === PsychoJS.Status.STARTED || key_resp_23.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       key_resp_23.status = PsychoJS.Status.FINISHED;
   }
 
     if (key_resp_23.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_23.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_23_allKeys = _key_resp_23_allKeys.concat(theseKeys);
       if (_key_resp_23_allKeys.length > 0) {
         key_resp_23.keys = _key_resp_23_allKeys[_key_resp_23_allKeys.length - 1].name;  // just the last key pressed
         key_resp_23.rt = _key_resp_23_allKeys[_key_resp_23_allKeys.length - 1].rt;
         // was this correct?
         if (key_resp_23.keys == corAns) {
             key_resp_23.corr = 1;
         } else {
             key_resp_23.corr = 0;
         }
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     if (nCorrhf02 > 2) {
         console.log("true")
         continueRoutine = false; // until we're told otherwise
         } else {
             console.log("false")
             continueRoutine = true;
             }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Practice_trial_incongruent_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Practice_trial_incongruent_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Practice_trial_incongruent_2'-------
     for (const thisComponent of Practice_trial_incongruent_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // was no response the correct answer?!
     if (key_resp_23.keys === undefined) {
       if (['None','none',undefined].includes(corAns)) {
          key_resp_23.corr = 1;  // correct non-response
       } else {
          key_resp_23.corr = 0;  // failed to respond (incorrectly)
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('key_resp_23.keys', key_resp_23.keys);
     psychoJS.experiment.addData('key_resp_23.corr', key_resp_23.corr);
     if (typeof key_resp_23.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_23.rt', key_resp_23.rt);
         routineTimer.reset();
         }
     
     key_resp_23.stop();
       if (key_resp_23.keys === undefined) {
           msg_incongruent02 = 'No Response'
           color_msg_incongruent02 = 'black'
           } else {
           if (key_resp_23.corr > 0){
               msg_incongruent02 = 'Correct'
               color_msg_incongruent02 = 'green'
           } else {
               msg_incongruent02 = 'Incorrect'
               color_msg_incongruent02 = 'red'
           }
           }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var feedback_hf_incongruent_2Components;
 function feedback_hf_incongruent_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'feedback_hf_incongruent_2'-------
     t = 0;
     feedback_hf_incongruent_2Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(1.500000);
     // update component parameters for each repeat
     text_112.setColor(new util.Color(color_msg_incongruent02));
     text_112.setText(msg_incongruent02);
     console.log("hf_incongruent02")
     console.log(nCorrhf02)
     
     // keep track of which components have finished
     feedback_hf_incongruent_2Components = [];
     feedback_hf_incongruent_2Components.push(white_background_37);
     feedback_hf_incongruent_2Components.push(text_112);
     
     for (const thisComponent of feedback_hf_incongruent_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_hf_incongruent_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'feedback_hf_incongruent_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = feedback_hf_incongruent_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_37* updates
     if (t >= 0.0 && white_background_37.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_37.tStart = t;  // (not accounting for frame time here)
       white_background_37.frameNStart = frameN;  // exact frame index
       
       white_background_37.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_37.status === PsychoJS.Status.STARTED || white_background_37.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_37.setAutoDraw(false);
     }
     
     // *text_112* updates
     if (t >= 0.0 && text_112.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_112.tStart = t;  // (not accounting for frame time here)
       text_112.frameNStart = frameN;  // exact frame index
       
       text_112.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_112.status === PsychoJS.Status.STARTED || text_112.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_112.setAutoDraw(false);
     }
     if (nCorrhf02 > 2) {
         console.log("true")
         continueRoutine = false; // until we're told otherwise
         } else {
             console.log("false")
             continueRoutine = true;
             }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of feedback_hf_incongruent_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_hf_incongruent_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'feedback_hf_incongruent_2'-------
     for (const thisComponent of feedback_hf_incongruent_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_24_allKeys;
 var Ready2Components;
 function Ready2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Ready2'-------
     t = 0;
     Ready2Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_24.keys = undefined;
     key_resp_24.rt = undefined;
     _key_resp_24_allKeys = [];
     // keep track of which components have finished
     Ready2Components = [];
     Ready2Components.push(white_background_3);
     Ready2Components.push(text_49);
     Ready2Components.push(text_50);
     Ready2Components.push(key_resp_24);
     
     for (const thisComponent of Ready2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Ready2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Ready2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Ready2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_3* updates
     if (t >= 0.0 && white_background_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_3.tStart = t;  // (not accounting for frame time here)
       white_background_3.frameNStart = frameN;  // exact frame index
       
       white_background_3.setAutoDraw(true);
     }
 
     
     // *text_49* updates
     if (t >= 0.0 && text_49.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_49.tStart = t;  // (not accounting for frame time here)
       text_49.frameNStart = frameN;  // exact frame index
       
       text_49.setAutoDraw(true);
     }
 
     
     // *text_50* updates
     if (t >= 0.0 && text_50.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_50.tStart = t;  // (not accounting for frame time here)
       text_50.frameNStart = frameN;  // exact frame index
       
       text_50.setAutoDraw(true);
     }
 
     
     // *key_resp_24* updates
     if (t >= 0.0 && key_resp_24.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_24.tStart = t;  // (not accounting for frame time here)
       key_resp_24.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_24.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_24.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_24.clearEvents(); });
     }
 
     if (key_resp_24.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_24.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_24_allKeys = _key_resp_24_allKeys.concat(theseKeys);
       if (_key_resp_24_allKeys.length > 0) {
         key_resp_24.keys = _key_resp_24_allKeys[_key_resp_24_allKeys.length - 1].name;  // just the last key pressed
         key_resp_24.rt = _key_resp_24_allKeys[_key_resp_24_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Ready2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Ready2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Ready2'-------
     for (const thisComponent of Ready2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_24.keys', key_resp_24.keys);
     if (typeof key_resp_24.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_24.rt', key_resp_24.rt);
         routineTimer.reset();
         }
     
     key_resp_24.stop();
     // the Routine "Ready2" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_25_allKeys;
 var FlowersComponents;
 function FlowersRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Flowers'-------
     t = 0;
     FlowersClock.reset(); // clock
     frameN = -1;
     routineTimer.add(2.250000);
     // update component parameters for each repeat
     image.setImage(Flowers);
     key_resp_25.keys = undefined;
     key_resp_25.rt = undefined;
     _key_resp_25_allKeys = [];
     // keep track of which components have finished
     FlowersComponents = [];
     FlowersComponents.push(white_background_16);
     FlowersComponents.push(text_51);
     FlowersComponents.push(text_67);
     FlowersComponents.push(image);
     FlowersComponents.push(text_54);
     FlowersComponents.push(key_resp_25);
     
     for (const thisComponent of FlowersComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function FlowersRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Flowers'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = FlowersClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_16* updates
     if (t >= 0.0 && white_background_16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_16.tStart = t;  // (not accounting for frame time here)
       white_background_16.frameNStart = frameN;  // exact frame index
       
       white_background_16.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_16.status === PsychoJS.Status.STARTED || white_background_16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_16.setAutoDraw(false);
     }
     
     // *text_51* updates
     if (t >= 0.0 && text_51.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_51.tStart = t;  // (not accounting for frame time here)
       text_51.frameNStart = frameN;  // exact frame index
       
       text_51.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_51.status === PsychoJS.Status.STARTED || text_51.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_51.setAutoDraw(false);
     }
     
     // *text_67* updates
     if (t >= 0.5 && text_67.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_67.tStart = t;  // (not accounting for frame time here)
       text_67.frameNStart = frameN;  // exact frame index
       
       text_67.setAutoDraw(true);
     }
 
     frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_67.status === PsychoJS.Status.STARTED || text_67.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_67.setAutoDraw(false);
     }
     
     // *image* updates
     if (t >= 1.0 && image.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image.tStart = t;  // (not accounting for frame time here)
       image.frameNStart = frameN;  // exact frame index
       
       image.setAutoDraw(true);
     }
 
     frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((image.status === PsychoJS.Status.STARTED || image.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       image.setAutoDraw(false);
     }
     
     // *text_54* updates
     if (t >= 1.75 && text_54.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_54.tStart = t;  // (not accounting for frame time here)
       text_54.frameNStart = frameN;  // exact frame index
       
       text_54.setAutoDraw(true);
     }
 
     frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_54.status === PsychoJS.Status.STARTED || text_54.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_54.setAutoDraw(false);
     }
     
     // *key_resp_25* updates
     if (t >= 1.0 && key_resp_25.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_25.tStart = t;  // (not accounting for frame time here)
       key_resp_25.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_25.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_25.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_25.clearEvents(); });
     }
 
     frameRemains = 1.0 + 1.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((key_resp_25.status === PsychoJS.Status.STARTED || key_resp_25.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       key_resp_25.status = PsychoJS.Status.FINISHED;
   }
 
     if (key_resp_25.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_25.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_25_allKeys = _key_resp_25_allKeys.concat(theseKeys);
       if (_key_resp_25_allKeys.length > 0) {
         key_resp_25.keys = _key_resp_25_allKeys[_key_resp_25_allKeys.length - 1].name;  // just the last key pressed
         key_resp_25.rt = _key_resp_25_allKeys[_key_resp_25_allKeys.length - 1].rt;
         // was this correct?
         if (key_resp_25.keys == corAns) {
             key_resp_25.corr = 1;
         } else {
             key_resp_25.corr = 0;
         }
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of FlowersComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function FlowersRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Flowers'-------
     for (const thisComponent of FlowersComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // was no response the correct answer?!
     if (key_resp_25.keys === undefined) {
       if (['None','none',undefined].includes(corAns)) {
          key_resp_25.corr = 1;  // correct non-response
       } else {
          key_resp_25.corr = 0;  // failed to respond (incorrectly)
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('key_resp_25.keys', key_resp_25.keys);
     psychoJS.experiment.addData('key_resp_25.corr', key_resp_25.corr);
     if (typeof key_resp_25.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_25.rt', key_resp_25.rt);
         routineTimer.reset();
         }
     
     key_resp_25.stop();
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_26_allKeys;
 var IntroA_4Components;
 function IntroA_4RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'IntroA_4'-------
     t = 0;
     IntroA_4Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_26.keys = undefined;
     key_resp_26.rt = undefined;
     _key_resp_26_allKeys = [];
     // keep track of which components have finished
     IntroA_4Components = [];
     IntroA_4Components.push(white_background_27);
     IntroA_4Components.push(text_55);
     IntroA_4Components.push(key_resp_26);
     IntroA_4Components.push(text_56);
     
     for (const thisComponent of IntroA_4Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroA_4RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'IntroA_4'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = IntroA_4Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_27* updates
     if (t >= 0.0 && white_background_27.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_27.tStart = t;  // (not accounting for frame time here)
       white_background_27.frameNStart = frameN;  // exact frame index
       
       white_background_27.setAutoDraw(true);
     }
 
     
     // *text_55* updates
     if (t >= 0.0 && text_55.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_55.tStart = t;  // (not accounting for frame time here)
       text_55.frameNStart = frameN;  // exact frame index
       
       text_55.setAutoDraw(true);
     }
 
     
     // *key_resp_26* updates
     if (t >= 0.0 && key_resp_26.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_26.tStart = t;  // (not accounting for frame time here)
       key_resp_26.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_26.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_26.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_26.clearEvents(); });
     }
 
     if (key_resp_26.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_26.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_26_allKeys = _key_resp_26_allKeys.concat(theseKeys);
       if (_key_resp_26_allKeys.length > 0) {
         key_resp_26.keys = _key_resp_26_allKeys[_key_resp_26_allKeys.length - 1].name;  // just the last key pressed
         key_resp_26.rt = _key_resp_26_allKeys[_key_resp_26_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_56* updates
     if (t >= 0.0 && text_56.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_56.tStart = t;  // (not accounting for frame time here)
       text_56.frameNStart = frameN;  // exact frame index
       
       text_56.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of IntroA_4Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroA_4RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'IntroA_4'-------
     for (const thisComponent of IntroA_4Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_26.keys', key_resp_26.keys);
     if (typeof key_resp_26.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_26.rt', key_resp_26.rt);
         routineTimer.reset();
         }
     
     key_resp_26.stop();
     // the Routine "IntroA_4" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_29_allKeys;
 var IntroB_5Components;
 function IntroB_5RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'IntroB_5'-------
     t = 0;
     IntroB_5Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_29.keys = undefined;
     key_resp_29.rt = undefined;
     _key_resp_29_allKeys = [];
     // keep track of which components have finished
     IntroB_5Components = [];
     IntroB_5Components.push(white_background_18);
     IntroB_5Components.push(text_57);
     IntroB_5Components.push(text_58);
     IntroB_5Components.push(key_resp_29);
     
     for (const thisComponent of IntroB_5Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroB_5RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'IntroB_5'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = IntroB_5Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_18* updates
     if (t >= 0.0 && white_background_18.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_18.tStart = t;  // (not accounting for frame time here)
       white_background_18.frameNStart = frameN;  // exact frame index
       
       white_background_18.setAutoDraw(true);
     }
 
     
     // *text_57* updates
     if (t >= 0.0 && text_57.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_57.tStart = t;  // (not accounting for frame time here)
       text_57.frameNStart = frameN;  // exact frame index
       
       text_57.setAutoDraw(true);
     }
 
     
     // *text_58* updates
     if (t >= 0.0 && text_58.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_58.tStart = t;  // (not accounting for frame time here)
       text_58.frameNStart = frameN;  // exact frame index
       
       text_58.setAutoDraw(true);
     }
 
     
     // *key_resp_29* updates
     if (t >= 0.0 && key_resp_29.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_29.tStart = t;  // (not accounting for frame time here)
       key_resp_29.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_29.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_29.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_29.clearEvents(); });
     }
 
     if (key_resp_29.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_29.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_29_allKeys = _key_resp_29_allKeys.concat(theseKeys);
       if (_key_resp_29_allKeys.length > 0) {
         key_resp_29.keys = _key_resp_29_allKeys[_key_resp_29_allKeys.length - 1].name;  // just the last key pressed
         key_resp_29.rt = _key_resp_29_allKeys[_key_resp_29_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of IntroB_5Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroB_5RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'IntroB_5'-------
     for (const thisComponent of IntroB_5Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_29.keys', key_resp_29.keys);
     if (typeof key_resp_29.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_29.rt', key_resp_29.rt);
         routineTimer.reset();
         }
     
     key_resp_29.stop();
     // the Routine "IntroB_5" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_31_allKeys;
 var IntroC_11Components;
 function IntroC_11RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'IntroC_11'-------
     t = 0;
     IntroC_11Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_31.keys = undefined;
     key_resp_31.rt = undefined;
     _key_resp_31_allKeys = [];
     // keep track of which components have finished
     IntroC_11Components = [];
     IntroC_11Components.push(white_background_23);
     IntroC_11Components.push(text_69);
     IntroC_11Components.push(text_70);
     IntroC_11Components.push(key_resp_31);
     
     for (const thisComponent of IntroC_11Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroC_11RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'IntroC_11'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = IntroC_11Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_23* updates
     if (t >= 0.0 && white_background_23.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_23.tStart = t;  // (not accounting for frame time here)
       white_background_23.frameNStart = frameN;  // exact frame index
       
       white_background_23.setAutoDraw(true);
     }
 
     
     // *text_69* updates
     if (t >= 0.0 && text_69.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_69.tStart = t;  // (not accounting for frame time here)
       text_69.frameNStart = frameN;  // exact frame index
       
       text_69.setAutoDraw(true);
     }
 
     
     // *text_70* updates
     if (t >= 0.0 && text_70.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_70.tStart = t;  // (not accounting for frame time here)
       text_70.frameNStart = frameN;  // exact frame index
       
       text_70.setAutoDraw(true);
     }
 
     
     // *key_resp_31* updates
     if (t >= 0.0 && key_resp_31.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_31.tStart = t;  // (not accounting for frame time here)
       key_resp_31.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_31.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_31.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_31.clearEvents(); });
     }
 
     if (key_resp_31.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_31.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_31_allKeys = _key_resp_31_allKeys.concat(theseKeys);
       if (_key_resp_31_allKeys.length > 0) {
         key_resp_31.keys = _key_resp_31_allKeys[_key_resp_31_allKeys.length - 1].name;  // just the last key pressed
         key_resp_31.rt = _key_resp_31_allKeys[_key_resp_31_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of IntroC_11Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroC_11RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'IntroC_11'-------
     for (const thisComponent of IntroC_11Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_31.keys', key_resp_31.keys);
     if (typeof key_resp_31.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_31.rt', key_resp_31.rt);
         routineTimer.reset();
         }
     
     key_resp_31.stop();
     // the Routine "IntroC_11" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_30_allKeys;
 var IntroC_2Components;
 function IntroC_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'IntroC_2'-------
     t = 0;
     IntroC_2Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     text_74.setText("Press 'spacebar' to continue.");
     key_resp_30.keys = undefined;
     key_resp_30.rt = undefined;
     _key_resp_30_allKeys = [];
     // keep track of which components have finished
     IntroC_2Components = [];
     IntroC_2Components.push(white_background_24);
     IntroC_2Components.push(text_73);
     IntroC_2Components.push(text_74);
     IntroC_2Components.push(key_resp_30);
     
     for (const thisComponent of IntroC_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroC_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'IntroC_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = IntroC_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_24* updates
     if (t >= 0.0 && white_background_24.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_24.tStart = t;  // (not accounting for frame time here)
       white_background_24.frameNStart = frameN;  // exact frame index
       
       white_background_24.setAutoDraw(true);
     }
 
     
     // *text_73* updates
     if (t >= 0.0 && text_73.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_73.tStart = t;  // (not accounting for frame time here)
       text_73.frameNStart = frameN;  // exact frame index
       
       text_73.setAutoDraw(true);
     }
 
     
     // *text_74* updates
     if (t >= 0.0 && text_74.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_74.tStart = t;  // (not accounting for frame time here)
       text_74.frameNStart = frameN;  // exact frame index
       
       text_74.setAutoDraw(true);
     }
 
     
     // *key_resp_30* updates
     if (t >= 0.0 && key_resp_30.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_30.tStart = t;  // (not accounting for frame time here)
       key_resp_30.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_30.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_30.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_30.clearEvents(); });
     }
 
     if (key_resp_30.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_30.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_30_allKeys = _key_resp_30_allKeys.concat(theseKeys);
       if (_key_resp_30_allKeys.length > 0) {
         key_resp_30.keys = _key_resp_30_allKeys[_key_resp_30_allKeys.length - 1].name;  // just the last key pressed
         key_resp_30.rt = _key_resp_30_allKeys[_key_resp_30_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of IntroC_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function IntroC_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'IntroC_2'-------
     for (const thisComponent of IntroC_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_30.keys', key_resp_30.keys);
     if (typeof key_resp_30.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_30.rt', key_resp_30.rt);
         routineTimer.reset();
         }
     
     key_resp_30.stop();
     // the Routine "IntroC_2" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_33_allKeys;
 var Quick_Reminder_MixedComponents;
 function Quick_Reminder_MixedRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Quick_Reminder_Mixed'-------
     t = 0;
     Quick_Reminder_MixedClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_33.keys = undefined;
     key_resp_33.rt = undefined;
     _key_resp_33_allKeys = [];
     // keep track of which components have finished
     Quick_Reminder_MixedComponents = [];
     Quick_Reminder_MixedComponents.push(white_background_29);
     Quick_Reminder_MixedComponents.push(text_77);
     Quick_Reminder_MixedComponents.push(key_resp_33);
     Quick_Reminder_MixedComponents.push(text_78);
     
     for (const thisComponent of Quick_Reminder_MixedComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Quick_Reminder_MixedRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Quick_Reminder_Mixed'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Quick_Reminder_MixedClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_29* updates
     if (t >= 0.0 && white_background_29.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_29.tStart = t;  // (not accounting for frame time here)
       white_background_29.frameNStart = frameN;  // exact frame index
       
       white_background_29.setAutoDraw(true);
     }
 
     
     // *text_77* updates
     if (t >= 0.0 && text_77.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_77.tStart = t;  // (not accounting for frame time here)
       text_77.frameNStart = frameN;  // exact frame index
       
       text_77.setAutoDraw(true);
     }
 
     
     // *key_resp_33* updates
     if (t >= 0.0 && key_resp_33.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_33.tStart = t;  // (not accounting for frame time here)
       key_resp_33.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_33.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_33.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_33.clearEvents(); });
     }
 
     if (key_resp_33.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_33.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_33_allKeys = _key_resp_33_allKeys.concat(theseKeys);
       if (_key_resp_33_allKeys.length > 0) {
         key_resp_33.keys = _key_resp_33_allKeys[_key_resp_33_allKeys.length - 1].name;  // just the last key pressed
         key_resp_33.rt = _key_resp_33_allKeys[_key_resp_33_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_78* updates
     if (t >= 0.0 && text_78.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_78.tStart = t;  // (not accounting for frame time here)
       text_78.frameNStart = frameN;  // exact frame index
       
       text_78.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Quick_Reminder_MixedComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Quick_Reminder_MixedRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Quick_Reminder_Mixed'-------
     for (const thisComponent of Quick_Reminder_MixedComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_33.keys', key_resp_33.keys);
     if (typeof key_resp_33.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_33.rt', key_resp_33.rt);
         routineTimer.reset();
         }
     
     key_resp_33.stop();
     // the Routine "Quick_Reminder_Mixed" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_35_allKeys;
 var Practice_mixedComponents;
 function Practice_mixedRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Practice_mixed'-------
     t = 0;
     Practice_mixedClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_35.keys = undefined;
     key_resp_35.rt = undefined;
     _key_resp_35_allKeys = [];
     // keep track of which components have finished
     Practice_mixedComponents = [];
     Practice_mixedComponents.push(white_background_2);
     Practice_mixedComponents.push(text_79);
     Practice_mixedComponents.push(key_resp_35);
     Practice_mixedComponents.push(text_80);
     
     for (const thisComponent of Practice_mixedComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Practice_mixedRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Practice_mixed'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Practice_mixedClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_2* updates
     if (t >= 0.0 && white_background_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_2.tStart = t;  // (not accounting for frame time here)
       white_background_2.frameNStart = frameN;  // exact frame index
       
       white_background_2.setAutoDraw(true);
     }
 
     
     // *text_79* updates
     if (t >= 0.0 && text_79.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_79.tStart = t;  // (not accounting for frame time here)
       text_79.frameNStart = frameN;  // exact frame index
       
       text_79.setAutoDraw(true);
     }
 
     
     // *key_resp_35* updates
     if (t >= 0.0 && key_resp_35.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_35.tStart = t;  // (not accounting for frame time here)
       key_resp_35.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_35.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_35.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_35.clearEvents(); });
     }
 
     if (key_resp_35.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_35.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_35_allKeys = _key_resp_35_allKeys.concat(theseKeys);
       if (_key_resp_35_allKeys.length > 0) {
         key_resp_35.keys = _key_resp_35_allKeys[_key_resp_35_allKeys.length - 1].name;  // just the last key pressed
         key_resp_35.rt = _key_resp_35_allKeys[_key_resp_35_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_80* updates
     if (t >= 0.0 && text_80.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_80.tStart = t;  // (not accounting for frame time here)
       text_80.frameNStart = frameN;  // exact frame index
       
       text_80.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Practice_mixedComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Practice_mixedRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Practice_mixed'-------
     for (const thisComponent of Practice_mixedComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_35.keys', key_resp_35.keys);
     if (typeof key_resp_35.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_35.rt', key_resp_35.rt);
         routineTimer.reset();
         }
     
     key_resp_35.stop();
     // the Routine "Practice_mixed" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_36_allKeys;
 var Practice_trial_mixedComponents;
 function Practice_trial_mixedRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Practice_trial_mixed'-------
     t = 0;
     Practice_trial_mixedClock.reset(); // clock
     frameN = -1;
     routineTimer.add(2.250000);
     // update component parameters for each repeat
     image_9.setImage(Hearts_Flowers);
     key_resp_36.keys = undefined;
     key_resp_36.rt = undefined;
     _key_resp_36_allKeys = [];
     var msg_mixed01;
     var color_msg_mixed01;
     // keep track of which components have finished
     Practice_trial_mixedComponents = [];
     Practice_trial_mixedComponents.push(white_background_15);
     Practice_trial_mixedComponents.push(text_81);
     Practice_trial_mixedComponents.push(text_82);
     Practice_trial_mixedComponents.push(image_9);
     Practice_trial_mixedComponents.push(text_83);
     Practice_trial_mixedComponents.push(key_resp_36);
     
     for (const thisComponent of Practice_trial_mixedComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Practice_trial_mixedRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Practice_trial_mixed'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Practice_trial_mixedClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_15* updates
     if (t >= 0.0 && white_background_15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_15.tStart = t;  // (not accounting for frame time here)
       white_background_15.frameNStart = frameN;  // exact frame index
       
       white_background_15.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_15.status === PsychoJS.Status.STARTED || white_background_15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_15.setAutoDraw(false);
     }
     
     // *text_81* updates
     if (t >= 0.0 && text_81.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_81.tStart = t;  // (not accounting for frame time here)
       text_81.frameNStart = frameN;  // exact frame index
       
       text_81.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_81.status === PsychoJS.Status.STARTED || text_81.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_81.setAutoDraw(false);
     }
     
     // *text_82* updates
     if (t >= 0.5 && text_82.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_82.tStart = t;  // (not accounting for frame time here)
       text_82.frameNStart = frameN;  // exact frame index
       
       text_82.setAutoDraw(true);
     }
 
     frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_82.status === PsychoJS.Status.STARTED || text_82.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_82.setAutoDraw(false);
     }
     
     // *image_9* updates
     if (t >= 1.0 && image_9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_9.tStart = t;  // (not accounting for frame time here)
       image_9.frameNStart = frameN;  // exact frame index
       
       image_9.setAutoDraw(true);
     }
 
     frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((image_9.status === PsychoJS.Status.STARTED || image_9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       image_9.setAutoDraw(false);
     }
     
     // *text_83* updates
     if (t >= 1.75 && text_83.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_83.tStart = t;  // (not accounting for frame time here)
       text_83.frameNStart = frameN;  // exact frame index
       
       text_83.setAutoDraw(true);
     }
 
     frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_83.status === PsychoJS.Status.STARTED || text_83.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_83.setAutoDraw(false);
     }
     
     // *key_resp_36* updates
     if (t >= 1.0 && key_resp_36.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_36.tStart = t;  // (not accounting for frame time here)
       key_resp_36.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_36.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_36.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_36.clearEvents(); });
     }
 
     frameRemains = 1.0 + 1.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((key_resp_36.status === PsychoJS.Status.STARTED || key_resp_36.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       key_resp_36.status = PsychoJS.Status.FINISHED;
   }
 
     if (key_resp_36.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_36.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_36_allKeys = _key_resp_36_allKeys.concat(theseKeys);
       if (_key_resp_36_allKeys.length > 0) {
         key_resp_36.keys = _key_resp_36_allKeys[_key_resp_36_allKeys.length - 1].name;  // just the last key pressed
         key_resp_36.rt = _key_resp_36_allKeys[_key_resp_36_allKeys.length - 1].rt;
         // was this correct?
         if (key_resp_36.keys == corAns) {
             key_resp_36.corr = 1;
         } else {
             key_resp_36.corr = 0;
         }
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Practice_trial_mixedComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 var msg_mixed01;
 var color_msg_mixed01;
 function Practice_trial_mixedRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Practice_trial_mixed'-------
     for (const thisComponent of Practice_trial_mixedComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // was no response the correct answer?!
     if (key_resp_36.keys === undefined) {
       if (['None','none',undefined].includes(corAns)) {
          key_resp_36.corr = 1;  // correct non-response
       } else {
          key_resp_36.corr = 0;  // failed to respond (incorrectly)
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('key_resp_36.keys', key_resp_36.keys);
     psychoJS.experiment.addData('key_resp_36.corr', key_resp_36.corr);
     if (typeof key_resp_36.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_36.rt', key_resp_36.rt);
         routineTimer.reset();
         }
     
     key_resp_36.stop();
       if (key_resp_36.keys === undefined) {
           msg_mixed01 = 'No response'
           color_msg_mixed01 = 'black'
           } else {
           if (key_resp_36.corr > 0){
               msg_mixed01 = 'Correct'
               color_msg_mixed01 = 'green'
           } else {
               msg_mixed01 = 'Incorrect'
               color_msg_mixed01 = 'red'
           }
           }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var feedback_hf_mixed_1Components;
 function feedback_hf_mixed_1RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'feedback_hf_mixed_1'-------
     t = 0;
     feedback_hf_mixed_1Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(1.500000);
     // update component parameters for each repeat
     text_110.setColor(new util.Color(color_msg_mixed01));
     text_110.setText(msg_mixed01);
     // keep track of which components have finished
     feedback_hf_mixed_1Components = [];
     feedback_hf_mixed_1Components.push(white_background_39);
     feedback_hf_mixed_1Components.push(text_110);
     
     for (const thisComponent of feedback_hf_mixed_1Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_hf_mixed_1RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'feedback_hf_mixed_1'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = feedback_hf_mixed_1Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_39* updates
     if (t >= 0.0 && white_background_39.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_39.tStart = t;  // (not accounting for frame time here)
       white_background_39.frameNStart = frameN;  // exact frame index
       
       white_background_39.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_39.status === PsychoJS.Status.STARTED || white_background_39.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_39.setAutoDraw(false);
     }
     
     // *text_110* updates
     if (t >= 0.0 && text_110.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_110.tStart = t;  // (not accounting for frame time here)
       text_110.frameNStart = frameN;  // exact frame index
       
       text_110.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_110.status === PsychoJS.Status.STARTED || text_110.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_110.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of feedback_hf_mixed_1Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_hf_mixed_1RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'feedback_hf_mixed_1'-------
     for (const thisComponent of feedback_hf_mixed_1Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_39_allKeys;
 var nCorrhf03;
 var reminder_mixedComponents;
 function reminder_mixedRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'reminder_mixed'-------
     t = 0;
     reminder_mixedClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_39.keys = undefined;
     key_resp_39.rt = undefined;
     _key_resp_39_allKeys = [];
     nCorrhf03 = 0;
     console.log("hf_mixed03")
     console.log(nCorrhf03)
       for (eachResp=0; eachResp<psychoJS.experiment._trialsData.length; eachResp++){
         if ('key_resp_36.corr' in psychoJS.experiment._trialsData[eachResp]) {
         nCorrhf03 += psychoJS.experiment._trialsData[eachResp]['key_resp_36.corr'];
         }
       }
     
     
     
     // keep track of which components have finished
     reminder_mixedComponents = [];
     reminder_mixedComponents.push(white_background_43);
     reminder_mixedComponents.push(text_106);
     reminder_mixedComponents.push(text_107);
     reminder_mixedComponents.push(key_resp_39);
     
     for (const thisComponent of reminder_mixedComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function reminder_mixedRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'reminder_mixed'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = reminder_mixedClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_43* updates
     if (t >= 0.0 && white_background_43.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_43.tStart = t;  // (not accounting for frame time here)
       white_background_43.frameNStart = frameN;  // exact frame index
       
       white_background_43.setAutoDraw(true);
     }
 
     
     // *text_106* updates
     if (t >= 0.0 && text_106.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_106.tStart = t;  // (not accounting for frame time here)
       text_106.frameNStart = frameN;  // exact frame index
       
       text_106.setAutoDraw(true);
     }
 
     
     // *text_107* updates
     if (t >= 0.0 && text_107.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_107.tStart = t;  // (not accounting for frame time here)
       text_107.frameNStart = frameN;  // exact frame index
       
       text_107.setAutoDraw(true);
     }
 
     
     // *key_resp_39* updates
     if (t >= 0.0 && key_resp_39.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_39.tStart = t;  // (not accounting for frame time here)
       key_resp_39.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_39.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_39.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_39.clearEvents(); });
     }
 
     if (key_resp_39.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_39.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_39_allKeys = _key_resp_39_allKeys.concat(theseKeys);
       if (_key_resp_39_allKeys.length > 0) {
         key_resp_39.keys = _key_resp_39_allKeys[_key_resp_39_allKeys.length - 1].name;  // just the last key pressed
         key_resp_39.rt = _key_resp_39_allKeys[_key_resp_39_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     console.log("hf_mixed03")
     console.log(nCorrhf03)
     if (nCorrhf03 > 5) {
         console.log("true")
         continueRoutine = false; // until we're told otherwise
         } 
     else if (key_resp_39.keys === 'space') {
             continueRoutine = false;
             }
     else {
             console.log("false")
             continueRoutine = true;
             }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of reminder_mixedComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function reminder_mixedRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'reminder_mixed'-------
     for (const thisComponent of reminder_mixedComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_39.keys', key_resp_39.keys);
     if (typeof key_resp_39.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_39.rt', key_resp_39.rt);
         routineTimer.reset();
         }
     
     key_resp_39.stop();
     // the Routine "reminder_mixed" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_40_allKeys;
 var Practice_trial_mixed_2Components;
 function Practice_trial_mixed_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Practice_trial_mixed_2'-------
     t = 0;
     Practice_trial_mixed_2Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(2.250000);
     // update component parameters for each repeat
     image_15.setImage(Hearts_Flowers);
     key_resp_40.keys = undefined;
     key_resp_40.rt = undefined;
     _key_resp_40_allKeys = [];
     var color_msg_mixed02;
     var msg_mixed02;
     
     
     // keep track of which components have finished
     Practice_trial_mixed_2Components = [];
     Practice_trial_mixed_2Components.push(white_background_36);
     Practice_trial_mixed_2Components.push(text_99);
     Practice_trial_mixed_2Components.push(text_100);
     Practice_trial_mixed_2Components.push(image_15);
     Practice_trial_mixed_2Components.push(text_101);
     Practice_trial_mixed_2Components.push(key_resp_40);
     
     for (const thisComponent of Practice_trial_mixed_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Practice_trial_mixed_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Practice_trial_mixed_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Practice_trial_mixed_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_36* updates
     if (t >= 0.0 && white_background_36.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_36.tStart = t;  // (not accounting for frame time here)
       white_background_36.frameNStart = frameN;  // exact frame index
       
       white_background_36.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_36.status === PsychoJS.Status.STARTED || white_background_36.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_36.setAutoDraw(false);
     }
     
     // *text_99* updates
     if (t >= 0.0 && text_99.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_99.tStart = t;  // (not accounting for frame time here)
       text_99.frameNStart = frameN;  // exact frame index
       
       text_99.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_99.status === PsychoJS.Status.STARTED || text_99.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_99.setAutoDraw(false);
     }
     
     // *text_100* updates
     if (t >= 0.5 && text_100.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_100.tStart = t;  // (not accounting for frame time here)
       text_100.frameNStart = frameN;  // exact frame index
       
       text_100.setAutoDraw(true);
     }
 
     frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_100.status === PsychoJS.Status.STARTED || text_100.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_100.setAutoDraw(false);
     }
     
     // *image_15* updates
     if (t >= 1.0 && image_15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_15.tStart = t;  // (not accounting for frame time here)
       image_15.frameNStart = frameN;  // exact frame index
       
       image_15.setAutoDraw(true);
     }
 
     frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((image_15.status === PsychoJS.Status.STARTED || image_15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       image_15.setAutoDraw(false);
     }
     
     // *text_101* updates
     if (t >= 1.75 && text_101.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_101.tStart = t;  // (not accounting for frame time here)
       text_101.frameNStart = frameN;  // exact frame index
       
       text_101.setAutoDraw(true);
     }
 
     frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_101.status === PsychoJS.Status.STARTED || text_101.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_101.setAutoDraw(false);
     }
     
     // *key_resp_40* updates
     if (t >= 1.0 && key_resp_40.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_40.tStart = t;  // (not accounting for frame time here)
       key_resp_40.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_40.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_40.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_40.clearEvents(); });
     }
 
     frameRemains = 1.0 + 1.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((key_resp_40.status === PsychoJS.Status.STARTED || key_resp_40.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       key_resp_40.status = PsychoJS.Status.FINISHED;
   }
 
     if (key_resp_40.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_40.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_40_allKeys = _key_resp_40_allKeys.concat(theseKeys);
       if (_key_resp_40_allKeys.length > 0) {
         key_resp_40.keys = _key_resp_40_allKeys[_key_resp_40_allKeys.length - 1].name;  // just the last key pressed
         key_resp_40.rt = _key_resp_40_allKeys[_key_resp_40_allKeys.length - 1].rt;
         // was this correct?
         if (key_resp_40.keys == corAns) {
             key_resp_40.corr = 1;
         } else {
             key_resp_40.corr = 0;
         }
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     console.log("hf_mixed03")
     console.log(nCorrhf03)
     if (nCorrhf03 > 5) {
         console.log("true")
         continueRoutine = false; // until we're told otherwise
         } else {
             console.log("false")
             continueRoutine = true;
             }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Practice_trial_mixed_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 var msg_mixed02;
 var color_msg_mixed02;
 function Practice_trial_mixed_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Practice_trial_mixed_2'-------
     for (const thisComponent of Practice_trial_mixed_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // was no response the correct answer?!
     if (key_resp_40.keys === undefined) {
       if (['None','none',undefined].includes(corAns)) {
          key_resp_40.corr = 1;  // correct non-response
       } else {
          key_resp_40.corr = 0;  // failed to respond (incorrectly)
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('key_resp_40.keys', key_resp_40.keys);
     psychoJS.experiment.addData('key_resp_40.corr', key_resp_40.corr);
     if (typeof key_resp_40.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_40.rt', key_resp_40.rt);
         routineTimer.reset();
         }
     
     key_resp_40.stop();
       if (key_resp_40.keys === undefined) {
           msg_mixed02 = 'No response'
           color_msg_mixed02 = 'black'
           } else {
           if (key_resp_40.corr > 0){
               msg_mixed02 = 'Correct'
               color_msg_mixed02 = 'green'
           } else {
               msg_mixed02 = 'Incorrect'
               color_msg_mixed02 = 'red'
           }
           }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var feedback_hf_mixed_2Components;
 function feedback_hf_mixed_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'feedback_hf_mixed_2'-------
     t = 0;
     feedback_hf_mixed_2Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(1.500000);
     // update component parameters for each repeat
     text_109.setColor(new util.Color(color_msg_mixed02));
     text_109.setText(msg_mixed02);
     console.log("hf_mixed03")
     console.log(nCorrhf03)
     
     // keep track of which components have finished
     feedback_hf_mixed_2Components = [];
     feedback_hf_mixed_2Components.push(white_background_40);
     feedback_hf_mixed_2Components.push(text_109);
     
     for (const thisComponent of feedback_hf_mixed_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_hf_mixed_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'feedback_hf_mixed_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = feedback_hf_mixed_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_40* updates
     if (t >= 0.0 && white_background_40.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_40.tStart = t;  // (not accounting for frame time here)
       white_background_40.frameNStart = frameN;  // exact frame index
       
       white_background_40.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_40.status === PsychoJS.Status.STARTED || white_background_40.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_40.setAutoDraw(false);
     }
     
     // *text_109* updates
     if (t >= 0.0 && text_109.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_109.tStart = t;  // (not accounting for frame time here)
       text_109.frameNStart = frameN;  // exact frame index
       
       text_109.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_109.status === PsychoJS.Status.STARTED || text_109.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_109.setAutoDraw(false);
     }
     if (nCorrhf03 > 5) {
         console.log("true")
         continueRoutine = false; // until we're told otherwise
         } else {
             console.log("false")
             continueRoutine = true;
             }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of feedback_hf_mixed_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_hf_mixed_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'feedback_hf_mixed_2'-------
     for (const thisComponent of feedback_hf_mixed_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_41_allKeys;
 var Ready3Components;
 function Ready3RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Ready3'-------
     t = 0;
     Ready3Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_41.keys = undefined;
     key_resp_41.rt = undefined;
     _key_resp_41_allKeys = [];
     // keep track of which components have finished
     Ready3Components = [];
     Ready3Components.push(white_background_4);
     Ready3Components.push(text_84);
     Ready3Components.push(key_resp_41);
     Ready3Components.push(text_85);
     
     for (const thisComponent of Ready3Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Ready3RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Ready3'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Ready3Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_4* updates
     if (t >= 0.0 && white_background_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_4.tStart = t;  // (not accounting for frame time here)
       white_background_4.frameNStart = frameN;  // exact frame index
       
       white_background_4.setAutoDraw(true);
     }
 
     
     // *text_84* updates
     if (t >= 0.0 && text_84.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_84.tStart = t;  // (not accounting for frame time here)
       text_84.frameNStart = frameN;  // exact frame index
       
       text_84.setAutoDraw(true);
     }
 
     
     // *key_resp_41* updates
     if (t >= 0.0 && key_resp_41.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_41.tStart = t;  // (not accounting for frame time here)
       key_resp_41.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_41.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_41.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_41.clearEvents(); });
     }
 
     if (key_resp_41.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_41.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_41_allKeys = _key_resp_41_allKeys.concat(theseKeys);
       if (_key_resp_41_allKeys.length > 0) {
         key_resp_41.keys = _key_resp_41_allKeys[_key_resp_41_allKeys.length - 1].name;  // just the last key pressed
         key_resp_41.rt = _key_resp_41_allKeys[_key_resp_41_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_85* updates
     if (t >= 0.0 && text_85.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_85.tStart = t;  // (not accounting for frame time here)
       text_85.frameNStart = frameN;  // exact frame index
       
       text_85.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Ready3Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Ready3RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Ready3'-------
     for (const thisComponent of Ready3Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_41.keys', key_resp_41.keys);
     if (typeof key_resp_41.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_41.rt', key_resp_41.rt);
         routineTimer.reset();
         }
     
     key_resp_41.stop();
     // the Routine "Ready3" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_42_allKeys;
 var mixed_firstComponents;
 function mixed_firstRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'mixed_first'-------
     t = 0;
     mixed_firstClock.reset(); // clock
     frameN = -1;
     routineTimer.add(2.250000);
     // update component parameters for each repeat
     key_resp_42.keys = undefined;
     key_resp_42.rt = undefined;
     _key_resp_42_allKeys = [];
     // keep track of which components have finished
     mixed_firstComponents = [];
     mixed_firstComponents.push(white_background_9);
     mixed_firstComponents.push(text_86);
     mixed_firstComponents.push(text_87);
     mixed_firstComponents.push(image_10);
     mixed_firstComponents.push(text_88);
     mixed_firstComponents.push(key_resp_42);
     
     for (const thisComponent of mixed_firstComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function mixed_firstRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'mixed_first'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = mixed_firstClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_9* updates
     if (t >= 0.0 && white_background_9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_9.tStart = t;  // (not accounting for frame time here)
       white_background_9.frameNStart = frameN;  // exact frame index
       
       white_background_9.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_9.status === PsychoJS.Status.STARTED || white_background_9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_9.setAutoDraw(false);
     }
     
     // *text_86* updates
     if (t >= 0.0 && text_86.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_86.tStart = t;  // (not accounting for frame time here)
       text_86.frameNStart = frameN;  // exact frame index
       
       text_86.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_86.status === PsychoJS.Status.STARTED || text_86.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_86.setAutoDraw(false);
     }
     
     // *text_87* updates
     if (t >= 0.5 && text_87.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_87.tStart = t;  // (not accounting for frame time here)
       text_87.frameNStart = frameN;  // exact frame index
       
       text_87.setAutoDraw(true);
     }
 
     frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_87.status === PsychoJS.Status.STARTED || text_87.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_87.setAutoDraw(false);
     }
     
     // *image_10* updates
     if (t >= 1.0 && image_10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_10.tStart = t;  // (not accounting for frame time here)
       image_10.frameNStart = frameN;  // exact frame index
       
       image_10.setAutoDraw(true);
     }
 
     frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((image_10.status === PsychoJS.Status.STARTED || image_10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       image_10.setAutoDraw(false);
     }
     
     // *text_88* updates
     if (t >= 1.75 && text_88.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_88.tStart = t;  // (not accounting for frame time here)
       text_88.frameNStart = frameN;  // exact frame index
       
       text_88.setAutoDraw(true);
     }
 
     frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_88.status === PsychoJS.Status.STARTED || text_88.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_88.setAutoDraw(false);
     }
     
     // *key_resp_42* updates
     if (t >= 1.0 && key_resp_42.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_42.tStart = t;  // (not accounting for frame time here)
       key_resp_42.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_42.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_42.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_42.clearEvents(); });
     }
 
     frameRemains = 1.0 + 1.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((key_resp_42.status === PsychoJS.Status.STARTED || key_resp_42.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       key_resp_42.status = PsychoJS.Status.FINISHED;
   }
 
     if (key_resp_42.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_42.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_42_allKeys = _key_resp_42_allKeys.concat(theseKeys);
       if (_key_resp_42_allKeys.length > 0) {
         key_resp_42.keys = _key_resp_42_allKeys[_key_resp_42_allKeys.length - 1].name;  // just the last key pressed
         key_resp_42.rt = _key_resp_42_allKeys[_key_resp_42_allKeys.length - 1].rt;
         // was this correct?
         if (key_resp_42.keys == "'m'") {
             key_resp_42.corr = 1;
         } else {
             key_resp_42.corr = 0;
         }
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of mixed_firstComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function mixed_firstRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'mixed_first'-------
     for (const thisComponent of mixed_firstComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // was no response the correct answer?!
     if (key_resp_42.keys === undefined) {
       if (['None','none',undefined].includes("'m'")) {
          key_resp_42.corr = 1;  // correct non-response
       } else {
          key_resp_42.corr = 0;  // failed to respond (incorrectly)
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('key_resp_42.keys', key_resp_42.keys);
     psychoJS.experiment.addData('key_resp_42.corr', key_resp_42.corr);
     if (typeof key_resp_42.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_42.rt', key_resp_42.rt);
         routineTimer.reset();
         }
     
     key_resp_42.stop();
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_43_allKeys;
 var MixedComponents;
 function MixedRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Mixed'-------
     t = 0;
     MixedClock.reset(); // clock
     frameN = -1;
     routineTimer.add(2.250000);
     // update component parameters for each repeat
     image_2.setImage(Hearts_Flowers);
     key_resp_43.keys = undefined;
     key_resp_43.rt = undefined;
     _key_resp_43_allKeys = [];
     // keep track of which components have finished
     MixedComponents = [];
     MixedComponents.push(white_background_5);
     MixedComponents.push(text_89);
     MixedComponents.push(text_90);
     MixedComponents.push(image_2);
     MixedComponents.push(text_91);
     MixedComponents.push(key_resp_43);
     
     for (const thisComponent of MixedComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function MixedRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Mixed'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = MixedClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_5* updates
     if (t >= 0.0 && white_background_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_5.tStart = t;  // (not accounting for frame time here)
       white_background_5.frameNStart = frameN;  // exact frame index
       
       white_background_5.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_5.status === PsychoJS.Status.STARTED || white_background_5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_5.setAutoDraw(false);
     }
     
     // *text_89* updates
     if (t >= 0.0 && text_89.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_89.tStart = t;  // (not accounting for frame time here)
       text_89.frameNStart = frameN;  // exact frame index
       
       text_89.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_89.status === PsychoJS.Status.STARTED || text_89.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_89.setAutoDraw(false);
     }
     
     // *text_90* updates
     if (t >= 0.5 && text_90.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_90.tStart = t;  // (not accounting for frame time here)
       text_90.frameNStart = frameN;  // exact frame index
       
       text_90.setAutoDraw(true);
     }
 
     frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_90.status === PsychoJS.Status.STARTED || text_90.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_90.setAutoDraw(false);
     }
     
     // *image_2* updates
     if (t >= 1.0 && image_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_2.tStart = t;  // (not accounting for frame time here)
       image_2.frameNStart = frameN;  // exact frame index
       
       image_2.setAutoDraw(true);
     }
 
     frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((image_2.status === PsychoJS.Status.STARTED || image_2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       image_2.setAutoDraw(false);
     }
     
     // *text_91* updates
     if (t >= 1.75 && text_91.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_91.tStart = t;  // (not accounting for frame time here)
       text_91.frameNStart = frameN;  // exact frame index
       
       text_91.setAutoDraw(true);
     }
 
     frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_91.status === PsychoJS.Status.STARTED || text_91.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_91.setAutoDraw(false);
     }
     
     // *key_resp_43* updates
     if (t >= 1.0 && key_resp_43.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_43.tStart = t;  // (not accounting for frame time here)
       key_resp_43.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_43.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_43.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_43.clearEvents(); });
     }
 
     frameRemains = 1.0 + 1.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((key_resp_43.status === PsychoJS.Status.STARTED || key_resp_43.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       key_resp_43.status = PsychoJS.Status.FINISHED;
   }
 
     if (key_resp_43.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_43.getKeys({keyList: ['z', 'm'], waitRelease: false});
       _key_resp_43_allKeys = _key_resp_43_allKeys.concat(theseKeys);
       if (_key_resp_43_allKeys.length > 0) {
         key_resp_43.keys = _key_resp_43_allKeys[_key_resp_43_allKeys.length - 1].name;  // just the last key pressed
         key_resp_43.rt = _key_resp_43_allKeys[_key_resp_43_allKeys.length - 1].rt;
         // was this correct?
         if (key_resp_43.keys == corAns) {
             key_resp_43.corr = 1;
         } else {
             key_resp_43.corr = 0;
         }
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of MixedComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function MixedRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Mixed'-------
     for (const thisComponent of MixedComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // was no response the correct answer?!
     if (key_resp_43.keys === undefined) {
       if (['None','none',undefined].includes(corAns)) {
          key_resp_43.corr = 1;  // correct non-response
       } else {
          key_resp_43.corr = 0;  // failed to respond (incorrectly)
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('key_resp_43.keys', key_resp_43.keys);
     psychoJS.experiment.addData('key_resp_43.corr', key_resp_43.corr);
     if (typeof key_resp_43.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_43.rt', key_resp_43.rt);
         routineTimer.reset();
         }
     
     key_resp_43.stop();
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Thank_YouComponents;
 function Thank_YouRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Thank_You'-------
     t = 0;
     Thank_YouClock.reset(); // clock
     frameN = -1;
     routineTimer.add(2.500000);
     // update component parameters for each repeat
     // keep track of which components have finished
     Thank_YouComponents = [];
     Thank_YouComponents.push(white_background_31);
     Thank_YouComponents.push(text_92);
     Thank_YouComponents.push(text_111);
     
     for (const thisComponent of Thank_YouComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Thank_YouRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Thank_You'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Thank_YouClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *white_background_31* updates
     if (t >= 0.0 && white_background_31.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       white_background_31.tStart = t;  // (not accounting for frame time here)
       white_background_31.frameNStart = frameN;  // exact frame index
       
       white_background_31.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((white_background_31.status === PsychoJS.Status.STARTED || white_background_31.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       white_background_31.setAutoDraw(false);
     }
     
     // *text_92* updates
     if (t >= 0.0 && text_92.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_92.tStart = t;  // (not accounting for frame time here)
       text_92.frameNStart = frameN;  // exact frame index
       
       text_92.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_92.status === PsychoJS.Status.STARTED || text_92.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_92.setAutoDraw(false);
     }
     
     // *text_111* updates
     if (t >= 0.0 && text_111.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_111.tStart = t;  // (not accounting for frame time here)
       text_111.frameNStart = frameN;  // exact frame index
       
       text_111.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((text_111.status === PsychoJS.Status.STARTED || text_111.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       text_111.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Thank_YouComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Thank_YouRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Thank_You'-------
     for (const thisComponent of Thank_YouComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_52_allKeys;
 var welcomeComponents;
 function welcomeRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'welcome'-------
     t = 0;
     welcomeClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_52.keys = undefined;
     key_resp_52.rt = undefined;
     _key_resp_52_allKeys = [];
     // keep track of which components have finished
     welcomeComponents = [];
     welcomeComponents.push(text_122);
     welcomeComponents.push(text_123);
     welcomeComponents.push(key_resp_52);
     
     for (const thisComponent of welcomeComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function welcomeRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'welcome'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = welcomeClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *text_122* updates
     if (t >= 0.0 && text_122.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_122.tStart = t;  // (not accounting for frame time here)
       text_122.frameNStart = frameN;  // exact frame index
       
       text_122.setAutoDraw(true);
     }
 
     
     // *text_123* updates
     if (t >= 0.0 && text_123.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_123.tStart = t;  // (not accounting for frame time here)
       text_123.frameNStart = frameN;  // exact frame index
       
       text_123.setAutoDraw(true);
     }
 
     
     // *key_resp_52* updates
     if (t >= 0.0 && key_resp_52.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_52.tStart = t;  // (not accounting for frame time here)
       key_resp_52.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_52.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_52.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_52.clearEvents(); });
     }
 
     if (key_resp_52.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_52.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_52_allKeys = _key_resp_52_allKeys.concat(theseKeys);
       if (_key_resp_52_allKeys.length > 0) {
         key_resp_52.keys = _key_resp_52_allKeys[_key_resp_52_allKeys.length - 1].name;  // just the last key pressed
         key_resp_52.rt = _key_resp_52_allKeys[_key_resp_52_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of welcomeComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function welcomeRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'welcome'-------
     for (const thisComponent of welcomeComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_52.keys', key_resp_52.keys);
     if (typeof key_resp_52.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_52.rt', key_resp_52.rt);
         routineTimer.reset();
         }
     
     key_resp_52.stop();
     // the Routine "welcome" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_53_allKeys;
 var Instructions_3Components;
 function Instructions_3RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Instructions_3'-------
     t = 0;
     Instructions_3Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_53.keys = undefined;
     key_resp_53.rt = undefined;
     _key_resp_53_allKeys = [];
     // keep track of which components have finished
     Instructions_3Components = [];
     Instructions_3Components.push(instructions_2);
     Instructions_3Components.push(key_resp_53);
     Instructions_3Components.push(text_124);
     
     for (const thisComponent of Instructions_3Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Instructions_3RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Instructions_3'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Instructions_3Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *instructions_2* updates
     if (t >= 0.0 && instructions_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       instructions_2.tStart = t;  // (not accounting for frame time here)
       instructions_2.frameNStart = frameN;  // exact frame index
       
       instructions_2.setAutoDraw(true);
     }
 
     
     // *key_resp_53* updates
     if (t >= 0.0 && key_resp_53.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_53.tStart = t;  // (not accounting for frame time here)
       key_resp_53.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_53.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_53.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_53.clearEvents(); });
     }
 
     if (key_resp_53.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_53.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_53_allKeys = _key_resp_53_allKeys.concat(theseKeys);
       if (_key_resp_53_allKeys.length > 0) {
         key_resp_53.keys = _key_resp_53_allKeys[_key_resp_53_allKeys.length - 1].name;  // just the last key pressed
         key_resp_53.rt = _key_resp_53_allKeys[_key_resp_53_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_124* updates
     if (t >= 0.0 && text_124.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_124.tStart = t;  // (not accounting for frame time here)
       text_124.frameNStart = frameN;  // exact frame index
       
       text_124.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Instructions_3Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Instructions_3RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Instructions_3'-------
     for (const thisComponent of Instructions_3Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_53.keys', key_resp_53.keys);
     if (typeof key_resp_53.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_53.rt', key_resp_53.rt);
         routineTimer.reset();
         }
     
     key_resp_53.stop();
     // the Routine "Instructions_3" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_54_allKeys;
 var ExampleComponents;
 function ExampleRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Example'-------
     t = 0;
     ExampleClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_54.keys = undefined;
     key_resp_54.rt = undefined;
     _key_resp_54_allKeys = [];
     // keep track of which components have finished
     ExampleComponents = [];
     ExampleComponents.push(example_text);
     ExampleComponents.push(example);
     ExampleComponents.push(example_text_2);
     ExampleComponents.push(key_resp_54);
     
     for (const thisComponent of ExampleComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function ExampleRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Example'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = ExampleClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *example_text* updates
     if (t >= 0.0 && example_text.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       example_text.tStart = t;  // (not accounting for frame time here)
       example_text.frameNStart = frameN;  // exact frame index
       
       example_text.setAutoDraw(true);
     }
 
     
     // *example* updates
     if (t >= 0.0 && example.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       example.tStart = t;  // (not accounting for frame time here)
       example.frameNStart = frameN;  // exact frame index
       
       example.setAutoDraw(true);
     }
 
     
     // *example_text_2* updates
     if (t >= 0.0 && example_text_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       example_text_2.tStart = t;  // (not accounting for frame time here)
       example_text_2.frameNStart = frameN;  // exact frame index
       
       example_text_2.setAutoDraw(true);
     }
 
     
     // *key_resp_54* updates
     if (t >= 0.0 && key_resp_54.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_54.tStart = t;  // (not accounting for frame time here)
       key_resp_54.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_54.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_54.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_54.clearEvents(); });
     }
 
     if (key_resp_54.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_54.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_54_allKeys = _key_resp_54_allKeys.concat(theseKeys);
       if (_key_resp_54_allKeys.length > 0) {
         key_resp_54.keys = _key_resp_54_allKeys[_key_resp_54_allKeys.length - 1].name;  // just the last key pressed
         key_resp_54.rt = _key_resp_54_allKeys[_key_resp_54_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of ExampleComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function ExampleRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Example'-------
     for (const thisComponent of ExampleComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_54.keys', key_resp_54.keys);
     if (typeof key_resp_54.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_54.rt', key_resp_54.rt);
         routineTimer.reset();
         }
     
     key_resp_54.stop();
     // the Routine "Example" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_55_allKeys;
 var lets_practiceComponents;
 function lets_practiceRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'lets_practice'-------
     t = 0;
     lets_practiceClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_55.keys = undefined;
     key_resp_55.rt = undefined;
     _key_resp_55_allKeys = [];
     // keep track of which components have finished
     lets_practiceComponents = [];
     lets_practiceComponents.push(text_125);
     lets_practiceComponents.push(key_resp_55);
     lets_practiceComponents.push(text_126);
     
     for (const thisComponent of lets_practiceComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function lets_practiceRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'lets_practice'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = lets_practiceClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *text_125* updates
     if (t >= 0.0 && text_125.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_125.tStart = t;  // (not accounting for frame time here)
       text_125.frameNStart = frameN;  // exact frame index
       
       text_125.setAutoDraw(true);
     }
 
     
     // *key_resp_55* updates
     if (t >= 0.0 && key_resp_55.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_55.tStart = t;  // (not accounting for frame time here)
       key_resp_55.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_55.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_55.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_55.clearEvents(); });
     }
 
     if (key_resp_55.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_55.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_55_allKeys = _key_resp_55_allKeys.concat(theseKeys);
       if (_key_resp_55_allKeys.length > 0) {
         key_resp_55.keys = _key_resp_55_allKeys[_key_resp_55_allKeys.length - 1].name;  // just the last key pressed
         key_resp_55.rt = _key_resp_55_allKeys[_key_resp_55_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     
     // *text_126* updates
     if (t >= 0.0 && text_126.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_126.tStart = t;  // (not accounting for frame time here)
       text_126.frameNStart = frameN;  // exact frame index
       
       text_126.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of lets_practiceComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function lets_practiceRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'lets_practice'-------
     for (const thisComponent of lets_practiceComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_55.keys', key_resp_55.keys);
     if (typeof key_resp_55.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_55.rt', key_resp_55.rt);
         routineTimer.reset();
         }
     
     key_resp_55.stop();
     // the Routine "lets_practice" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var timer_practice_wcst;
 var beginning_practice_wcst;
 var trials_practice_2Components;
 function trials_practice_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'trials_practice_2'-------
     t = 0;
     trials_practice_2Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     trial_card_2.setImage(card);
     corr = 0;
     timer_practice_wcst = new util.Clock();
     beginning_practice_wcst = timer_practice_wcst.getTime();
     // setup some python lists for storing info about the response_2
     response_2.clicked_name = [];
     gotValidClick = false; // until a click is received
     // keep track of which components have finished
     trials_practice_2Components = [];
     trials_practice_2Components.push(fixation_4);
     trials_practice_2Components.push(one_red_dot_2);
     trials_practice_2Components.push(two_yellow_triangles_2);
     trials_practice_2Components.push(three_green_crosses_2);
     trials_practice_2Components.push(four_blue_stars_2);
     trials_practice_2Components.push(trial_card_2);
     trials_practice_2Components.push(response_2);
     
     for (const thisComponent of trials_practice_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function trials_practice_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'trials_practice_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = trials_practice_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *fixation_4* updates
     if (t >= 0.0 && fixation_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixation_4.tStart = t;  // (not accounting for frame time here)
       fixation_4.frameNStart = frameN;  // exact frame index
       
       fixation_4.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fixation_4.status === PsychoJS.Status.STARTED || fixation_4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fixation_4.setAutoDraw(false);
     }
     
     // *one_red_dot_2* updates
     if (t >= 0 && one_red_dot_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       one_red_dot_2.tStart = t;  // (not accounting for frame time here)
       one_red_dot_2.frameNStart = frameN;  // exact frame index
       
       one_red_dot_2.setAutoDraw(true);
     }
 
     
     // *two_yellow_triangles_2* updates
     if (t >= 0 && two_yellow_triangles_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       two_yellow_triangles_2.tStart = t;  // (not accounting for frame time here)
       two_yellow_triangles_2.frameNStart = frameN;  // exact frame index
       
       two_yellow_triangles_2.setAutoDraw(true);
     }
 
     
     // *three_green_crosses_2* updates
     if (t >= 0 && three_green_crosses_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       three_green_crosses_2.tStart = t;  // (not accounting for frame time here)
       three_green_crosses_2.frameNStart = frameN;  // exact frame index
       
       three_green_crosses_2.setAutoDraw(true);
     }
 
     
     // *four_blue_stars_2* updates
     if (t >= 0 && four_blue_stars_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       four_blue_stars_2.tStart = t;  // (not accounting for frame time here)
       four_blue_stars_2.frameNStart = frameN;  // exact frame index
       
       four_blue_stars_2.setAutoDraw(true);
     }
 
     
     // *trial_card_2* updates
     if (t >= 0.5 && trial_card_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       trial_card_2.tStart = t;  // (not accounting for frame time here)
       trial_card_2.frameNStart = frameN;  // exact frame index
       
       trial_card_2.setAutoDraw(true);
     }
 
     var current_practice_wcst = timer_practice_wcst.getTime();
     var allow_practice_wcst = (current_practice_wcst - beginning_practice_wcst);
     console.log(allow_practice_wcst)
     if(allow_practice_wcst < .499){
         continueRoutine = true;
         } else {
             for (var stimulus, _pj_c = 0, _pj_a = [one_red_dot, two_yellow_triangles, three_green_crosses, four_blue_stars], _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                 stimulus = _pj_a[_pj_c];
                 if (response_2.isPressedIn(stimulus)) {
                     var corrAnsMaybe = 'images/' + stimulus.name + '.jpg';
                     console.log(stimulus.name, corrAns, corrAnsMaybe === corrAns);
                     if ((corrAnsMaybe === corrAns)) {
                         corr = 1;
                         }
                     psychoJS.experiment.addData("correct", corr);
                     psychoJS.experiment.addData("wcst_rt", allow_practice_wcst);
                     continueRoutine = false;
         }
     }
     }
     
     
     
     // *response_2* updates
     if (t >= 0.5 && response_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       response_2.tStart = t;  // (not accounting for frame time here)
       response_2.frameNStart = frameN;  // exact frame index
       
       response_2.status = PsychoJS.Status.STARTED;
       response_2.mouseClock.reset();
       prevButtonState = response_2.getPressed();  // if button is down already this ISN'T a new click
       }
     if (response_2.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = response_2.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [one_red_dot_2, two_yellow_triangles_2, three_green_crosses_2, four_blue_stars_2]) {
             if (obj.contains(response_2)) {
               gotValidClick = true;
               response_2.clicked_name.push(obj.name)
             }
           }
           if (gotValidClick === true) { // abort routine on response
             continueRoutine = false;
           }
         }
       }
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of trials_practice_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function trials_practice_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'trials_practice_2'-------
     for (const thisComponent of trials_practice_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     _mouseXYs = response_2.getPos();
     _mouseButtons = response_2.getPressed();
     psychoJS.experiment.addData('response_2.x', _mouseXYs[0]);
     psychoJS.experiment.addData('response_2.y', _mouseXYs[1]);
     psychoJS.experiment.addData('response_2.leftButton', _mouseButtons[0]);
     psychoJS.experiment.addData('response_2.midButton', _mouseButtons[1]);
     psychoJS.experiment.addData('response_2.rightButton', _mouseButtons[2]);
     if (response_2.clicked_name.length > 0) {
       psychoJS.experiment.addData('response_2.clicked_name', response_2.clicked_name[0]);}
     // the Routine "trials_practice_2" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var feedback_practice_2Components;
 function feedback_practice_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'feedback_practice_2'-------
     t = 0;
     feedback_practice_2Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(1.000000);
     // update component parameters for each repeat
     if ((corr === 1)) {
         msg = "Correct!";
     } else {
         msg = "Incorrect";
     }
     
     
     
     feedback_text_2.setText(msg);
     // keep track of which components have finished
     feedback_practice_2Components = [];
     feedback_practice_2Components.push(feedback_text_2);
     
     for (const thisComponent of feedback_practice_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_practice_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'feedback_practice_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = feedback_practice_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *feedback_text_2* updates
     if (t >= 0 && feedback_text_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       feedback_text_2.tStart = t;  // (not accounting for frame time here)
       feedback_text_2.frameNStart = frameN;  // exact frame index
       
       feedback_text_2.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((feedback_text_2.status === PsychoJS.Status.STARTED || feedback_text_2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       feedback_text_2.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of feedback_practice_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function feedback_practice_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'feedback_practice_2'-------
     for (const thisComponent of feedback_practice_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     trial_counter = 0;
     condition_counter = 0;
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var _key_resp_56_allKeys;
 var readyComponents;
 function readyRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'ready'-------
     t = 0;
     readyClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     key_resp_56.keys = undefined;
     key_resp_56.rt = undefined;
     _key_resp_56_allKeys = [];
     // keep track of which components have finished
     readyComponents = [];
     readyComponents.push(text_127);
     readyComponents.push(text_128);
     readyComponents.push(key_resp_56);
     
     for (const thisComponent of readyComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function readyRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'ready'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = readyClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *text_127* updates
     if (t >= 0.0 && text_127.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_127.tStart = t;  // (not accounting for frame time here)
       text_127.frameNStart = frameN;  // exact frame index
       
       text_127.setAutoDraw(true);
     }
 
     
     // *text_128* updates
     if (t >= 0.0 && text_128.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_128.tStart = t;  // (not accounting for frame time here)
       text_128.frameNStart = frameN;  // exact frame index
       
       text_128.setAutoDraw(true);
     }
 
     
     // *key_resp_56* updates
     if (t >= 0.0 && key_resp_56.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       key_resp_56.tStart = t;  // (not accounting for frame time here)
       key_resp_56.frameNStart = frameN;  // exact frame index
       
       // keyboard checking is just starting
       psychoJS.window.callOnFlip(function() { key_resp_56.clock.reset(); });  // t=0 on next screen flip
       psychoJS.window.callOnFlip(function() { key_resp_56.start(); }); // start on screen flip
       psychoJS.window.callOnFlip(function() { key_resp_56.clearEvents(); });
     }
 
     if (key_resp_56.status === PsychoJS.Status.STARTED) {
       let theseKeys = key_resp_56.getKeys({keyList: ['space'], waitRelease: false});
       _key_resp_56_allKeys = _key_resp_56_allKeys.concat(theseKeys);
       if (_key_resp_56_allKeys.length > 0) {
         key_resp_56.keys = _key_resp_56_allKeys[_key_resp_56_allKeys.length - 1].name;  // just the last key pressed
         key_resp_56.rt = _key_resp_56_allKeys[_key_resp_56_allKeys.length - 1].rt;
         // a response ends the routine
         continueRoutine = false;
       }
     }
     
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of readyComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function readyRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'ready'-------
     for (const thisComponent of readyComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     psychoJS.experiment.addData('key_resp_56.keys', key_resp_56.keys);
     if (typeof key_resp_56.keys !== 'undefined') {  // we had a response
         psychoJS.experiment.addData('key_resp_56.rt', key_resp_56.rt);
         routineTimer.reset();
         }
     
     key_resp_56.stop();
     // the Routine "ready" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var code_meta_2Components;
 function code_meta_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'code_meta_2'-------
     t = 0;
     code_meta_2Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // keep track of which components have finished
     code_meta_2Components = [];
     
     for (const thisComponent of code_meta_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function code_meta_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'code_meta_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = code_meta_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of code_meta_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function code_meta_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'code_meta_2'-------
     for (const thisComponent of code_meta_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // the Routine "code_meta_2" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var timer_wcst;
 var beginning_wcst;
 var TrialsComponents;
 function TrialsRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Trials'-------
     t = 0;
     TrialsClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     trial_card.setImage(card);
     corr = 0;
     timer_wcst = new util.Clock();
     beginning_wcst = timer_wcst.getTime();
     // setup some python lists for storing info about the response
     response.clicked_name = [];
     gotValidClick = false; // until a click is received
     // keep track of which components have finished
     TrialsComponents = [];
     TrialsComponents.push(fixation_5);
     TrialsComponents.push(one_red_dot);
     TrialsComponents.push(two_yellow_triangles);
     TrialsComponents.push(three_green_crosses);
     TrialsComponents.push(four_blue_stars);
     TrialsComponents.push(trial_card);
     TrialsComponents.push(response);
     
     for (const thisComponent of TrialsComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function TrialsRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Trials'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = TrialsClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *fixation_5* updates
     if (t >= 0.0 && fixation_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixation_5.tStart = t;  // (not accounting for frame time here)
       fixation_5.frameNStart = frameN;  // exact frame index
       
       fixation_5.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((fixation_5.status === PsychoJS.Status.STARTED || fixation_5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       fixation_5.setAutoDraw(false);
     }
     
     // *one_red_dot* updates
     if (t >= 0 && one_red_dot.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       one_red_dot.tStart = t;  // (not accounting for frame time here)
       one_red_dot.frameNStart = frameN;  // exact frame index
       
       one_red_dot.setAutoDraw(true);
     }
 
     
     // *two_yellow_triangles* updates
     if (t >= 0 && two_yellow_triangles.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       two_yellow_triangles.tStart = t;  // (not accounting for frame time here)
       two_yellow_triangles.frameNStart = frameN;  // exact frame index
       
       two_yellow_triangles.setAutoDraw(true);
     }
 
     
     // *three_green_crosses* updates
     if (t >= 0 && three_green_crosses.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       three_green_crosses.tStart = t;  // (not accounting for frame time here)
       three_green_crosses.frameNStart = frameN;  // exact frame index
       
       three_green_crosses.setAutoDraw(true);
     }
 
     
     // *four_blue_stars* updates
     if (t >= 0 && four_blue_stars.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       four_blue_stars.tStart = t;  // (not accounting for frame time here)
       four_blue_stars.frameNStart = frameN;  // exact frame index
       
       four_blue_stars.setAutoDraw(true);
     }
 
     
     // *trial_card* updates
     if (t >= 0.5 && trial_card.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       trial_card.tStart = t;  // (not accounting for frame time here)
       trial_card.frameNStart = frameN;  // exact frame index
       
       trial_card.setAutoDraw(true);
     }
 
     var current_wcst = timer_wcst.getTime();
     var allow_wcst = (current_wcst - beginning_wcst);
     console.log(allow_wcst)
     if(allow_wcst < .499){
         continueRoutine = true;
         } else {
             for (var stimulus, _pj_c = 0, _pj_a = [one_red_dot, two_yellow_triangles, three_green_crosses, four_blue_stars], _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                 stimulus = _pj_a[_pj_c];
                 if (response.isPressedIn(stimulus)) {
                     var corrAnsMaybe = 'images/' + stimulus.name + '.jpg';
                     console.log(stimulus.name, corrAns, corrAnsMaybe === corrAns);
                     if ((corrAnsMaybe === corrAns)) {
                         corr = 1;
                         }
                     var end_wcst = timer_wcst.getTime();
                     var time_wcst_trial = (end_wcst - beginning_wcst);
                     psychoJS.experiment.addData("wcst_rt", time_wcst_trial);
                     psychoJS.experiment.addData("correct", corr);
                     continueRoutine = false;
         }
     }
     }
     
     
     // *response* updates
     if (t >= 0.5 && response.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       response.tStart = t;  // (not accounting for frame time here)
       response.frameNStart = frameN;  // exact frame index
       
       response.status = PsychoJS.Status.STARTED;
       response.mouseClock.reset();
       prevButtonState = response.getPressed();  // if button is down already this ISN'T a new click
       }
     if (response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = response.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [one_red_dot, two_yellow_triangles, three_green_crosses, four_blue_stars]) {
             if (obj.contains(response)) {
               gotValidClick = true;
               response.clicked_name.push(obj.name)
             }
           }
           if (gotValidClick === true) { // abort routine on response
             continueRoutine = false;
           }
         }
       }
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of TrialsComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function TrialsRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Trials'-------
     for (const thisComponent of TrialsComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     _mouseXYs = response.getPos();
     _mouseButtons = response.getPressed();
     psychoJS.experiment.addData('response.x', _mouseXYs[0]);
     psychoJS.experiment.addData('response.y', _mouseXYs[1]);
     psychoJS.experiment.addData('response.leftButton', _mouseButtons[0]);
     psychoJS.experiment.addData('response.midButton', _mouseButtons[1]);
     psychoJS.experiment.addData('response.rightButton', _mouseButtons[2]);
     if (response.clicked_name.length > 0) {
       psychoJS.experiment.addData('response.clicked_name', response.clicked_name[0]);}
     // the Routine "Trials" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var Feedback_2Components;
 function Feedback_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'Feedback_2'-------
     t = 0;
     Feedback_2Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(1.000000);
     // update component parameters for each repeat
     if ((corr === 1)) {
         msg = "Correct! ";
     } else {
         msg = "Incorrect";
     }
     
     
     
     feedback_text.setText(msg);
     // keep track of which components have finished
     Feedback_2Components = [];
     Feedback_2Components.push(feedback_text);
     
     for (const thisComponent of Feedback_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Feedback_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'Feedback_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = Feedback_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *feedback_text* updates
     if (t >= 0 && feedback_text.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       feedback_text.tStart = t;  // (not accounting for frame time here)
       feedback_text.frameNStart = frameN;  // exact frame index
       
       feedback_text.setAutoDraw(true);
     }
 
     frameRemains = 0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((feedback_text.status === PsychoJS.Status.STARTED || feedback_text.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       feedback_text.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of Feedback_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function Feedback_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'Feedback_2'-------
     for (const thisComponent of Feedback_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     if((trial_counter === 0 && corr === 1)){
         corr_trial_counter = 1;
         prev = 1;
     } else if ((trial_counter === 0 && corr === 0)) {
         corr_trial_counter = 0;
         prev = 0; 
     } else if ((trial_counter > 0 && corr === 1)){
         if((prev === 1)){
             corr_trial_counter = corr_trial_counter + 1;
             prev = 1;
         } else {
             corr_trial_counter = 1;
             prev =1;}
     } else {
         corr_trial_counter = 0;
         prev = 0;
     }
     
     console.log(corr_trial_counter);
     console.log(trial_counter);
     trial_counter = (trial_counter + 1);
     console.log(trial_counter);
     
     psychoJS.experiment.addData("trial_counter", trial_counter);
     
     if ((corr_trial_counter === 6)) {
         trials_3.finished = true;
         condition_counter = condition_counter + 1 
         corr_trial_counter = 0
         console.log(corr_trial_counter);
         console.log(condition_counter);
     }
     
     if ((trial_counter === 40)){
         trials_3.finished = true;
         }
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var code_end_2Components;
 function code_end_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'code_end_2'-------
     t = 0;
     code_end_2Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     console.log(condition_counter)
     console.log(trial_counter)
     if ((condition_counter > 3)) {
         blocks_2.finished = true;
     } else if ((trial_counter === 40)){
         blocks_2.finished = true;
     } else {
         blocks_2.finished = false;
     }
     
     // keep track of which components have finished
     code_end_2Components = [];
     
     for (const thisComponent of code_end_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function code_end_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'code_end_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = code_end_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of code_end_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function code_end_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'code_end_2'-------
     for (const thisComponent of code_end_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // the Routine "code_end_2" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var tol_welcomeComponents;
 function tol_welcomeRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'tol_welcome'-------
     t = 0;
     tol_welcomeClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the mouse_8
     mouse_8.clicked_name = [];
     gotValidClick = false; // until a click is received
     // keep track of which components have finished
     tol_welcomeComponents = [];
     tol_welcomeComponents.push(light_gray_bg_6);
     tol_welcomeComponents.push(text_129);
     tol_welcomeComponents.push(mouse_8);
     tol_welcomeComponents.push(check_box_welcome);
     tol_welcomeComponents.push(text_next_wel);
     
     for (const thisComponent of tol_welcomeComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function tol_welcomeRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'tol_welcome'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = tol_welcomeClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *light_gray_bg_6* updates
     if (t >= 0.0 && light_gray_bg_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       light_gray_bg_6.tStart = t;  // (not accounting for frame time here)
       light_gray_bg_6.frameNStart = frameN;  // exact frame index
       
       light_gray_bg_6.setAutoDraw(true);
     }
 
     
     // *text_129* updates
     if (t >= 0.0 && text_129.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_129.tStart = t;  // (not accounting for frame time here)
       text_129.frameNStart = frameN;  // exact frame index
       
       text_129.setAutoDraw(true);
     }
 
     // *mouse_8* updates
     if (t >= 0.0 && mouse_8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       mouse_8.tStart = t;  // (not accounting for frame time here)
       mouse_8.frameNStart = frameN;  // exact frame index
       
       mouse_8.status = PsychoJS.Status.STARTED;
       mouse_8.mouseClock.reset();
       prevButtonState = mouse_8.getPressed();  // if button is down already this ISN'T a new click
       }
     if (mouse_8.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = mouse_8.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [check_box_welcome]) {
             if (obj.contains(mouse_8)) {
               gotValidClick = true;
               mouse_8.clicked_name.push(obj.name)
             }
           }
           if (gotValidClick === true) { // abort routine on response
             continueRoutine = false;
           }
         }
       }
     }
     
     // *check_box_welcome* updates
     if (t >= 0.0 && check_box_welcome.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       check_box_welcome.tStart = t;  // (not accounting for frame time here)
       check_box_welcome.frameNStart = frameN;  // exact frame index
       
       check_box_welcome.setAutoDraw(true);
     }
 
     
     // *text_next_wel* updates
     if (t >= 0.0 && text_next_wel.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_next_wel.tStart = t;  // (not accounting for frame time here)
       text_next_wel.frameNStart = frameN;  // exact frame index
       
       text_next_wel.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of tol_welcomeComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function tol_welcomeRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'tol_welcome'-------
     for (const thisComponent of tol_welcomeComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     _mouseXYs = mouse_8.getPos();
     _mouseButtons = mouse_8.getPressed();
     psychoJS.experiment.addData('mouse_8.x', _mouseXYs[0]);
     psychoJS.experiment.addData('mouse_8.y', _mouseXYs[1]);
     psychoJS.experiment.addData('mouse_8.leftButton', _mouseButtons[0]);
     psychoJS.experiment.addData('mouse_8.midButton', _mouseButtons[1]);
     psychoJS.experiment.addData('mouse_8.rightButton', _mouseButtons[2]);
     if (mouse_8.clicked_name.length > 0) {
       psychoJS.experiment.addData('mouse_8.clicked_name', mouse_8.clicked_name[0]);}
     // the Routine "tol_welcome" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var tol_explanationComponents;
 function tol_explanationRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'tol_explanation'-------
     t = 0;
     tol_explanationClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the mouse_9
     // current position of the mouse:
     mouse_9.x = [];
     mouse_9.y = [];
     mouse_9.leftButton = [];
     mouse_9.midButton = [];
     mouse_9.rightButton = [];
     mouse_9.time = [];
     mouse_9.clicked_name = [];
     gotValidClick = false; // until a click is received
     bluet1m2_4.setPos([(- 0.587), (- 0.17)]);
     // keep track of which components have finished
     tol_explanationComponents = [];
     tol_explanationComponents.push(light_gray_bg_7);
     tol_explanationComponents.push(base_right_6);
     tol_explanationComponents.push(pole_right_13);
     tol_explanationComponents.push(pole_right_14);
     tol_explanationComponents.push(pole_right_15);
     tol_explanationComponents.push(right_green_5);
     tol_explanationComponents.push(right_red_5);
     tol_explanationComponents.push(right_blue_5);
     tol_explanationComponents.push(base_left_6);
     tol_explanationComponents.push(bart1m2_leftc_4);
     tol_explanationComponents.push(bart1m2_leftb_4);
     tol_explanationComponents.push(bart1m2_lefta_4);
     tol_explanationComponents.push(mouse_9);
     tol_explanationComponents.push(fixedt1m2_a1_4);
     tol_explanationComponents.push(fixedt1m2_a2_4);
     tol_explanationComponents.push(fixedt1m2_a3_4);
     tol_explanationComponents.push(fixedt1m2_b1_4);
     tol_explanationComponents.push(fixedt1m2_b2_4);
     tol_explanationComponents.push(fixedt1m2_c1_4);
     tol_explanationComponents.push(text_exp);
     tol_explanationComponents.push(greent1m2_4);
     tol_explanationComponents.push(redt1m2_4);
     tol_explanationComponents.push(bluet1m2_4);
     tol_explanationComponents.push(check_box_2);
     tol_explanationComponents.push(text_132);
     tol_explanationComponents.push(text_133);
     tol_explanationComponents.push(text_134);
     
     for (const thisComponent of tol_explanationComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function tol_explanationRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'tol_explanation'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = tol_explanationClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *light_gray_bg_7* updates
     if (t >= 0.0 && light_gray_bg_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       light_gray_bg_7.tStart = t;  // (not accounting for frame time here)
       light_gray_bg_7.frameNStart = frameN;  // exact frame index
       
       light_gray_bg_7.setAutoDraw(true);
     }
 
     
     // *base_right_6* updates
     if (t >= 0.0 && base_right_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_right_6.tStart = t;  // (not accounting for frame time here)
       base_right_6.frameNStart = frameN;  // exact frame index
       
       base_right_6.setAutoDraw(true);
     }
 
     
     // *pole_right_13* updates
     if (t >= 0.0 && pole_right_13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_13.tStart = t;  // (not accounting for frame time here)
       pole_right_13.frameNStart = frameN;  // exact frame index
       
       pole_right_13.setAutoDraw(true);
     }
 
     
     // *pole_right_14* updates
     if (t >= 0.0 && pole_right_14.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_14.tStart = t;  // (not accounting for frame time here)
       pole_right_14.frameNStart = frameN;  // exact frame index
       
       pole_right_14.setAutoDraw(true);
     }
 
     
     // *pole_right_15* updates
     if (t >= 0.0 && pole_right_15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_15.tStart = t;  // (not accounting for frame time here)
       pole_right_15.frameNStart = frameN;  // exact frame index
       
       pole_right_15.setAutoDraw(true);
     }
 
     
     // *right_green_5* updates
     if (t >= 0.0 && right_green_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_green_5.tStart = t;  // (not accounting for frame time here)
       right_green_5.frameNStart = frameN;  // exact frame index
       
       right_green_5.setAutoDraw(true);
     }
 
     
     // *right_red_5* updates
     if (t >= 0.0 && right_red_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_red_5.tStart = t;  // (not accounting for frame time here)
       right_red_5.frameNStart = frameN;  // exact frame index
       
       right_red_5.setAutoDraw(true);
     }
 
     
     // *right_blue_5* updates
     if (t >= 0.0 && right_blue_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_blue_5.tStart = t;  // (not accounting for frame time here)
       right_blue_5.frameNStart = frameN;  // exact frame index
       
       right_blue_5.setAutoDraw(true);
     }
 
     
     // *base_left_6* updates
     if (t >= 0.0 && base_left_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_left_6.tStart = t;  // (not accounting for frame time here)
       base_left_6.frameNStart = frameN;  // exact frame index
       
       base_left_6.setAutoDraw(true);
     }
 
     
     // *bart1m2_leftc_4* updates
     if (t >= 0.0 && bart1m2_leftc_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_leftc_4.tStart = t;  // (not accounting for frame time here)
       bart1m2_leftc_4.frameNStart = frameN;  // exact frame index
       
       bart1m2_leftc_4.setAutoDraw(true);
     }
 
     
     // *bart1m2_leftb_4* updates
     if (t >= 0.0 && bart1m2_leftb_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_leftb_4.tStart = t;  // (not accounting for frame time here)
       bart1m2_leftb_4.frameNStart = frameN;  // exact frame index
       
       bart1m2_leftb_4.setAutoDraw(true);
     }
 
     
     // *bart1m2_lefta_4* updates
     if (t >= 0.0 && bart1m2_lefta_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_lefta_4.tStart = t;  // (not accounting for frame time here)
       bart1m2_lefta_4.frameNStart = frameN;  // exact frame index
       
       bart1m2_lefta_4.setAutoDraw(true);
     }
 
     // *mouse_9* updates
     if (t >= 0 && mouse_9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       mouse_9.tStart = t;  // (not accounting for frame time here)
       mouse_9.frameNStart = frameN;  // exact frame index
       
       mouse_9.status = PsychoJS.Status.STARTED;
       mouse_9.mouseClock.reset();
       prevButtonState = mouse_9.getPressed();  // if button is down already this ISN'T a new click
       }
     if (mouse_9.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = mouse_9.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = mouse_9.getPos();
           mouse_9.x.push(_mouseXYs[0]);
           mouse_9.y.push(_mouseXYs[1]);
           mouse_9.leftButton.push(_mouseButtons[0]);
           mouse_9.midButton.push(_mouseButtons[1]);
           mouse_9.rightButton.push(_mouseButtons[2]);
           mouse_9.time.push(mouse_9.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [check_box_2]) {
             if (obj.contains(mouse_9)) {
               gotValidClick = true;
               mouse_9.clicked_name.push(obj.name)
             }
           }
           if (gotValidClick === true) { // abort routine on response
             continueRoutine = false;
           }
         }
       }
     }
     
     // *fixedt1m2_a1_4* updates
     if (t >= 0.0 && fixedt1m2_a1_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a1_4.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a1_4.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a1_4.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_a2_4* updates
     if (t >= 0.0 && fixedt1m2_a2_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a2_4.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a2_4.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a2_4.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_a3_4* updates
     if (t >= 0.0 && fixedt1m2_a3_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a3_4.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a3_4.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a3_4.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_b1_4* updates
     if (t >= 0.0 && fixedt1m2_b1_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_b1_4.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_b1_4.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_b1_4.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_b2_4* updates
     if (t >= 0.0 && fixedt1m2_b2_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_b2_4.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_b2_4.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_b2_4.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_c1_4* updates
     if (t >= 0.0 && fixedt1m2_c1_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_c1_4.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_c1_4.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_c1_4.setAutoDraw(true);
     }
 
     
     // *text_exp* updates
     if (t >= 0.0 && text_exp.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_exp.tStart = t;  // (not accounting for frame time here)
       text_exp.frameNStart = frameN;  // exact frame index
       
       text_exp.setAutoDraw(true);
     }
 
     
     // *greent1m2_4* updates
     if (t >= 0.0 && greent1m2_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       greent1m2_4.tStart = t;  // (not accounting for frame time here)
       greent1m2_4.frameNStart = frameN;  // exact frame index
       
       greent1m2_4.setAutoDraw(true);
     }
 
     
     // *redt1m2_4* updates
     if (t >= 0.0 && redt1m2_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       redt1m2_4.tStart = t;  // (not accounting for frame time here)
       redt1m2_4.frameNStart = frameN;  // exact frame index
       
       redt1m2_4.setAutoDraw(true);
     }
 
     
     // *bluet1m2_4* updates
     if (t >= 0.0 && bluet1m2_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bluet1m2_4.tStart = t;  // (not accounting for frame time here)
       bluet1m2_4.frameNStart = frameN;  // exact frame index
       
       bluet1m2_4.setAutoDraw(true);
     }
 
     
     // *check_box_2* updates
     if (t >= 0.0 && check_box_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       check_box_2.tStart = t;  // (not accounting for frame time here)
       check_box_2.frameNStart = frameN;  // exact frame index
       
       check_box_2.setAutoDraw(true);
     }
 
     
     // *text_132* updates
     if (t >= 0.0 && text_132.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_132.tStart = t;  // (not accounting for frame time here)
       text_132.frameNStart = frameN;  // exact frame index
       
       text_132.setAutoDraw(true);
     }
 
     
     // *text_133* updates
     if (t >= 0.0 && text_133.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_133.tStart = t;  // (not accounting for frame time here)
       text_133.frameNStart = frameN;  // exact frame index
       
       text_133.setAutoDraw(true);
     }
 
     
     // *text_134* updates
     if (t >= 0.0 && text_134.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_134.tStart = t;  // (not accounting for frame time here)
       text_134.frameNStart = frameN;  // exact frame index
       
       text_134.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of tol_explanationComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function tol_explanationRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'tol_explanation'-------
     for (const thisComponent of tol_explanationComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     if (mouse_9.x) {  psychoJS.experiment.addData('mouse_9.x', mouse_9.x[0])};
     if (mouse_9.y) {  psychoJS.experiment.addData('mouse_9.y', mouse_9.y[0])};
     if (mouse_9.leftButton) {  psychoJS.experiment.addData('mouse_9.leftButton', mouse_9.leftButton[0])};
     if (mouse_9.midButton) {  psychoJS.experiment.addData('mouse_9.midButton', mouse_9.midButton[0])};
     if (mouse_9.rightButton) {  psychoJS.experiment.addData('mouse_9.rightButton', mouse_9.rightButton[0])};
     if (mouse_9.time) {  psychoJS.experiment.addData('mouse_9.time', mouse_9.time[0])};
     if (mouse_9.clicked_name) {  psychoJS.experiment.addData('mouse_9.clicked_name', mouse_9.clicked_name[0])};
     
     // the Routine "tol_explanation" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var tol_instructionsComponents;
 function tol_instructionsRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'tol_instructions'-------
     t = 0;
     tol_instructionsClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the mouse_10
     // current position of the mouse:
     mouse_10.x = [];
     mouse_10.y = [];
     mouse_10.leftButton = [];
     mouse_10.midButton = [];
     mouse_10.rightButton = [];
     mouse_10.time = [];
     mouse_10.clicked_name = [];
     gotValidClick = false; // until a click is received
     bluet1m2_5.setPos([(- 0.587), (- 0.17)]);
     // keep track of which components have finished
     tol_instructionsComponents = [];
     tol_instructionsComponents.push(light_gray_bg_8);
     tol_instructionsComponents.push(base_right_7);
     tol_instructionsComponents.push(pole_right_16);
     tol_instructionsComponents.push(pole_right_17);
     tol_instructionsComponents.push(pole_right_18);
     tol_instructionsComponents.push(right_green_6);
     tol_instructionsComponents.push(right_red_6);
     tol_instructionsComponents.push(right_blue_6);
     tol_instructionsComponents.push(base_left_7);
     tol_instructionsComponents.push(bart1m2_leftc_5);
     tol_instructionsComponents.push(bart1m2_leftb_5);
     tol_instructionsComponents.push(bart1m2_lefta_5);
     tol_instructionsComponents.push(mouse_10);
     tol_instructionsComponents.push(fixedt1m2_a1_5);
     tol_instructionsComponents.push(fixedt1m2_a2_5);
     tol_instructionsComponents.push(fixedt1m2_a3_5);
     tol_instructionsComponents.push(fixedt1m2_b1_5);
     tol_instructionsComponents.push(fixedt1m2_b2_5);
     tol_instructionsComponents.push(fixedt1m2_c1_5);
     tol_instructionsComponents.push(text_exp_2);
     tol_instructionsComponents.push(greent1m2_5);
     tol_instructionsComponents.push(redt1m2_5);
     tol_instructionsComponents.push(bluet1m2_5);
     tol_instructionsComponents.push(check_box_3);
     tol_instructionsComponents.push(text_135);
     tol_instructionsComponents.push(text_136);
     tol_instructionsComponents.push(text_137);
     
     for (const thisComponent of tol_instructionsComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function tol_instructionsRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'tol_instructions'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = tol_instructionsClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *light_gray_bg_8* updates
     if (t >= 0.0 && light_gray_bg_8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       light_gray_bg_8.tStart = t;  // (not accounting for frame time here)
       light_gray_bg_8.frameNStart = frameN;  // exact frame index
       
       light_gray_bg_8.setAutoDraw(true);
     }
 
     
     // *base_right_7* updates
     if (t >= 0.0 && base_right_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_right_7.tStart = t;  // (not accounting for frame time here)
       base_right_7.frameNStart = frameN;  // exact frame index
       
       base_right_7.setAutoDraw(true);
     }
 
     
     // *pole_right_16* updates
     if (t >= 0.0 && pole_right_16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_16.tStart = t;  // (not accounting for frame time here)
       pole_right_16.frameNStart = frameN;  // exact frame index
       
       pole_right_16.setAutoDraw(true);
     }
 
     
     // *pole_right_17* updates
     if (t >= 0.0 && pole_right_17.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_17.tStart = t;  // (not accounting for frame time here)
       pole_right_17.frameNStart = frameN;  // exact frame index
       
       pole_right_17.setAutoDraw(true);
     }
 
     
     // *pole_right_18* updates
     if (t >= 0.0 && pole_right_18.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_18.tStart = t;  // (not accounting for frame time here)
       pole_right_18.frameNStart = frameN;  // exact frame index
       
       pole_right_18.setAutoDraw(true);
     }
 
     
     // *right_green_6* updates
     if (t >= 0.0 && right_green_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_green_6.tStart = t;  // (not accounting for frame time here)
       right_green_6.frameNStart = frameN;  // exact frame index
       
       right_green_6.setAutoDraw(true);
     }
 
     
     // *right_red_6* updates
     if (t >= 0.0 && right_red_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_red_6.tStart = t;  // (not accounting for frame time here)
       right_red_6.frameNStart = frameN;  // exact frame index
       
       right_red_6.setAutoDraw(true);
     }
 
     
     // *right_blue_6* updates
     if (t >= 0.0 && right_blue_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_blue_6.tStart = t;  // (not accounting for frame time here)
       right_blue_6.frameNStart = frameN;  // exact frame index
       
       right_blue_6.setAutoDraw(true);
     }
 
     
     // *base_left_7* updates
     if (t >= 0.0 && base_left_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_left_7.tStart = t;  // (not accounting for frame time here)
       base_left_7.frameNStart = frameN;  // exact frame index
       
       base_left_7.setAutoDraw(true);
     }
 
     
     // *bart1m2_leftc_5* updates
     if (t >= 0.0 && bart1m2_leftc_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_leftc_5.tStart = t;  // (not accounting for frame time here)
       bart1m2_leftc_5.frameNStart = frameN;  // exact frame index
       
       bart1m2_leftc_5.setAutoDraw(true);
     }
 
     
     // *bart1m2_leftb_5* updates
     if (t >= 0.0 && bart1m2_leftb_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_leftb_5.tStart = t;  // (not accounting for frame time here)
       bart1m2_leftb_5.frameNStart = frameN;  // exact frame index
       
       bart1m2_leftb_5.setAutoDraw(true);
     }
 
     
     // *bart1m2_lefta_5* updates
     if (t >= 0.0 && bart1m2_lefta_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_lefta_5.tStart = t;  // (not accounting for frame time here)
       bart1m2_lefta_5.frameNStart = frameN;  // exact frame index
       
       bart1m2_lefta_5.setAutoDraw(true);
     }
 
     // *mouse_10* updates
     if (t >= 0 && mouse_10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       mouse_10.tStart = t;  // (not accounting for frame time here)
       mouse_10.frameNStart = frameN;  // exact frame index
       
       mouse_10.status = PsychoJS.Status.STARTED;
       mouse_10.mouseClock.reset();
       prevButtonState = mouse_10.getPressed();  // if button is down already this ISN'T a new click
       }
     if (mouse_10.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = mouse_10.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = mouse_10.getPos();
           mouse_10.x.push(_mouseXYs[0]);
           mouse_10.y.push(_mouseXYs[1]);
           mouse_10.leftButton.push(_mouseButtons[0]);
           mouse_10.midButton.push(_mouseButtons[1]);
           mouse_10.rightButton.push(_mouseButtons[2]);
           mouse_10.time.push(mouse_10.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [check_box_3]) {
             if (obj.contains(mouse_10)) {
               gotValidClick = true;
               mouse_10.clicked_name.push(obj.name)
             }
           }
           if (gotValidClick === true) { // abort routine on response
             continueRoutine = false;
           }
         }
       }
     }
     
     // *fixedt1m2_a1_5* updates
     if (t >= 0.0 && fixedt1m2_a1_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a1_5.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a1_5.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a1_5.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_a2_5* updates
     if (t >= 0.0 && fixedt1m2_a2_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a2_5.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a2_5.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a2_5.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_a3_5* updates
     if (t >= 0.0 && fixedt1m2_a3_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a3_5.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a3_5.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a3_5.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_b1_5* updates
     if (t >= 0.0 && fixedt1m2_b1_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_b1_5.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_b1_5.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_b1_5.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_b2_5* updates
     if (t >= 0.0 && fixedt1m2_b2_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_b2_5.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_b2_5.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_b2_5.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_c1_5* updates
     if (t >= 0.0 && fixedt1m2_c1_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_c1_5.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_c1_5.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_c1_5.setAutoDraw(true);
     }
 
     
     // *text_exp_2* updates
     if (t >= 0.0 && text_exp_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_exp_2.tStart = t;  // (not accounting for frame time here)
       text_exp_2.frameNStart = frameN;  // exact frame index
       
       text_exp_2.setAutoDraw(true);
     }
 
     
     // *greent1m2_5* updates
     if (t >= 0.0 && greent1m2_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       greent1m2_5.tStart = t;  // (not accounting for frame time here)
       greent1m2_5.frameNStart = frameN;  // exact frame index
       
       greent1m2_5.setAutoDraw(true);
     }
 
     
     // *redt1m2_5* updates
     if (t >= 0.0 && redt1m2_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       redt1m2_5.tStart = t;  // (not accounting for frame time here)
       redt1m2_5.frameNStart = frameN;  // exact frame index
       
       redt1m2_5.setAutoDraw(true);
     }
 
     
     // *bluet1m2_5* updates
     if (t >= 0.0 && bluet1m2_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bluet1m2_5.tStart = t;  // (not accounting for frame time here)
       bluet1m2_5.frameNStart = frameN;  // exact frame index
       
       bluet1m2_5.setAutoDraw(true);
     }
 
     
     // *check_box_3* updates
     if (t >= 0.0 && check_box_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       check_box_3.tStart = t;  // (not accounting for frame time here)
       check_box_3.frameNStart = frameN;  // exact frame index
       
       check_box_3.setAutoDraw(true);
     }
 
     
     // *text_135* updates
     if (t >= 0.0 && text_135.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_135.tStart = t;  // (not accounting for frame time here)
       text_135.frameNStart = frameN;  // exact frame index
       
       text_135.setAutoDraw(true);
     }
 
     
     // *text_136* updates
     if (t >= 0.0 && text_136.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_136.tStart = t;  // (not accounting for frame time here)
       text_136.frameNStart = frameN;  // exact frame index
       
       text_136.setAutoDraw(true);
     }
 
     
     // *text_137* updates
     if (t >= 0.0 && text_137.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_137.tStart = t;  // (not accounting for frame time here)
       text_137.frameNStart = frameN;  // exact frame index
       
       text_137.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of tol_instructionsComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function tol_instructionsRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'tol_instructions'-------
     for (const thisComponent of tol_instructionsComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     if (mouse_10.x) {  psychoJS.experiment.addData('mouse_10.x', mouse_10.x[0])};
     if (mouse_10.y) {  psychoJS.experiment.addData('mouse_10.y', mouse_10.y[0])};
     if (mouse_10.leftButton) {  psychoJS.experiment.addData('mouse_10.leftButton', mouse_10.leftButton[0])};
     if (mouse_10.midButton) {  psychoJS.experiment.addData('mouse_10.midButton', mouse_10.midButton[0])};
     if (mouse_10.rightButton) {  psychoJS.experiment.addData('mouse_10.rightButton', mouse_10.rightButton[0])};
     if (mouse_10.time) {  psychoJS.experiment.addData('mouse_10.time', mouse_10.time[0])};
     if (mouse_10.clicked_name) {  psychoJS.experiment.addData('mouse_10.clicked_name', mouse_10.clicked_name[0])};
     
     // the Routine "tol_instructions" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var tol_exampleComponents;
 function tol_exampleRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'tol_example'-------
     t = 0;
     tol_exampleClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the mouse_11
     // current position of the mouse:
     mouse_11.x = [];
     mouse_11.y = [];
     mouse_11.leftButton = [];
     mouse_11.midButton = [];
     mouse_11.rightButton = [];
     mouse_11.time = [];
     mouse_11.clicked_name = [];
     gotValidClick = false; // until a click is received
     bluet1m2_6.setPos([(- 0.587), (- 0.17)]);
     // keep track of which components have finished
     tol_exampleComponents = [];
     tol_exampleComponents.push(light_gray_bg_9);
     tol_exampleComponents.push(base_right_8);
     tol_exampleComponents.push(pole_right_19);
     tol_exampleComponents.push(pole_right_20);
     tol_exampleComponents.push(pole_right_21);
     tol_exampleComponents.push(right_green_7);
     tol_exampleComponents.push(right_red_7);
     tol_exampleComponents.push(right_blue_7);
     tol_exampleComponents.push(base_left_8);
     tol_exampleComponents.push(bart1m2_leftc_6);
     tol_exampleComponents.push(bart1m2_leftb_6);
     tol_exampleComponents.push(bart1m2_lefta_6);
     tol_exampleComponents.push(mouse_11);
     tol_exampleComponents.push(fixedt1m2_a1_6);
     tol_exampleComponents.push(fixedt1m2_a2_6);
     tol_exampleComponents.push(fixedt1m2_a3_6);
     tol_exampleComponents.push(fixedt1m2_b1_6);
     tol_exampleComponents.push(fixedt1m2_b2_6);
     tol_exampleComponents.push(fixedt1m2_c1_6);
     tol_exampleComponents.push(text_exp_3);
     tol_exampleComponents.push(greent1m2_6);
     tol_exampleComponents.push(redt1m2_6);
     tol_exampleComponents.push(bluet1m2_6);
     tol_exampleComponents.push(check_box_4);
     tol_exampleComponents.push(text_138);
     tol_exampleComponents.push(text_139);
     tol_exampleComponents.push(text_140);
     
     for (const thisComponent of tol_exampleComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function tol_exampleRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'tol_example'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = tol_exampleClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *light_gray_bg_9* updates
     if (t >= 0.0 && light_gray_bg_9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       light_gray_bg_9.tStart = t;  // (not accounting for frame time here)
       light_gray_bg_9.frameNStart = frameN;  // exact frame index
       
       light_gray_bg_9.setAutoDraw(true);
     }
 
     
     // *base_right_8* updates
     if (t >= 0.0 && base_right_8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_right_8.tStart = t;  // (not accounting for frame time here)
       base_right_8.frameNStart = frameN;  // exact frame index
       
       base_right_8.setAutoDraw(true);
     }
 
     
     // *pole_right_19* updates
     if (t >= 0.0 && pole_right_19.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_19.tStart = t;  // (not accounting for frame time here)
       pole_right_19.frameNStart = frameN;  // exact frame index
       
       pole_right_19.setAutoDraw(true);
     }
 
     
     // *pole_right_20* updates
     if (t >= 0.0 && pole_right_20.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_20.tStart = t;  // (not accounting for frame time here)
       pole_right_20.frameNStart = frameN;  // exact frame index
       
       pole_right_20.setAutoDraw(true);
     }
 
     
     // *pole_right_21* updates
     if (t >= 0.0 && pole_right_21.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_21.tStart = t;  // (not accounting for frame time here)
       pole_right_21.frameNStart = frameN;  // exact frame index
       
       pole_right_21.setAutoDraw(true);
     }
 
     
     // *right_green_7* updates
     if (t >= 0.0 && right_green_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_green_7.tStart = t;  // (not accounting for frame time here)
       right_green_7.frameNStart = frameN;  // exact frame index
       
       right_green_7.setAutoDraw(true);
     }
 
     
     // *right_red_7* updates
     if (t >= 0.0 && right_red_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_red_7.tStart = t;  // (not accounting for frame time here)
       right_red_7.frameNStart = frameN;  // exact frame index
       
       right_red_7.setAutoDraw(true);
     }
 
     
     // *right_blue_7* updates
     if (t >= 0.0 && right_blue_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_blue_7.tStart = t;  // (not accounting for frame time here)
       right_blue_7.frameNStart = frameN;  // exact frame index
       
       right_blue_7.setAutoDraw(true);
     }
 
     
     // *base_left_8* updates
     if (t >= 0.0 && base_left_8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_left_8.tStart = t;  // (not accounting for frame time here)
       base_left_8.frameNStart = frameN;  // exact frame index
       
       base_left_8.setAutoDraw(true);
     }
 
     
     // *bart1m2_leftc_6* updates
     if (t >= 0.0 && bart1m2_leftc_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_leftc_6.tStart = t;  // (not accounting for frame time here)
       bart1m2_leftc_6.frameNStart = frameN;  // exact frame index
       
       bart1m2_leftc_6.setAutoDraw(true);
     }
 
     
     // *bart1m2_leftb_6* updates
     if (t >= 0.0 && bart1m2_leftb_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_leftb_6.tStart = t;  // (not accounting for frame time here)
       bart1m2_leftb_6.frameNStart = frameN;  // exact frame index
       
       bart1m2_leftb_6.setAutoDraw(true);
     }
 
     
     // *bart1m2_lefta_6* updates
     if (t >= 0.0 && bart1m2_lefta_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_lefta_6.tStart = t;  // (not accounting for frame time here)
       bart1m2_lefta_6.frameNStart = frameN;  // exact frame index
       
       bart1m2_lefta_6.setAutoDraw(true);
     }
 
     // *mouse_11* updates
     if (t >= 0 && mouse_11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       mouse_11.tStart = t;  // (not accounting for frame time here)
       mouse_11.frameNStart = frameN;  // exact frame index
       
       mouse_11.status = PsychoJS.Status.STARTED;
       mouse_11.mouseClock.reset();
       prevButtonState = mouse_11.getPressed();  // if button is down already this ISN'T a new click
       }
     if (mouse_11.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = mouse_11.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = mouse_11.getPos();
           mouse_11.x.push(_mouseXYs[0]);
           mouse_11.y.push(_mouseXYs[1]);
           mouse_11.leftButton.push(_mouseButtons[0]);
           mouse_11.midButton.push(_mouseButtons[1]);
           mouse_11.rightButton.push(_mouseButtons[2]);
           mouse_11.time.push(mouse_11.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [check_box_4]) {
             if (obj.contains(mouse_11)) {
               gotValidClick = true;
               mouse_11.clicked_name.push(obj.name)
             }
           }
           if (gotValidClick === true) { // abort routine on response
             continueRoutine = false;
           }
         }
       }
     }
     
     // *fixedt1m2_a1_6* updates
     if (t >= 0.0 && fixedt1m2_a1_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a1_6.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a1_6.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a1_6.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_a2_6* updates
     if (t >= 0.0 && fixedt1m2_a2_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a2_6.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a2_6.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a2_6.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_a3_6* updates
     if (t >= 0.0 && fixedt1m2_a3_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a3_6.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a3_6.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a3_6.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_b1_6* updates
     if (t >= 0.0 && fixedt1m2_b1_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_b1_6.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_b1_6.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_b1_6.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_b2_6* updates
     if (t >= 0.0 && fixedt1m2_b2_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_b2_6.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_b2_6.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_b2_6.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_c1_6* updates
     if (t >= 0.0 && fixedt1m2_c1_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_c1_6.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_c1_6.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_c1_6.setAutoDraw(true);
     }
 
     
     // *text_exp_3* updates
     if (t >= 0.0 && text_exp_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_exp_3.tStart = t;  // (not accounting for frame time here)
       text_exp_3.frameNStart = frameN;  // exact frame index
       
       text_exp_3.setAutoDraw(true);
     }
 
     
     // *greent1m2_6* updates
     if (t >= 0.0 && greent1m2_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       greent1m2_6.tStart = t;  // (not accounting for frame time here)
       greent1m2_6.frameNStart = frameN;  // exact frame index
       
       greent1m2_6.setAutoDraw(true);
     }
 
     
     // *redt1m2_6* updates
     if (t >= 0.0 && redt1m2_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       redt1m2_6.tStart = t;  // (not accounting for frame time here)
       redt1m2_6.frameNStart = frameN;  // exact frame index
       
       redt1m2_6.setAutoDraw(true);
     }
 
     
     // *bluet1m2_6* updates
     if (t >= 0.0 && bluet1m2_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bluet1m2_6.tStart = t;  // (not accounting for frame time here)
       bluet1m2_6.frameNStart = frameN;  // exact frame index
       
       bluet1m2_6.setAutoDraw(true);
     }
 
     
     // *check_box_4* updates
     if (t >= 0.0 && check_box_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       check_box_4.tStart = t;  // (not accounting for frame time here)
       check_box_4.frameNStart = frameN;  // exact frame index
       
       check_box_4.setAutoDraw(true);
     }
 
     
     // *text_138* updates
     if (t >= 0.0 && text_138.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_138.tStart = t;  // (not accounting for frame time here)
       text_138.frameNStart = frameN;  // exact frame index
       
       text_138.setAutoDraw(true);
     }
 
     
     // *text_139* updates
     if (t >= 0.0 && text_139.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_139.tStart = t;  // (not accounting for frame time here)
       text_139.frameNStart = frameN;  // exact frame index
       
       text_139.setAutoDraw(true);
     }
 
     
     // *text_140* updates
     if (t >= 0.0 && text_140.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_140.tStart = t;  // (not accounting for frame time here)
       text_140.frameNStart = frameN;  // exact frame index
       
       text_140.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of tol_exampleComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function tol_exampleRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'tol_example'-------
     for (const thisComponent of tol_exampleComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     if (mouse_11.x) {  psychoJS.experiment.addData('mouse_11.x', mouse_11.x[0])};
     if (mouse_11.y) {  psychoJS.experiment.addData('mouse_11.y', mouse_11.y[0])};
     if (mouse_11.leftButton) {  psychoJS.experiment.addData('mouse_11.leftButton', mouse_11.leftButton[0])};
     if (mouse_11.midButton) {  psychoJS.experiment.addData('mouse_11.midButton', mouse_11.midButton[0])};
     if (mouse_11.rightButton) {  psychoJS.experiment.addData('mouse_11.rightButton', mouse_11.rightButton[0])};
     if (mouse_11.time) {  psychoJS.experiment.addData('mouse_11.time', mouse_11.time[0])};
     if (mouse_11.clicked_name) {  psychoJS.experiment.addData('mouse_11.clicked_name', mouse_11.clicked_name[0])};
     
     // the Routine "tol_example" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var tol_prepracticeComponents;
 function tol_prepracticeRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'tol_prepractice'-------
     t = 0;
     tol_prepracticeClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the mouse_12
     // current position of the mouse:
     mouse_12.x = [];
     mouse_12.y = [];
     mouse_12.leftButton = [];
     mouse_12.midButton = [];
     mouse_12.rightButton = [];
     mouse_12.time = [];
     mouse_12.clicked_name = [];
     gotValidClick = false; // until a click is received
     bluet1m2_7.setPos([(- 0.587), (- 0.17)]);
     // keep track of which components have finished
     tol_prepracticeComponents = [];
     tol_prepracticeComponents.push(light_gray_bg_10);
     tol_prepracticeComponents.push(base_right_9);
     tol_prepracticeComponents.push(pole_right_22);
     tol_prepracticeComponents.push(pole_right_23);
     tol_prepracticeComponents.push(pole_right_24);
     tol_prepracticeComponents.push(right_green_8);
     tol_prepracticeComponents.push(right_red_8);
     tol_prepracticeComponents.push(right_blue_8);
     tol_prepracticeComponents.push(base_left_9);
     tol_prepracticeComponents.push(bart1m2_leftc_7);
     tol_prepracticeComponents.push(bart1m2_leftb_7);
     tol_prepracticeComponents.push(bart1m2_lefta_7);
     tol_prepracticeComponents.push(mouse_12);
     tol_prepracticeComponents.push(fixedt1m2_a1_7);
     tol_prepracticeComponents.push(fixedt1m2_a2_7);
     tol_prepracticeComponents.push(fixedt1m2_a3_7);
     tol_prepracticeComponents.push(fixedt1m2_b1_7);
     tol_prepracticeComponents.push(fixedt1m2_b2_7);
     tol_prepracticeComponents.push(fixedt1m2_c1_7);
     tol_prepracticeComponents.push(text_exp_4);
     tol_prepracticeComponents.push(greent1m2_7);
     tol_prepracticeComponents.push(redt1m2_7);
     tol_prepracticeComponents.push(bluet1m2_7);
     tol_prepracticeComponents.push(check_box_5);
     tol_prepracticeComponents.push(text_141);
     tol_prepracticeComponents.push(text_142);
     tol_prepracticeComponents.push(text_143);
     tol_prepracticeComponents.push(text_144);
     
     for (const thisComponent of tol_prepracticeComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function tol_prepracticeRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'tol_prepractice'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = tol_prepracticeClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *light_gray_bg_10* updates
     if (t >= 0.0 && light_gray_bg_10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       light_gray_bg_10.tStart = t;  // (not accounting for frame time here)
       light_gray_bg_10.frameNStart = frameN;  // exact frame index
       
       light_gray_bg_10.setAutoDraw(true);
     }
 
     
     // *base_right_9* updates
     if (t >= 0.0 && base_right_9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_right_9.tStart = t;  // (not accounting for frame time here)
       base_right_9.frameNStart = frameN;  // exact frame index
       
       base_right_9.setAutoDraw(true);
     }
 
     
     // *pole_right_22* updates
     if (t >= 0.0 && pole_right_22.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_22.tStart = t;  // (not accounting for frame time here)
       pole_right_22.frameNStart = frameN;  // exact frame index
       
       pole_right_22.setAutoDraw(true);
     }
 
     
     // *pole_right_23* updates
     if (t >= 0.0 && pole_right_23.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_23.tStart = t;  // (not accounting for frame time here)
       pole_right_23.frameNStart = frameN;  // exact frame index
       
       pole_right_23.setAutoDraw(true);
     }
 
     
     // *pole_right_24* updates
     if (t >= 0.0 && pole_right_24.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_24.tStart = t;  // (not accounting for frame time here)
       pole_right_24.frameNStart = frameN;  // exact frame index
       
       pole_right_24.setAutoDraw(true);
     }
 
     
     // *right_green_8* updates
     if (t >= 0.0 && right_green_8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_green_8.tStart = t;  // (not accounting for frame time here)
       right_green_8.frameNStart = frameN;  // exact frame index
       
       right_green_8.setAutoDraw(true);
     }
 
     
     // *right_red_8* updates
     if (t >= 0.0 && right_red_8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_red_8.tStart = t;  // (not accounting for frame time here)
       right_red_8.frameNStart = frameN;  // exact frame index
       
       right_red_8.setAutoDraw(true);
     }
 
     
     // *right_blue_8* updates
     if (t >= 0.0 && right_blue_8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_blue_8.tStart = t;  // (not accounting for frame time here)
       right_blue_8.frameNStart = frameN;  // exact frame index
       
       right_blue_8.setAutoDraw(true);
     }
 
     
     // *base_left_9* updates
     if (t >= 0.0 && base_left_9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_left_9.tStart = t;  // (not accounting for frame time here)
       base_left_9.frameNStart = frameN;  // exact frame index
       
       base_left_9.setAutoDraw(true);
     }
 
     
     // *bart1m2_leftc_7* updates
     if (t >= 0.0 && bart1m2_leftc_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_leftc_7.tStart = t;  // (not accounting for frame time here)
       bart1m2_leftc_7.frameNStart = frameN;  // exact frame index
       
       bart1m2_leftc_7.setAutoDraw(true);
     }
 
     
     // *bart1m2_leftb_7* updates
     if (t >= 0.0 && bart1m2_leftb_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_leftb_7.tStart = t;  // (not accounting for frame time here)
       bart1m2_leftb_7.frameNStart = frameN;  // exact frame index
       
       bart1m2_leftb_7.setAutoDraw(true);
     }
 
     
     // *bart1m2_lefta_7* updates
     if (t >= 0.0 && bart1m2_lefta_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_lefta_7.tStart = t;  // (not accounting for frame time here)
       bart1m2_lefta_7.frameNStart = frameN;  // exact frame index
       
       bart1m2_lefta_7.setAutoDraw(true);
     }
 
     // *mouse_12* updates
     if (t >= 0 && mouse_12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       mouse_12.tStart = t;  // (not accounting for frame time here)
       mouse_12.frameNStart = frameN;  // exact frame index
       
       mouse_12.status = PsychoJS.Status.STARTED;
       mouse_12.mouseClock.reset();
       prevButtonState = mouse_12.getPressed();  // if button is down already this ISN'T a new click
       }
     if (mouse_12.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = mouse_12.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = mouse_12.getPos();
           mouse_12.x.push(_mouseXYs[0]);
           mouse_12.y.push(_mouseXYs[1]);
           mouse_12.leftButton.push(_mouseButtons[0]);
           mouse_12.midButton.push(_mouseButtons[1]);
           mouse_12.rightButton.push(_mouseButtons[2]);
           mouse_12.time.push(mouse_12.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [check_box_5]) {
             if (obj.contains(mouse_12)) {
               gotValidClick = true;
               mouse_12.clicked_name.push(obj.name)
             }
           }
           if (gotValidClick === true) { // abort routine on response
             continueRoutine = false;
           }
         }
       }
     }
     
     // *fixedt1m2_a1_7* updates
     if (t >= 0.0 && fixedt1m2_a1_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a1_7.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a1_7.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a1_7.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_a2_7* updates
     if (t >= 0.0 && fixedt1m2_a2_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a2_7.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a2_7.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a2_7.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_a3_7* updates
     if (t >= 0.0 && fixedt1m2_a3_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a3_7.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a3_7.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a3_7.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_b1_7* updates
     if (t >= 0.0 && fixedt1m2_b1_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_b1_7.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_b1_7.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_b1_7.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_b2_7* updates
     if (t >= 0.0 && fixedt1m2_b2_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_b2_7.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_b2_7.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_b2_7.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_c1_7* updates
     if (t >= 0.0 && fixedt1m2_c1_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_c1_7.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_c1_7.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_c1_7.setAutoDraw(true);
     }
 
     
     // *text_exp_4* updates
     if (t >= 0.0 && text_exp_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_exp_4.tStart = t;  // (not accounting for frame time here)
       text_exp_4.frameNStart = frameN;  // exact frame index
       
       text_exp_4.setAutoDraw(true);
     }
 
     
     // *greent1m2_7* updates
     if (t >= 0.0 && greent1m2_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       greent1m2_7.tStart = t;  // (not accounting for frame time here)
       greent1m2_7.frameNStart = frameN;  // exact frame index
       
       greent1m2_7.setAutoDraw(true);
     }
 
     
     // *redt1m2_7* updates
     if (t >= 0.0 && redt1m2_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       redt1m2_7.tStart = t;  // (not accounting for frame time here)
       redt1m2_7.frameNStart = frameN;  // exact frame index
       
       redt1m2_7.setAutoDraw(true);
     }
 
     
     // *bluet1m2_7* updates
     if (t >= 0.0 && bluet1m2_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bluet1m2_7.tStart = t;  // (not accounting for frame time here)
       bluet1m2_7.frameNStart = frameN;  // exact frame index
       
       bluet1m2_7.setAutoDraw(true);
     }
 
     
     // *check_box_5* updates
     if (t >= 0.0 && check_box_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       check_box_5.tStart = t;  // (not accounting for frame time here)
       check_box_5.frameNStart = frameN;  // exact frame index
       
       check_box_5.setAutoDraw(true);
     }
 
     
     // *text_141* updates
     if (t >= 0.0 && text_141.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_141.tStart = t;  // (not accounting for frame time here)
       text_141.frameNStart = frameN;  // exact frame index
       
       text_141.setAutoDraw(true);
     }
 
     
     // *text_142* updates
     if (t >= 0.0 && text_142.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_142.tStart = t;  // (not accounting for frame time here)
       text_142.frameNStart = frameN;  // exact frame index
       
       text_142.setAutoDraw(true);
     }
 
     
     // *text_143* updates
     if (t >= 0.0 && text_143.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_143.tStart = t;  // (not accounting for frame time here)
       text_143.frameNStart = frameN;  // exact frame index
       
       text_143.setAutoDraw(true);
     }
 
     
     // *text_144* updates
     if (t >= 0.0 && text_144.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_144.tStart = t;  // (not accounting for frame time here)
       text_144.frameNStart = frameN;  // exact frame index
       
       text_144.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of tol_prepracticeComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function tol_prepracticeRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'tol_prepractice'-------
     for (const thisComponent of tol_prepracticeComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     if (mouse_12.x) {  psychoJS.experiment.addData('mouse_12.x', mouse_12.x[0])};
     if (mouse_12.y) {  psychoJS.experiment.addData('mouse_12.y', mouse_12.y[0])};
     if (mouse_12.leftButton) {  psychoJS.experiment.addData('mouse_12.leftButton', mouse_12.leftButton[0])};
     if (mouse_12.midButton) {  psychoJS.experiment.addData('mouse_12.midButton', mouse_12.midButton[0])};
     if (mouse_12.rightButton) {  psychoJS.experiment.addData('mouse_12.rightButton', mouse_12.rightButton[0])};
     if (mouse_12.time) {  psychoJS.experiment.addData('mouse_12.time', mouse_12.time[0])};
     if (mouse_12.clicked_name) {  psychoJS.experiment.addData('mouse_12.clicked_name', mouse_12.clicked_name[0])};
     
     // the Routine "tol_prepractice" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var msg_next;
 var tol_next_trialComponents;
 function tol_next_trialRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'tol_next_trial'-------
     t = 0;
     tol_next_trialClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     msg_next = "";
     if ((counter2 > 0)) {
         if ((counter2 > 1)) {
             if ((timer_t1 > 120)) {
                 msg_next = "Try to be faster next time\nLet\u2019s try another target board!";
             } else {
                 msg_next = "Great job! \nLet\u2019s try another target board!";
             }
         } else {
             if ((timer_t1 > 120)) {
                 msg_next = "Try to be faster next time\nLet\u2019s start with the real task!";
             } else {
                 msg_next = "Great job! \nLet\u2019s start with the real task!";
             }
         }
     }
     
     text_146.setText(msg_next);
     // setup some python lists for storing info about the mouse_15
     mouse_15.clicked_name = [];
     gotValidClick = false; // until a click is received
     // keep track of which components have finished
     tol_next_trialComponents = [];
     tol_next_trialComponents.push(light_gray_bg_13);
     tol_next_trialComponents.push(text_146);
     tol_next_trialComponents.push(mouse_15);
     tol_next_trialComponents.push(check_box_trial);
     tol_next_trialComponents.push(text_next_wel_3);
     
     for (const thisComponent of tol_next_trialComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function tol_next_trialRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'tol_next_trial'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = tol_next_trialClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     if ((counter2 > 0)) {
         if ((timer_t1 > 120)) {
             continueRoutine = true;
         } else {
             continueRoutine = true;
         }
     } else {
         continueRoutine = false;
     }
     
     
     // *light_gray_bg_13* updates
     if (t >= 0.0 && light_gray_bg_13.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       light_gray_bg_13.tStart = t;  // (not accounting for frame time here)
       light_gray_bg_13.frameNStart = frameN;  // exact frame index
       
       light_gray_bg_13.setAutoDraw(true);
     }
 
     
     // *text_146* updates
     if (t >= 0.0 && text_146.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_146.tStart = t;  // (not accounting for frame time here)
       text_146.frameNStart = frameN;  // exact frame index
       
       text_146.setAutoDraw(true);
     }
 
     // *mouse_15* updates
     if (t >= 0.0 && mouse_15.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       mouse_15.tStart = t;  // (not accounting for frame time here)
       mouse_15.frameNStart = frameN;  // exact frame index
       
       mouse_15.status = PsychoJS.Status.STARTED;
       mouse_15.mouseClock.reset();
       prevButtonState = mouse_15.getPressed();  // if button is down already this ISN'T a new click
       }
     if (mouse_15.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = mouse_15.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [check_box_trial]) {
             if (obj.contains(mouse_15)) {
               gotValidClick = true;
               mouse_15.clicked_name.push(obj.name)
             }
           }
           if (gotValidClick === true) { // abort routine on response
             continueRoutine = false;
           }
         }
       }
     }
     
     // *check_box_trial* updates
     if (t >= 0.0 && check_box_trial.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       check_box_trial.tStart = t;  // (not accounting for frame time here)
       check_box_trial.frameNStart = frameN;  // exact frame index
       
       check_box_trial.setAutoDraw(true);
     }
 
     
     // *text_next_wel_3* updates
     if (t >= 0.0 && text_next_wel_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_next_wel_3.tStart = t;  // (not accounting for frame time here)
       text_next_wel_3.frameNStart = frameN;  // exact frame index
       
       text_next_wel_3.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of tol_next_trialComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function tol_next_trialRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'tol_next_trial'-------
     for (const thisComponent of tol_next_trialComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     _mouseXYs = mouse_15.getPos();
     _mouseButtons = mouse_15.getPressed();
     psychoJS.experiment.addData('mouse_15.x', _mouseXYs[0]);
     psychoJS.experiment.addData('mouse_15.y', _mouseXYs[1]);
     psychoJS.experiment.addData('mouse_15.leftButton', _mouseButtons[0]);
     psychoJS.experiment.addData('mouse_15.midButton', _mouseButtons[1]);
     psychoJS.experiment.addData('mouse_15.rightButton', _mouseButtons[2]);
     if (mouse_15.clicked_name.length > 0) {
       psychoJS.experiment.addData('mouse_15.clicked_name', mouse_15.clicked_name[0]);}
     // the Routine "tol_next_trial" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var beginning_t1;
 var first_movementComponents;
 function first_movementRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'first_movement'-------
     t = 0;
     first_movementClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // setup some python lists for storing info about the mouse_3
     // current position of the mouse:
     mouse_3.x = [];
     mouse_3.y = [];
     mouse_3.leftButton = [];
     mouse_3.midButton = [];
     mouse_3.rightButton = [];
     mouse_3.time = [];
     mouse_3.clicked_name = [];
     gotValidClick = false; // until a click is received
     right_green.setPos(right_greenpos_orig);
     right_red.setPos(right_redpos_orig);
     right_blue.setPos(right_bluepos_orig);
     if ((counter < 1)) {
         bluet1m1.setPos(left_bluepos_orig);
         redt1m1.setPos(left_redpos_orig);
         greent1m1.setPos(left_greenpos_orig);
         timer = new util.Clock();
         beginning_t1 = timer.getTime();
         console.log(beginning_t1);
     } else {
         bluet1m1.setPos(bluepos);
         redt1m1.setPos(redpos);
         greent1m1.setPos(greenpos);
     }
     
     // keep track of which components have finished
     first_movementComponents = [];
     first_movementComponents.push(mouse_3);
     first_movementComponents.push(light_gray_bg);
     first_movementComponents.push(base_right);
     first_movementComponents.push(pole_right_01);
     first_movementComponents.push(pole_right_02);
     first_movementComponents.push(pole_right_03);
     first_movementComponents.push(right_green);
     first_movementComponents.push(right_red);
     first_movementComponents.push(right_blue);
     first_movementComponents.push(ball_hand_box);
     first_movementComponents.push(base_left);
     first_movementComponents.push(bart1m1_lefta);
     first_movementComponents.push(bart1m1_leftb);
     first_movementComponents.push(bart1m1_leftc);
     first_movementComponents.push(greent1m1);
     first_movementComponents.push(redt1m1);
     first_movementComponents.push(bluet1m1);
     first_movementComponents.push(fixedt1m1_a1);
     first_movementComponents.push(fixedt1m1_a2);
     first_movementComponents.push(fixedt1m1_a3);
     first_movementComponents.push(fixedt1m1_b1);
     first_movementComponents.push(fixedt1m1_b2);
     first_movementComponents.push(fixedt1m1_c1);
     first_movementComponents.push(text_148);
     
     for (const thisComponent of first_movementComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function first_movementRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'first_movement'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = first_movementClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     // *mouse_3* updates
     if (t >= 0 && mouse_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       mouse_3.tStart = t;  // (not accounting for frame time here)
       mouse_3.frameNStart = frameN;  // exact frame index
       
       mouse_3.status = PsychoJS.Status.STARTED;
       mouse_3.mouseClock.reset();
       prevButtonState = mouse_3.getPressed();  // if button is down already this ISN'T a new click
       }
     if (mouse_3.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = mouse_3.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = mouse_3.getPos();
           mouse_3.x.push(_mouseXYs[0]);
           mouse_3.y.push(_mouseXYs[1]);
           mouse_3.leftButton.push(_mouseButtons[0]);
           mouse_3.midButton.push(_mouseButtons[1]);
           mouse_3.rightButton.push(_mouseButtons[2]);
           mouse_3.time.push(mouse_3.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [bart1m1_lefta,  bart1m1_leftb, bart1m1_leftc]) {
             if (obj.contains(mouse_3)) {
               gotValidClick = true;
               mouse_3.clicked_name.push(obj.name)
             }
           }
         }
       }
     }
     
     // *light_gray_bg* updates
     if (t >= 0.0 && light_gray_bg.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       light_gray_bg.tStart = t;  // (not accounting for frame time here)
       light_gray_bg.frameNStart = frameN;  // exact frame index
       
       light_gray_bg.setAutoDraw(true);
     }
 
     
     // *base_right* updates
     if (t >= 0.0 && base_right.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_right.tStart = t;  // (not accounting for frame time here)
       base_right.frameNStart = frameN;  // exact frame index
       
       base_right.setAutoDraw(true);
     }
 
     
     // *pole_right_01* updates
     if (t >= 0.0 && pole_right_01.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_01.tStart = t;  // (not accounting for frame time here)
       pole_right_01.frameNStart = frameN;  // exact frame index
       
       pole_right_01.setAutoDraw(true);
     }
 
     
     // *pole_right_02* updates
     if (t >= 0.0 && pole_right_02.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_02.tStart = t;  // (not accounting for frame time here)
       pole_right_02.frameNStart = frameN;  // exact frame index
       
       pole_right_02.setAutoDraw(true);
     }
 
     
     // *pole_right_03* updates
     if (t >= 0.0 && pole_right_03.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_03.tStart = t;  // (not accounting for frame time here)
       pole_right_03.frameNStart = frameN;  // exact frame index
       
       pole_right_03.setAutoDraw(true);
     }
 
     
     // *right_green* updates
     if (t >= 0.0 && right_green.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_green.tStart = t;  // (not accounting for frame time here)
       right_green.frameNStart = frameN;  // exact frame index
       
       right_green.setAutoDraw(true);
     }
 
     
     // *right_red* updates
     if (t >= 0.0 && right_red.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_red.tStart = t;  // (not accounting for frame time here)
       right_red.frameNStart = frameN;  // exact frame index
       
       right_red.setAutoDraw(true);
     }
 
     
     // *right_blue* updates
     if (t >= 0.0 && right_blue.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_blue.tStart = t;  // (not accounting for frame time here)
       right_blue.frameNStart = frameN;  // exact frame index
       
       right_blue.setAutoDraw(true);
     }
 
     
     // *ball_hand_box* updates
     if (t >= 0.0 && ball_hand_box.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       ball_hand_box.tStart = t;  // (not accounting for frame time here)
       ball_hand_box.frameNStart = frameN;  // exact frame index
       
       ball_hand_box.setAutoDraw(true);
     }
 
     
     // *base_left* updates
     if (t >= 0.0 && base_left.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_left.tStart = t;  // (not accounting for frame time here)
       base_left.frameNStart = frameN;  // exact frame index
       
       base_left.setAutoDraw(true);
     }
 
     
     // *bart1m1_lefta* updates
     if (t >= 0.0 && bart1m1_lefta.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m1_lefta.tStart = t;  // (not accounting for frame time here)
       bart1m1_lefta.frameNStart = frameN;  // exact frame index
       
       bart1m1_lefta.setAutoDraw(true);
     }
 
     
     // *bart1m1_leftb* updates
     if (t >= 0.0 && bart1m1_leftb.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m1_leftb.tStart = t;  // (not accounting for frame time here)
       bart1m1_leftb.frameNStart = frameN;  // exact frame index
       
       bart1m1_leftb.setAutoDraw(true);
     }
 
     
     // *bart1m1_leftc* updates
     if (t >= 0.0 && bart1m1_leftc.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m1_leftc.tStart = t;  // (not accounting for frame time here)
       bart1m1_leftc.frameNStart = frameN;  // exact frame index
       
       bart1m1_leftc.setAutoDraw(true);
     }
 
     
     // *greent1m1* updates
     if (t >= 0.0 && greent1m1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       greent1m1.tStart = t;  // (not accounting for frame time here)
       greent1m1.frameNStart = frameN;  // exact frame index
       
       greent1m1.setAutoDraw(true);
     }
 
     
     // *redt1m1* updates
     if (t >= 0.0 && redt1m1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       redt1m1.tStart = t;  // (not accounting for frame time here)
       redt1m1.frameNStart = frameN;  // exact frame index
       
       redt1m1.setAutoDraw(true);
     }
 
     
     // *bluet1m1* updates
     if (t >= 0.0 && bluet1m1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bluet1m1.tStart = t;  // (not accounting for frame time here)
       bluet1m1.frameNStart = frameN;  // exact frame index
       
       bluet1m1.setAutoDraw(true);
     }
 
     if ((mouse_3.getPressed()[0] !== 0)) {
         if (mouse_3.isPressedIn(bart1m1_leftc)) {
             if (((fixedt1m1_a3.pos[0] === greent1m1.pos[0]) && (fixedt1m1_a3.pos[1] === greent1m1.pos[1]))) {
                 greenpos = [(- 0.35), 0.3];
                 console.log("a");
                 continueRoutine = false;
             } else {
                 if (((fixedt1m1_a3.pos[0] === bluet1m1.pos[0]) && (fixedt1m1_a3.pos[1] === bluet1m1.pos[1]))) {
                     bluepos = [(- 0.35), 0.3];
                     continueRoutine = false;
                     console.log("b");
                 } else {
                     if (((fixedt1m1_a3.pos[0] === redt1m1.pos[0]) && (fixedt1m1_a3.pos[1] === redt1m1.pos[1]))) {
                         redpos = [(- 0.35), 0.3];
                         continueRoutine = false;
                     } else {
                         if (((fixedt1m1_a2.pos[0] === greent1m1.pos[0]) && (fixedt1m1_a2.pos[1] === greent1m1.pos[1]))) {
                             greenpos = [(- 0.35), 0.3];
                             continueRoutine = false;
                             console.log("c");
                         } else {
                             if (((fixedt1m1_a2.pos[0] === bluet1m1.pos[0]) && (fixedt1m1_a2.pos[1] === bluet1m1.pos[1]))) {
                                 bluepos = [(- 0.35), 0.3];
                                 continueRoutine = false;
                                 console.log("d");
                             } else {
                                 if (((fixedt1m1_a2.pos[0] === redt1m1.pos[0]) && (fixedt1m1_a2.pos[1] === redt1m1.pos[1]))) {
                                     redpos = [(- 0.35), 0.3];
                                     continueRoutine = false;
                                     console.log("e");
                                 } else {
                                     if (((fixedt1m1_a1.pos[0] === greent1m1.pos[0]) && (fixedt1m1_a1.pos[1] === greent1m1.pos[1]))) {
                                         greenpos = [(- 0.35), 0.3];
                                         continueRoutine = false;
                                         console.log("f");
                                     } else {
                                         if (((fixedt1m1_a1.pos[0] === bluet1m1.pos[0]) && (fixedt1m1_a1.pos[1] === bluet1m1.pos[1]))) {
                                             bluepos = [(- 0.35), 0.3];
                                             continueRoutine = false;
                                             console.log("g");
                                         } else {
                                             if (((fixedt1m1_a1.pos[0] === redt1m1.pos[0]) && (fixedt1m1_a1.pos[1] === redt1m1.pos[1]))) {
                                                 redpos = [(- 0.35), 0.3];
                                                 continueRoutine = false;
                                                 console.log("h");
                                             } else {
                                                 console.log("nothing");
                                             }
                                         }
                                     }
                                 }
                             }
                         }
                     }
                 }
             }
         }
         if (mouse_3.isPressedIn(bart1m1_leftb)) {
             if (((fixedt1m1_b2.pos[0] === greent1m1.pos[0]) && (fixedt1m1_b2.pos[1] === greent1m1.pos[1]))) {
                 greenpos = [(- 0.35), 0.3];
                 continueRoutine = false;
                 console.log("i");
             } else {
                 if (((fixedt1m1_b2.pos[0] === bluet1m1.pos[0]) && (fixedt1m1_b2.pos[1] === bluet1m1.pos[1]))) {
                     bluepos = [(- 0.35), 0.3];
                     continueRoutine = false;
                     console.log("j");
                 } else {
                     if (((fixedt1m1_b2.pos[0] === redt1m1.pos[0]) && (fixedt1m1_b2.pos[1] === redt1m1.pos[1]))) {
                         redpos = [(- 0.35), 0.3];
                         continueRoutine = false;
                         console.log("k");
                     } else {
                         if (((fixedt1m1_b1.pos[0] === greent1m1.pos[0]) && (fixedt1m1_b1.pos[1] === greent1m1.pos[1]))) {
                             greenpos = [(- 0.35), 0.3];
                             continueRoutine = false;
                             console.log("l");
                         } else {
                             if (((fixedt1m1_b1.pos[0] === bluet1m1.pos[0]) && (fixedt1m1_b1.pos[1] === bluet1m1.pos[1]))) {
                                 bluepos = [(- 0.35), 0.3];
                                 continueRoutine = false;
                                 console.log("m");
                             } else {
                                 if (((fixedt1m1_b1.pos[0] === redt1m1.pos[0]) && (fixedt1m1_b1.pos[1] === redt1m1.pos[1]))) {
                                     redpos = [(- 0.35), 0.3];
                                     continueRoutine = false;
                                     console.log("n");
                                 } else {
                                     console.log("nothing");
                                 }
                             }
                         }
                     }
                 }
             }
         }
         if (mouse_3.isPressedIn(bart1m1_lefta)) {
             if (((fixedt1m1_c1.pos[0] === greent1m1.pos[0]) && (fixedt1m1_c1.pos[1] === greent1m1.pos[1]))) {
                 greenpos = [(- 0.35), 0.3];
                 continueRoutine = false;
                 console.log("o");
             } else {
                 if (((fixedt1m1_c1.pos[0] === bluet1m1.pos[0]) && (fixedt1m1_c1.pos[1] === bluet1m1.pos[1]))) {
                     bluepos = [(- 0.35), 0.3];
                     continueRoutine = false;
                     console.log("p");
                 } else {
                     if (((fixedt1m1_c1.pos[0] === redt1m1.pos[0]) && (fixedt1m1_c1.pos[1] === redt1m1.pos[1]))) {
                         redpos = [(- 0.35), 0.3];
                         continueRoutine = false;
                         console.log("q");
                     } else {
                         console.log("nothing");
                     }
                 }
             }
         }
     }
     
     
     // *fixedt1m1_a1* updates
     if (t >= 0.0 && fixedt1m1_a1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m1_a1.tStart = t;  // (not accounting for frame time here)
       fixedt1m1_a1.frameNStart = frameN;  // exact frame index
       
       fixedt1m1_a1.setAutoDraw(true);
     }
 
     
     // *fixedt1m1_a2* updates
     if (t >= 0.0 && fixedt1m1_a2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m1_a2.tStart = t;  // (not accounting for frame time here)
       fixedt1m1_a2.frameNStart = frameN;  // exact frame index
       
       fixedt1m1_a2.setAutoDraw(true);
     }
 
     
     // *fixedt1m1_a3* updates
     if (t >= 0.0 && fixedt1m1_a3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m1_a3.tStart = t;  // (not accounting for frame time here)
       fixedt1m1_a3.frameNStart = frameN;  // exact frame index
       
       fixedt1m1_a3.setAutoDraw(true);
     }
 
     
     // *fixedt1m1_b1* updates
     if (t >= 0.0 && fixedt1m1_b1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m1_b1.tStart = t;  // (not accounting for frame time here)
       fixedt1m1_b1.frameNStart = frameN;  // exact frame index
       
       fixedt1m1_b1.setAutoDraw(true);
     }
 
     
     // *fixedt1m1_b2* updates
     if (t >= 0.0 && fixedt1m1_b2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m1_b2.tStart = t;  // (not accounting for frame time here)
       fixedt1m1_b2.frameNStart = frameN;  // exact frame index
       
       fixedt1m1_b2.setAutoDraw(true);
     }
 
     
     // *fixedt1m1_c1* updates
     if (t >= 0.0 && fixedt1m1_c1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m1_c1.tStart = t;  // (not accounting for frame time here)
       fixedt1m1_c1.frameNStart = frameN;  // exact frame index
       
       fixedt1m1_c1.setAutoDraw(true);
     }
 
     
     // *text_148* updates
     if (t >= 0.0 && text_148.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_148.tStart = t;  // (not accounting for frame time here)
       text_148.frameNStart = frameN;  // exact frame index
       
       text_148.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of first_movementComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function first_movementRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'first_movement'-------
     for (const thisComponent of first_movementComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('mouse_3.x', mouse_3.x);
     psychoJS.experiment.addData('mouse_3.y', mouse_3.y);
     psychoJS.experiment.addData('mouse_3.leftButton', mouse_3.leftButton);
     psychoJS.experiment.addData('mouse_3.midButton', mouse_3.midButton);
     psychoJS.experiment.addData('mouse_3.rightButton', mouse_3.rightButton);
     psychoJS.experiment.addData('mouse_3.time', mouse_3.time);
     psychoJS.experiment.addData('mouse_3.clicked_name', mouse_3.clicked_name);
     
     if ((greenpos.length !== 0.0)) {
         if ((greenpos[1] === 0.3)) {
             greenpos = greenpos;
         } else {
             greenpos = greent1m1.pos;
             console.log("check1");
         }
     } else {
         greenpos = greent1m1.pos;
     }
     if ((redpos.length !== 0.0)) {
         if ((redpos[1] === 0.3)) {
             redpos = redpos;
         } else {
             redpos = redt1m1.pos;
             console.log("check1");
         }
     } else {
         redpos = redt1m1.pos;
     }
     if ((bluepos.length !== 0.0)) {
         if ((bluepos[1] === 0.3)) {
             bluepos = bluepos;
         } else {
             bluepos = bluet1m1.pos;
             console.log("check1");
         }
     } else {
         bluepos = bluet1m1.pos;
     }
     
     // the Routine "first_movement" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var check_step1_t1Components;
 function check_step1_t1RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'check_step1_t1'-------
     t = 0;
     check_step1_t1Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     right_green_4.setPos(right_greenpos_orig);
     right_red_4.setPos(right_redpos_orig);
     right_blue_4.setPos(right_bluepos_orig);
     // setup some python lists for storing info about the mouse_7
     // current position of the mouse:
     mouse_7.x = [];
     mouse_7.y = [];
     mouse_7.leftButton = [];
     mouse_7.midButton = [];
     mouse_7.rightButton = [];
     mouse_7.time = [];
     mouse_7.clicked_name = [];
     gotValidClick = false; // until a click is received
     greent1m2_3.setPos(greenpos);
     redt1m2_3.setPos(redpos);
     bluet1m2_3.setPos(bluepos);
     // keep track of which components have finished
     check_step1_t1Components = [];
     check_step1_t1Components.push(light_gray_bg_5);
     check_step1_t1Components.push(ball_hand_box_5);
     check_step1_t1Components.push(base_right_5);
     check_step1_t1Components.push(pole_right_10);
     check_step1_t1Components.push(pole_right_11);
     check_step1_t1Components.push(pole_right_12);
     check_step1_t1Components.push(right_green_4);
     check_step1_t1Components.push(right_red_4);
     check_step1_t1Components.push(right_blue_4);
     check_step1_t1Components.push(base_left_5);
     check_step1_t1Components.push(bart1m2_leftc_3);
     check_step1_t1Components.push(bart1m2_leftb_3);
     check_step1_t1Components.push(bart1m2_lefta_3);
     check_step1_t1Components.push(mouse_7);
     check_step1_t1Components.push(fixedt1m2_a1_3);
     check_step1_t1Components.push(fixedt1m2_a2_3);
     check_step1_t1Components.push(fixedt1m2_a3_3);
     check_step1_t1Components.push(fixedt1m2_b1_3);
     check_step1_t1Components.push(fixedt1m2_b2_3);
     check_step1_t1Components.push(fixedt1m2_c1_3);
     check_step1_t1Components.push(greent1m2_3);
     check_step1_t1Components.push(redt1m2_3);
     check_step1_t1Components.push(bluet1m2_3);
     check_step1_t1Components.push(text_150);
     
     for (const thisComponent of check_step1_t1Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function check_step1_t1RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'check_step1_t1'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = check_step1_t1Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *light_gray_bg_5* updates
     if (t >= 0.0 && light_gray_bg_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       light_gray_bg_5.tStart = t;  // (not accounting for frame time here)
       light_gray_bg_5.frameNStart = frameN;  // exact frame index
       
       light_gray_bg_5.setAutoDraw(true);
     }
 
     
     // *ball_hand_box_5* updates
     if (t >= 0.0 && ball_hand_box_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       ball_hand_box_5.tStart = t;  // (not accounting for frame time here)
       ball_hand_box_5.frameNStart = frameN;  // exact frame index
       
       ball_hand_box_5.setAutoDraw(true);
     }
 
     
     // *base_right_5* updates
     if (t >= 0.0 && base_right_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_right_5.tStart = t;  // (not accounting for frame time here)
       base_right_5.frameNStart = frameN;  // exact frame index
       
       base_right_5.setAutoDraw(true);
     }
 
     
     // *pole_right_10* updates
     if (t >= 0.0 && pole_right_10.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_10.tStart = t;  // (not accounting for frame time here)
       pole_right_10.frameNStart = frameN;  // exact frame index
       
       pole_right_10.setAutoDraw(true);
     }
 
     
     // *pole_right_11* updates
     if (t >= 0.0 && pole_right_11.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_11.tStart = t;  // (not accounting for frame time here)
       pole_right_11.frameNStart = frameN;  // exact frame index
       
       pole_right_11.setAutoDraw(true);
     }
 
     
     // *pole_right_12* updates
     if (t >= 0.0 && pole_right_12.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_12.tStart = t;  // (not accounting for frame time here)
       pole_right_12.frameNStart = frameN;  // exact frame index
       
       pole_right_12.setAutoDraw(true);
     }
 
     
     // *right_green_4* updates
     if (t >= 0.0 && right_green_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_green_4.tStart = t;  // (not accounting for frame time here)
       right_green_4.frameNStart = frameN;  // exact frame index
       
       right_green_4.setAutoDraw(true);
     }
 
     
     // *right_red_4* updates
     if (t >= 0.0 && right_red_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_red_4.tStart = t;  // (not accounting for frame time here)
       right_red_4.frameNStart = frameN;  // exact frame index
       
       right_red_4.setAutoDraw(true);
     }
 
     
     // *right_blue_4* updates
     if (t >= 0.0 && right_blue_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_blue_4.tStart = t;  // (not accounting for frame time here)
       right_blue_4.frameNStart = frameN;  // exact frame index
       
       right_blue_4.setAutoDraw(true);
     }
 
     
     // *base_left_5* updates
     if (t >= 0.0 && base_left_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_left_5.tStart = t;  // (not accounting for frame time here)
       base_left_5.frameNStart = frameN;  // exact frame index
       
       base_left_5.setAutoDraw(true);
     }
 
     
     // *bart1m2_leftc_3* updates
     if (t >= 0.0 && bart1m2_leftc_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_leftc_3.tStart = t;  // (not accounting for frame time here)
       bart1m2_leftc_3.frameNStart = frameN;  // exact frame index
       
       bart1m2_leftc_3.setAutoDraw(true);
     }
 
     
     // *bart1m2_leftb_3* updates
     if (t >= 0.0 && bart1m2_leftb_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_leftb_3.tStart = t;  // (not accounting for frame time here)
       bart1m2_leftb_3.frameNStart = frameN;  // exact frame index
       
       bart1m2_leftb_3.setAutoDraw(true);
     }
 
     
     // *bart1m2_lefta_3* updates
     if (t >= 0.0 && bart1m2_lefta_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_lefta_3.tStart = t;  // (not accounting for frame time here)
       bart1m2_lefta_3.frameNStart = frameN;  // exact frame index
       
       bart1m2_lefta_3.setAutoDraw(true);
     }
 
     // *mouse_7* updates
     if (t >= 0 && mouse_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       mouse_7.tStart = t;  // (not accounting for frame time here)
       mouse_7.frameNStart = frameN;  // exact frame index
       
       mouse_7.status = PsychoJS.Status.STARTED;
       mouse_7.mouseClock.reset();
       prevButtonState = mouse_7.getPressed();  // if button is down already this ISN'T a new click
       }
     if (mouse_7.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = mouse_7.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = mouse_7.getPos();
           mouse_7.x.push(_mouseXYs[0]);
           mouse_7.y.push(_mouseXYs[1]);
           mouse_7.leftButton.push(_mouseButtons[0]);
           mouse_7.midButton.push(_mouseButtons[1]);
           mouse_7.rightButton.push(_mouseButtons[2]);
           mouse_7.time.push(mouse_7.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [ball_hand_box_5]) {
             if (obj.contains(mouse_7)) {
               gotValidClick = true;
               mouse_7.clicked_name.push(obj.name)
             }
           }
           if (gotValidClick === true) { // abort routine on response
             continueRoutine = false;
           }
         }
       }
     }
     
     // *fixedt1m2_a1_3* updates
     if (t >= 0.0 && fixedt1m2_a1_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a1_3.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a1_3.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a1_3.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_a2_3* updates
     if (t >= 0.0 && fixedt1m2_a2_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a2_3.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a2_3.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a2_3.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_a3_3* updates
     if (t >= 0.0 && fixedt1m2_a3_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a3_3.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a3_3.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a3_3.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_b1_3* updates
     if (t >= 0.0 && fixedt1m2_b1_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_b1_3.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_b1_3.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_b1_3.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_b2_3* updates
     if (t >= 0.0 && fixedt1m2_b2_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_b2_3.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_b2_3.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_b2_3.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_c1_3* updates
     if (t >= 0.0 && fixedt1m2_c1_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_c1_3.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_c1_3.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_c1_3.setAutoDraw(true);
     }
 
     
     // *greent1m2_3* updates
     if (t >= 0.0 && greent1m2_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       greent1m2_3.tStart = t;  // (not accounting for frame time here)
       greent1m2_3.frameNStart = frameN;  // exact frame index
       
       greent1m2_3.setAutoDraw(true);
     }
 
     
     // *redt1m2_3* updates
     if (t >= 0.0 && redt1m2_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       redt1m2_3.tStart = t;  // (not accounting for frame time here)
       redt1m2_3.frameNStart = frameN;  // exact frame index
       
       redt1m2_3.setAutoDraw(true);
     }
 
     
     // *bluet1m2_3* updates
     if (t >= 0.0 && bluet1m2_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bluet1m2_3.tStart = t;  // (not accounting for frame time here)
       bluet1m2_3.frameNStart = frameN;  // exact frame index
       
       bluet1m2_3.setAutoDraw(true);
     }
 
     
     // *text_150* updates
     if (t >= 0.0 && text_150.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_150.tStart = t;  // (not accounting for frame time here)
       text_150.frameNStart = frameN;  // exact frame index
       
       text_150.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of check_step1_t1Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function check_step1_t1RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'check_step1_t1'-------
     for (const thisComponent of check_step1_t1Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     if (mouse_7.x) {  psychoJS.experiment.addData('mouse_7.x', mouse_7.x[0])};
     if (mouse_7.y) {  psychoJS.experiment.addData('mouse_7.y', mouse_7.y[0])};
     if (mouse_7.leftButton) {  psychoJS.experiment.addData('mouse_7.leftButton', mouse_7.leftButton[0])};
     if (mouse_7.midButton) {  psychoJS.experiment.addData('mouse_7.midButton', mouse_7.midButton[0])};
     if (mouse_7.rightButton) {  psychoJS.experiment.addData('mouse_7.rightButton', mouse_7.rightButton[0])};
     if (mouse_7.time) {  psychoJS.experiment.addData('mouse_7.time', mouse_7.time[0])};
     if (mouse_7.clicked_name) {  psychoJS.experiment.addData('mouse_7.clicked_name', mouse_7.clicked_name[0])};
     
     // the Routine "check_step1_t1" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var second_movComponents;
 function second_movRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'second_mov'-------
     t = 0;
     second_movClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     right_green_2.setPos(right_greenpos_orig);
     right_red_2.setPos(right_redpos_orig);
     right_blue_2.setPos(right_bluepos_orig);
     // setup some python lists for storing info about the mouse_4
     // current position of the mouse:
     mouse_4.x = [];
     mouse_4.y = [];
     mouse_4.leftButton = [];
     mouse_4.midButton = [];
     mouse_4.rightButton = [];
     mouse_4.time = [];
     mouse_4.clicked_name = [];
     gotValidClick = false; // until a click is received
     console.log(greenpos);
     console.log(redpos);
     console.log(bluepos);
     if ((greenpos[1] === 0.3)) {
         greent1m2.setPos([(- 0.35), 0.3]);
         console.log("test2");
         redt1m2.setPos(redpos);
         bluet1m2.setPos(bluepos);
     } else {
         if ((redpos[1] === 0.3)) {
             redt1m2.setPos([(- 0.35), 0.3]);
             console.log("test3");
             greent1m2.setPos(greenpos);
             bluet1m2.setPos(bluepos);
         } else {
             if ((bluepos[1] === 0.3)) {
                 bluet1m2.setPos([(- 0.35), 0.3]);
                 greent1m2.setPos(greenpos);
                 redt1m2.setPos(redpos);
                 console.log("test4");
             } else {
                 console.log("nothing2");
             }
         }
     }
     
     // keep track of which components have finished
     second_movComponents = [];
     second_movComponents.push(light_gray_bg_3);
     second_movComponents.push(ball_hand_box_3);
     second_movComponents.push(base_right_3);
     second_movComponents.push(pole_right_2);
     second_movComponents.push(pole_right_5);
     second_movComponents.push(pole_right_6);
     second_movComponents.push(right_green_2);
     second_movComponents.push(right_red_2);
     second_movComponents.push(right_blue_2);
     second_movComponents.push(base_left_3);
     second_movComponents.push(bart1m2_leftc);
     second_movComponents.push(bart1m2_leftb);
     second_movComponents.push(bart1m2_lefta);
     second_movComponents.push(mouse_4);
     second_movComponents.push(fixedt1m2_a1);
     second_movComponents.push(fixedt1m2_a2);
     second_movComponents.push(fixedt1m2_a3);
     second_movComponents.push(fixedt1m2_b1);
     second_movComponents.push(fixedt1m2_b2);
     second_movComponents.push(fixedt1m2_c1);
     second_movComponents.push(greent1m2);
     second_movComponents.push(redt1m2);
     second_movComponents.push(bluet1m2);
     second_movComponents.push(text_152);
     
     for (const thisComponent of second_movComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function second_movRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'second_mov'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = second_movClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *light_gray_bg_3* updates
     if (t >= 0.0 && light_gray_bg_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       light_gray_bg_3.tStart = t;  // (not accounting for frame time here)
       light_gray_bg_3.frameNStart = frameN;  // exact frame index
       
       light_gray_bg_3.setAutoDraw(true);
     }
 
     
     // *ball_hand_box_3* updates
     if (t >= 0.0 && ball_hand_box_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       ball_hand_box_3.tStart = t;  // (not accounting for frame time here)
       ball_hand_box_3.frameNStart = frameN;  // exact frame index
       
       ball_hand_box_3.setAutoDraw(true);
     }
 
     
     // *base_right_3* updates
     if (t >= 0.0 && base_right_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_right_3.tStart = t;  // (not accounting for frame time here)
       base_right_3.frameNStart = frameN;  // exact frame index
       
       base_right_3.setAutoDraw(true);
     }
 
     
     // *pole_right_2* updates
     if (t >= 0.0 && pole_right_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_2.tStart = t;  // (not accounting for frame time here)
       pole_right_2.frameNStart = frameN;  // exact frame index
       
       pole_right_2.setAutoDraw(true);
     }
 
     
     // *pole_right_5* updates
     if (t >= 0.0 && pole_right_5.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_5.tStart = t;  // (not accounting for frame time here)
       pole_right_5.frameNStart = frameN;  // exact frame index
       
       pole_right_5.setAutoDraw(true);
     }
 
     
     // *pole_right_6* updates
     if (t >= 0.0 && pole_right_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_6.tStart = t;  // (not accounting for frame time here)
       pole_right_6.frameNStart = frameN;  // exact frame index
       
       pole_right_6.setAutoDraw(true);
     }
 
     
     // *right_green_2* updates
     if (t >= 0.0 && right_green_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_green_2.tStart = t;  // (not accounting for frame time here)
       right_green_2.frameNStart = frameN;  // exact frame index
       
       right_green_2.setAutoDraw(true);
     }
 
     
     // *right_red_2* updates
     if (t >= 0.0 && right_red_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_red_2.tStart = t;  // (not accounting for frame time here)
       right_red_2.frameNStart = frameN;  // exact frame index
       
       right_red_2.setAutoDraw(true);
     }
 
     
     // *right_blue_2* updates
     if (t >= 0.0 && right_blue_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_blue_2.tStart = t;  // (not accounting for frame time here)
       right_blue_2.frameNStart = frameN;  // exact frame index
       
       right_blue_2.setAutoDraw(true);
     }
 
     
     // *base_left_3* updates
     if (t >= 0.0 && base_left_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_left_3.tStart = t;  // (not accounting for frame time here)
       base_left_3.frameNStart = frameN;  // exact frame index
       
       base_left_3.setAutoDraw(true);
     }
 
     
     // *bart1m2_leftc* updates
     if (t >= 0.0 && bart1m2_leftc.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_leftc.tStart = t;  // (not accounting for frame time here)
       bart1m2_leftc.frameNStart = frameN;  // exact frame index
       
       bart1m2_leftc.setAutoDraw(true);
     }
 
     
     // *bart1m2_leftb* updates
     if (t >= 0.0 && bart1m2_leftb.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_leftb.tStart = t;  // (not accounting for frame time here)
       bart1m2_leftb.frameNStart = frameN;  // exact frame index
       
       bart1m2_leftb.setAutoDraw(true);
     }
 
     
     // *bart1m2_lefta* updates
     if (t >= 0.0 && bart1m2_lefta.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_lefta.tStart = t;  // (not accounting for frame time here)
       bart1m2_lefta.frameNStart = frameN;  // exact frame index
       
       bart1m2_lefta.setAutoDraw(true);
     }
 
     // *mouse_4* updates
     if (t >= 0 && mouse_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       mouse_4.tStart = t;  // (not accounting for frame time here)
       mouse_4.frameNStart = frameN;  // exact frame index
       
       mouse_4.status = PsychoJS.Status.STARTED;
       mouse_4.mouseClock.reset();
       prevButtonState = mouse_4.getPressed();  // if button is down already this ISN'T a new click
       }
     if (mouse_4.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = mouse_4.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = mouse_4.getPos();
           mouse_4.x.push(_mouseXYs[0]);
           mouse_4.y.push(_mouseXYs[1]);
           mouse_4.leftButton.push(_mouseButtons[0]);
           mouse_4.midButton.push(_mouseButtons[1]);
           mouse_4.rightButton.push(_mouseButtons[2]);
           mouse_4.time.push(mouse_4.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [bart1m2_lefta, bart1m2_leftb, bart1m2_leftc]) {
             if (obj.contains(mouse_4)) {
               gotValidClick = true;
               mouse_4.clicked_name.push(obj.name)
             }
           }
         }
       }
     }
     
     // *fixedt1m2_a1* updates
     if (t >= 0.0 && fixedt1m2_a1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a1.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a1.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a1.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_a2* updates
     if (t >= 0.0 && fixedt1m2_a2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a2.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a2.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a2.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_a3* updates
     if (t >= 0.0 && fixedt1m2_a3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a3.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a3.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a3.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_b1* updates
     if (t >= 0.0 && fixedt1m2_b1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_b1.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_b1.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_b1.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_b2* updates
     if (t >= 0.0 && fixedt1m2_b2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_b2.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_b2.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_b2.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_c1* updates
     if (t >= 0.0 && fixedt1m2_c1.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_c1.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_c1.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_c1.setAutoDraw(true);
     }
 
     if (((ball_hand_box_3.pos[0] === greent1m2.pos[0]) && (ball_hand_box_3.pos[1] === greent1m2.pos[1]))) {
         if (mouse_4.isPressedIn(bart1m2_lefta)) {
             if ((((fixedt1m2_a2.pos[0] === redt1m2.pos[0]) && (fixedt1m2_a2.pos[1] === redt1m2.pos[1])) || ((fixedt1m2_a2.pos[0] === bluet1m2.pos[0]) && (fixedt1m2_a2.pos[1] === bluet1m2.pos[1])))) {
                 greenpos = fixedt1m2_a3.pos;
                 redpos = redt1m2.pos;
                 bluepos = bluet1m2.pos;
                 continueRoutine = false;
                 console.log("first 3");
             } else {
                 if ((((fixedt1m2_a1.pos[0] === redt1m2.pos[0]) && (fixedt1m2_a1.pos[1] === redt1m2.pos[1])) || ((fixedt1m2_a1.pos[0] === bluet1m2.pos[0]) && (fixedt1m2_a1.pos[1] === bluet1m2.pos[1])))) {
                     greenpos = fixedt1m2_a2.pos;
                     redpos = redt1m2.pos;
                     bluepos = bluet1m2.pos;
                     continueRoutine = false;
                     console.log("first 2");
                 } else {
                     greenpos = fixedt1m2_a1.pos;
                     redpos = redt1m2.pos;
                     bluepos = bluet1m2.pos;
                     continueRoutine = false;
                     console.log("first 1");
                 }
             }
         }
         if (mouse_4.isPressedIn(bart1m2_leftb)) {
             if ((((fixedt1m2_b2.pos[0] === redt1m2.pos[0]) && (fixedt1m2_b2.pos[1] === redt1m2.pos[1])) || ((fixedt1m2_b2.pos[0] === bluet1m2.pos[0]) && (fixedt1m2_b2.pos[1] === bluet1m2.pos[1])))) {
                 console.log("nothing");
             } else {
                 if ((((fixedt1m2_b1.pos[0] === redt1m2.pos[0]) && (fixedt1m2_b1.pos[1] === redt1m2.pos[1])) || ((fixedt1m2_b1.pos[0] === bluet1m2.pos[0]) && (fixedt1m2_b1.pos[1] === bluet1m2.pos[1])))) {
                     greenpos = fixedt1m2_b2.pos;
                     redpos = redt1m2.pos;
                     bluepos = bluet1m2.pos;
                     continueRoutine = false;
                     console.log("second");
                 } else {
                     greenpos = fixedt1m2_b1.pos;
                     redpos = redt1m2.pos;
                     bluepos = bluet1m2.pos;
                     continueRoutine = false;
                     console.log("third");
                 }
             }
         } else {
             if (mouse_4.isPressedIn(bart1m2_leftc)) {
                 if ((((fixedt1m2_c1.pos[0] === redt1m2.pos[0]) && (fixedt1m2_c1.pos[1] === redt1m2.pos[1])) || ((fixedt1m2_c1.pos[0] === bluet1m2.pos[0]) && (fixedt1m2_c1.pos[1] === bluet1m2.pos[1])))) {
                     console.log("nothing green");
                 } else {
                     greenpos = fixedt1m2_c1.pos;
                     redpos = redt1m2.pos;
                     bluepos = bluet1m2.pos;
                     continueRoutine = false;
                     console.log("forth");
                 }
             }
         }
     }
     if (((ball_hand_box_3.pos[0] === redt1m2.pos[0]) && (ball_hand_box_3.pos[1] === redt1m2.pos[1]))) {
         if (mouse_4.isPressedIn(bart1m2_lefta)) {
             if ((((fixedt1m2_a2.pos[0] === greent1m2.pos[0]) && (fixedt1m2_a2.pos[1] === greent1m2.pos[1])) || ((fixedt1m2_a2.pos[0] === bluet1m2.pos[0]) && (fixedt1m2_a2.pos[1] === bluet1m2.pos[1])))) {
                 greenpos = greent1m2.pos;
                 redpos = fixedt1m2_a3.pos;
                 bluepos = bluet1m2.pos;
                 continueRoutine = false;
                 console.log("red 3");
             } else {
                 if ((((fixedt1m2_a1.pos[0] === greent1m2.pos[0]) && (fixedt1m2_a1.pos[1] === greent1m2.pos[1])) || ((fixedt1m2_a1.pos[0] === bluet1m2.pos[0]) && (fixedt1m2_a1.pos[1] === bluet1m2.pos[1])))) {
                     greenpos = greent1m2.pos;
                     redpos = fixedt1m2_a2.pos;
                     bluepos = bluet1m2.pos;
                     continueRoutine = false;
                     console.log("red 2");
                 } else {
                     greenpos = greent1m2.pos;
                     redpos = fixedt1m2_a1.pos;
                     bluepos = bluet1m2.pos;
                     continueRoutine = false;
                     console.log("red 1");
                 }
             }
         }
         if (mouse_4.isPressedIn(bart1m2_leftb)) {
             if ((((fixedt1m2_b2.pos[0] === greent1m2.pos[0]) && (fixedt1m2_b2.pos[1] === greent1m2.pos[1])) || ((fixedt1m2_b2.pos[0] === bluet1m2.pos[0]) && (fixedt1m2_b2.pos[1] === bluet1m2.pos[1])))) {
                 console.log("nothing red");
             } else {
                 if ((((fixedt1m2_b1.pos[0] === greent1m2.pos[0]) && (fixedt1m2_b1.pos[1] === greent1m2.pos[1])) || ((fixedt1m2_b1.pos[0] === bluet1m2.pos[0]) && (fixedt1m2_b1.pos[1] === bluet1m2.pos[1])))) {
                     greenpos = greent1m2.pos;
                     redpos = fixedt1m2_b2.pos;
                     bluepos = bluet1m2.pos;
                     continueRoutine = false;
                     console.log("red second");
                 } else {
                     greenpos = greent1m2.pos;
                     redpos = fixedt1m2_b1.pos;
                     bluepos = bluet1m2.pos;
                     continueRoutine = false;
                     console.log("red third");
                 }
             }
         } else {
             if (mouse_4.isPressedIn(bart1m2_leftc)) {
                 if ((((fixedt1m2_c1.pos[0] === greent1m2.pos[0]) && (fixedt1m2_c1.pos[1] === greent1m2.pos[1])) || ((fixedt1m2_c1.pos[0] === bluet1m2.pos[0]) && (fixedt1m2_c1.pos[1] === bluet1m2.pos[1])))) {
                     console.log("red nothing");
                 } else {
                     greenpos = greent1m2.pos;
                     redpos = fixedt1m2_c1.pos;
                     bluepos = bluet1m2.pos;
                     continueRoutine = false;
                     console.log("red forth");
                 }
             }
         }
     }
     if (((ball_hand_box_3.pos[0] === bluet1m2.pos[0]) && (ball_hand_box_3.pos[1] === bluet1m2.pos[1]))) {
         if (mouse_4.isPressedIn(bart1m2_lefta)) {
             if ((((fixedt1m2_a2.pos[0] === greent1m2.pos[0]) && (fixedt1m2_a2.pos[1] === greent1m2.pos[1])) || ((fixedt1m2_a2.pos[0] === redt1m2.pos[0]) && (fixedt1m2_a2.pos[1] === redt1m2.pos[1])))) {
                 greenpos = greent1m2.pos;
                 redpos = redt1m2.pos;
                 bluepos = fixedt1m2_a3.pos;
                 continueRoutine = false;
                 console.log("blue 3");
             } else {
                 if ((((fixedt1m2_a1.pos[0] === greent1m2.pos[0]) && (fixedt1m2_a1.pos[1] === greent1m2.pos[1])) || ((fixedt1m2_a1.pos[0] === redt1m2.pos[0]) && (fixedt1m2_a1.pos[1] === redt1m2.pos[1])))) {
                     greenpos = greent1m2.pos;
                     redpos = redt1m2.pos;
                     bluepos = fixedt1m2_a2.pos;
                     continueRoutine = false;
                     console.log("blue 2");
                 } else {
                     greenpos = greent1m2.pos;
                     redpos = redt1m2.pos;
                     bluepos = fixedt1m2_a1.pos;
                     continueRoutine = false;
                     console.log("blue 1");
                 }
             }
         }
         if (mouse_4.isPressedIn(bart1m2_leftb)) {
             if ((((fixedt1m2_b2.pos[0] === greent1m2.pos[0]) && (fixedt1m2_b2.pos[1] === greent1m2.pos[1])) || ((fixedt1m2_b2.pos[0] === redt1m2.pos[0]) && (fixedt1m2_b2.pos[1] === redt1m2.pos[1])))) {
                 console.log("nothing blue");
             } else {
                 if ((((fixedt1m2_b1.pos[0] === greent1m2.pos[0]) && (fixedt1m2_b1.pos[1] === greent1m2.pos[1])) || ((fixedt1m2_b1.pos[0] === redt1m2.pos[0]) && (fixedt1m2_b1.pos[1] === redt1m2.pos[1])))) {
                     greenpos = greent1m2.pos;
                     redpos = redt1m2.pos;
                     bluepos = fixedt1m2_b2.pos;
                     continueRoutine = false;
                     console.log("blue second");
                 } else {
                     greenpos = greent1m2.pos;
                     redpos = redt1m2.pos;
                     bluepos = fixedt1m2_b1.pos;
                     continueRoutine = false;
                     console.log("blue third");
                 }
             }
         } else {
             if (mouse_4.isPressedIn(bart1m2_leftc)) {
                 if ((((fixedt1m2_c1.pos[0] === greent1m2.pos[0]) && (fixedt1m2_c1.pos[1] === greent1m2.pos[1])) || ((fixedt1m2_c1.pos[0] === redt1m2.pos[0]) && (fixedt1m2_c1.pos[1] === redt1m2.pos[1])))) {
                     console.log("blue nothing");
                 } else {
                     greenpos = greent1m2.pos;
                     redpos = redt1m2.pos;
                     bluepos = fixedt1m2_c1.pos;
                     continueRoutine = false;
                     console.log("blue forth");
                 }
             }
         }
     }
     
     
     // *greent1m2* updates
     if (t >= 0.0 && greent1m2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       greent1m2.tStart = t;  // (not accounting for frame time here)
       greent1m2.frameNStart = frameN;  // exact frame index
       
       greent1m2.setAutoDraw(true);
     }
 
     
     // *redt1m2* updates
     if (t >= 0.0 && redt1m2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       redt1m2.tStart = t;  // (not accounting for frame time here)
       redt1m2.frameNStart = frameN;  // exact frame index
       
       redt1m2.setAutoDraw(true);
     }
 
     
     // *bluet1m2* updates
     if (t >= 0.0 && bluet1m2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bluet1m2.tStart = t;  // (not accounting for frame time here)
       bluet1m2.frameNStart = frameN;  // exact frame index
       
       bluet1m2.setAutoDraw(true);
     }
 
     
     // *text_152* updates
     if (t >= 0.0 && text_152.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_152.tStart = t;  // (not accounting for frame time here)
       text_152.frameNStart = frameN;  // exact frame index
       
       text_152.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of second_movComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function second_movRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'second_mov'-------
     for (const thisComponent of second_movComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     psychoJS.experiment.addData('mouse_4.x', mouse_4.x);
     psychoJS.experiment.addData('mouse_4.y', mouse_4.y);
     psychoJS.experiment.addData('mouse_4.leftButton', mouse_4.leftButton);
     psychoJS.experiment.addData('mouse_4.midButton', mouse_4.midButton);
     psychoJS.experiment.addData('mouse_4.rightButton', mouse_4.rightButton);
     psychoJS.experiment.addData('mouse_4.time', mouse_4.time);
     psychoJS.experiment.addData('mouse_4.clicked_name', mouse_4.clicked_name);
     
     // the Routine "second_mov" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var check_step2_t1Components;
 function check_step2_t1RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'check_step2_t1'-------
     t = 0;
     check_step2_t1Clock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     right_green_3.setPos(right_greenpos_orig);
     right_red_3.setPos(right_redpos_orig);
     right_blue_3.setPos(right_bluepos_orig);
     // setup some python lists for storing info about the mouse_6
     // current position of the mouse:
     mouse_6.x = [];
     mouse_6.y = [];
     mouse_6.leftButton = [];
     mouse_6.midButton = [];
     mouse_6.rightButton = [];
     mouse_6.time = [];
     mouse_6.clicked_name = [];
     gotValidClick = false; // until a click is received
     greent1m2_2.setPos(greenpos);
     redt1m2_2.setPos(redpos);
     bluet1m2_2.setPos(bluepos);
     // keep track of which components have finished
     check_step2_t1Components = [];
     check_step2_t1Components.push(light_gray_bg_4);
     check_step2_t1Components.push(ball_hand_box_4);
     check_step2_t1Components.push(base_right_4);
     check_step2_t1Components.push(pole_right_7);
     check_step2_t1Components.push(pole_right_8);
     check_step2_t1Components.push(pole_right_9);
     check_step2_t1Components.push(right_green_3);
     check_step2_t1Components.push(right_red_3);
     check_step2_t1Components.push(right_blue_3);
     check_step2_t1Components.push(base_left_4);
     check_step2_t1Components.push(bart1m2_leftc_2);
     check_step2_t1Components.push(bart1m2_leftb_2);
     check_step2_t1Components.push(bart1m2_lefta_2);
     check_step2_t1Components.push(mouse_6);
     check_step2_t1Components.push(fixedt1m2_a1_2);
     check_step2_t1Components.push(fixedt1m2_a2_2);
     check_step2_t1Components.push(fixedt1m2_a3_2);
     check_step2_t1Components.push(fixedt1m2_b1_2);
     check_step2_t1Components.push(fixedt1m2_b2_2);
     check_step2_t1Components.push(fixedt1m2_c1_2);
     check_step2_t1Components.push(greent1m2_2);
     check_step2_t1Components.push(redt1m2_2);
     check_step2_t1Components.push(bluet1m2_2);
     check_step2_t1Components.push(check_box);
     check_step2_t1Components.push(text_154);
     
     for (const thisComponent of check_step2_t1Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function check_step2_t1RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'check_step2_t1'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = check_step2_t1Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *light_gray_bg_4* updates
     if (t >= 0.0 && light_gray_bg_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       light_gray_bg_4.tStart = t;  // (not accounting for frame time here)
       light_gray_bg_4.frameNStart = frameN;  // exact frame index
       
       light_gray_bg_4.setAutoDraw(true);
     }
 
     
     // *ball_hand_box_4* updates
     if (t >= 0.0 && ball_hand_box_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       ball_hand_box_4.tStart = t;  // (not accounting for frame time here)
       ball_hand_box_4.frameNStart = frameN;  // exact frame index
       
       ball_hand_box_4.setAutoDraw(true);
     }
 
     
     // *base_right_4* updates
     if (t >= 0.0 && base_right_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_right_4.tStart = t;  // (not accounting for frame time here)
       base_right_4.frameNStart = frameN;  // exact frame index
       
       base_right_4.setAutoDraw(true);
     }
 
     
     // *pole_right_7* updates
     if (t >= 0.0 && pole_right_7.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_7.tStart = t;  // (not accounting for frame time here)
       pole_right_7.frameNStart = frameN;  // exact frame index
       
       pole_right_7.setAutoDraw(true);
     }
 
     
     // *pole_right_8* updates
     if (t >= 0.0 && pole_right_8.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_8.tStart = t;  // (not accounting for frame time here)
       pole_right_8.frameNStart = frameN;  // exact frame index
       
       pole_right_8.setAutoDraw(true);
     }
 
     
     // *pole_right_9* updates
     if (t >= 0.0 && pole_right_9.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       pole_right_9.tStart = t;  // (not accounting for frame time here)
       pole_right_9.frameNStart = frameN;  // exact frame index
       
       pole_right_9.setAutoDraw(true);
     }
 
     
     // *right_green_3* updates
     if (t >= 0.0 && right_green_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_green_3.tStart = t;  // (not accounting for frame time here)
       right_green_3.frameNStart = frameN;  // exact frame index
       
       right_green_3.setAutoDraw(true);
     }
 
     
     // *right_red_3* updates
     if (t >= 0.0 && right_red_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_red_3.tStart = t;  // (not accounting for frame time here)
       right_red_3.frameNStart = frameN;  // exact frame index
       
       right_red_3.setAutoDraw(true);
     }
 
     
     // *right_blue_3* updates
     if (t >= 0.0 && right_blue_3.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       right_blue_3.tStart = t;  // (not accounting for frame time here)
       right_blue_3.frameNStart = frameN;  // exact frame index
       
       right_blue_3.setAutoDraw(true);
     }
 
     
     // *base_left_4* updates
     if (t >= 0.0 && base_left_4.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       base_left_4.tStart = t;  // (not accounting for frame time here)
       base_left_4.frameNStart = frameN;  // exact frame index
       
       base_left_4.setAutoDraw(true);
     }
 
     
     // *bart1m2_leftc_2* updates
     if (t >= 0.0 && bart1m2_leftc_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_leftc_2.tStart = t;  // (not accounting for frame time here)
       bart1m2_leftc_2.frameNStart = frameN;  // exact frame index
       
       bart1m2_leftc_2.setAutoDraw(true);
     }
 
     
     // *bart1m2_leftb_2* updates
     if (t >= 0.0 && bart1m2_leftb_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_leftb_2.tStart = t;  // (not accounting for frame time here)
       bart1m2_leftb_2.frameNStart = frameN;  // exact frame index
       
       bart1m2_leftb_2.setAutoDraw(true);
     }
 
     
     // *bart1m2_lefta_2* updates
     if (t >= 0.0 && bart1m2_lefta_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bart1m2_lefta_2.tStart = t;  // (not accounting for frame time here)
       bart1m2_lefta_2.frameNStart = frameN;  // exact frame index
       
       bart1m2_lefta_2.setAutoDraw(true);
     }
 
     // *mouse_6* updates
     if (t >= 0 && mouse_6.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       mouse_6.tStart = t;  // (not accounting for frame time here)
       mouse_6.frameNStart = frameN;  // exact frame index
       
       mouse_6.status = PsychoJS.Status.STARTED;
       mouse_6.mouseClock.reset();
       prevButtonState = mouse_6.getPressed();  // if button is down already this ISN'T a new click
       }
     if (mouse_6.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
       _mouseButtons = mouse_6.getPressed();
       if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
         prevButtonState = _mouseButtons;
         if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
           _mouseXYs = mouse_6.getPos();
           mouse_6.x.push(_mouseXYs[0]);
           mouse_6.y.push(_mouseXYs[1]);
           mouse_6.leftButton.push(_mouseButtons[0]);
           mouse_6.midButton.push(_mouseButtons[1]);
           mouse_6.rightButton.push(_mouseButtons[2]);
           mouse_6.time.push(mouse_6.mouseClock.getTime());
           // check if the mouse was inside our 'clickable' objects
           gotValidClick = false;
           for (const obj of [check_box]) {
             if (obj.contains(mouse_6)) {
               gotValidClick = true;
               mouse_6.clicked_name.push(obj.name)
             }
           }
           if (gotValidClick === true) { // abort routine on response
             continueRoutine = false;
           }
         }
       }
     }
     
     // *fixedt1m2_a1_2* updates
     if (t >= 0.0 && fixedt1m2_a1_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a1_2.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a1_2.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a1_2.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_a2_2* updates
     if (t >= 0.0 && fixedt1m2_a2_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a2_2.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a2_2.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a2_2.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_a3_2* updates
     if (t >= 0.0 && fixedt1m2_a3_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_a3_2.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_a3_2.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_a3_2.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_b1_2* updates
     if (t >= 0.0 && fixedt1m2_b1_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_b1_2.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_b1_2.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_b1_2.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_b2_2* updates
     if (t >= 0.0 && fixedt1m2_b2_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_b2_2.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_b2_2.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_b2_2.setAutoDraw(true);
     }
 
     
     // *fixedt1m2_c1_2* updates
     if (t >= 0.0 && fixedt1m2_c1_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       fixedt1m2_c1_2.tStart = t;  // (not accounting for frame time here)
       fixedt1m2_c1_2.frameNStart = frameN;  // exact frame index
       
       fixedt1m2_c1_2.setAutoDraw(true);
     }
 
     
     // *greent1m2_2* updates
     if (t >= 0.0 && greent1m2_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       greent1m2_2.tStart = t;  // (not accounting for frame time here)
       greent1m2_2.frameNStart = frameN;  // exact frame index
       
       greent1m2_2.setAutoDraw(true);
     }
 
     
     // *redt1m2_2* updates
     if (t >= 0.0 && redt1m2_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       redt1m2_2.tStart = t;  // (not accounting for frame time here)
       redt1m2_2.frameNStart = frameN;  // exact frame index
       
       redt1m2_2.setAutoDraw(true);
     }
 
     
     // *bluet1m2_2* updates
     if (t >= 0.0 && bluet1m2_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       bluet1m2_2.tStart = t;  // (not accounting for frame time here)
       bluet1m2_2.frameNStart = frameN;  // exact frame index
       
       bluet1m2_2.setAutoDraw(true);
     }
 
     
     // *check_box* updates
     if (t >= 0.0 && check_box.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       check_box.tStart = t;  // (not accounting for frame time here)
       check_box.frameNStart = frameN;  // exact frame index
       
       check_box.setAutoDraw(true);
     }
 
     
     // *text_154* updates
     if (t >= 0.0 && text_154.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       text_154.tStart = t;  // (not accounting for frame time here)
       text_154.frameNStart = frameN;  // exact frame index
       
       text_154.setAutoDraw(true);
     }
 
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of check_step2_t1Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function check_step2_t1RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'check_step2_t1'-------
     for (const thisComponent of check_step2_t1Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     // store data for thisExp (ExperimentHandler)
     if (mouse_6.x) {  psychoJS.experiment.addData('mouse_6.x', mouse_6.x[0])};
     if (mouse_6.y) {  psychoJS.experiment.addData('mouse_6.y', mouse_6.y[0])};
     if (mouse_6.leftButton) {  psychoJS.experiment.addData('mouse_6.leftButton', mouse_6.leftButton[0])};
     if (mouse_6.midButton) {  psychoJS.experiment.addData('mouse_6.midButton', mouse_6.midButton[0])};
     if (mouse_6.rightButton) {  psychoJS.experiment.addData('mouse_6.rightButton', mouse_6.rightButton[0])};
     if (mouse_6.time) {  psychoJS.experiment.addData('mouse_6.time', mouse_6.time[0])};
     if (mouse_6.clicked_name) {  psychoJS.experiment.addData('mouse_6.clicked_name', mouse_6.clicked_name[0])};
     
     // the Routine "check_step2_t1" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var check_positionsComponents;
 function check_positionsRoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'check_positions'-------
     t = 0;
     check_positionsClock.reset(); // clock
     frameN = -1;
     // update component parameters for each repeat
     // keep track of which components have finished
     check_positionsComponents = [];
     
     for (const thisComponent of check_positionsComponents)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function check_positionsRoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'check_positions'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = check_positionsClock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of check_positionsComponents)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 var end_t1;
 var timer_t1;
 function check_positionsRoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'check_positions'-------
     for (const thisComponent of check_positionsComponents) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     counter = (counter + 1);
     console.log("check positions");
     console.log(greenpos);
     console.log(redpos);
     console.log(bluepos);
     if ((counter > 0)) {
         if (((greenpos[0] === greenfinal[0]) && (greenpos[1] === greenfinal[1]))) {
             psychoJS.experiment.addData("green_corr", "correct");
             if (((redpos[0] === redfinal[0]) && (redpos[1] === redfinal[1]))) {
                 psychoJS.experiment.addData("red_corr", "correct");
                 if (((bluepos[0] === bluefinal[0]) && (bluepos[1] === bluefinal[1]))) {
                     psychoJS.experiment.addData("blue_corr", "correct");
                     movements.finished = true;
                     bluepos = [];
                     greenpos = [];
                     redpos = [];
                     counter = 0;
                     counter2 = (counter2 + 1);
                 }
             }
         } else {
             /* keep playing */
         }
     }
     end_t1 = timer.getTime();
     timer_t1 = (end_t1 - beginning_t1);
     console.log(timer_t1);
     psychoJS.experiment.addData("timer_end", timer_t1);
     if ((timer_t1 > 120)) {
         movements.finished = true;
         bluepos = [];
         greenpos = [];
         redpos = [];
         counter = 0;
         counter2 = (counter2 + 1);
     }
     
     // the Routine "check_positions" was not non-slip safe, so reset the non-slip timer
     routineTimer.reset();
     
     return Scheduler.Event.NEXT;
   };
 }
 
 
 var End_2Components;
 function End_2RoutineBegin(snapshot) {
   return function () {
     //------Prepare to start Routine 'End_2'-------
     t = 0;
     End_2Clock.reset(); // clock
     frameN = -1;
     routineTimer.add(10.000000);
     // update component parameters for each repeat
     // keep track of which components have finished
     End_2Components = [];
     End_2Components.push(thank_you_2);
     End_2Components.push(end);
     End_2Components.push(image_16);
     
     for (const thisComponent of End_2Components)
       if ('status' in thisComponent)
         thisComponent.status = PsychoJS.Status.NOT_STARTED;
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function End_2RoutineEachFrame(snapshot) {
   return function () {
     //------Loop for each frame of Routine 'End_2'-------
     let continueRoutine = true; // until we're told otherwise
     // get current time
     t = End_2Clock.getTime();
     frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
     // update/draw components on each frame
     
     // *thank_you_2* updates
     if (t >= 0.0 && thank_you_2.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       thank_you_2.tStart = t;  // (not accounting for frame time here)
       thank_you_2.frameNStart = frameN;  // exact frame index
       
       thank_you_2.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((thank_you_2.status === PsychoJS.Status.STARTED || thank_you_2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       thank_you_2.setAutoDraw(false);
     }
     
     // *end* updates
     if (t >= 0.0 && end.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       end.tStart = t;  // (not accounting for frame time here)
       end.frameNStart = frameN;  // exact frame index
       
       end.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((end.status === PsychoJS.Status.STARTED || end.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       end.setAutoDraw(false);
     }
     
     // *image_16* updates
     if (t >= 0.0 && image_16.status === PsychoJS.Status.NOT_STARTED) {
       // keep track of start time/frame for later
       image_16.tStart = t;  // (not accounting for frame time here)
       image_16.frameNStart = frameN;  // exact frame index
       
       image_16.setAutoDraw(true);
     }
 
     frameRemains = 0.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
     if ((image_16.status === PsychoJS.Status.STARTED || image_16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
       image_16.setAutoDraw(false);
     }
     // check for quit (typically the Esc key)
     if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
       return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
     }
     
     // check if the Routine should terminate
     if (!continueRoutine) {  // a component has requested a forced-end of Routine
       return Scheduler.Event.NEXT;
     }
     
     continueRoutine = false;  // reverts to True if at least one component still running
     for (const thisComponent of End_2Components)
       if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
         continueRoutine = true;
         break;
       }
     
     // refresh the screen if continuing
     if (continueRoutine && routineTimer.getTime() > 0) {
       return Scheduler.Event.FLIP_REPEAT;
     } else {
       return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function End_2RoutineEnd(snapshot) {
   return function () {
     //------Ending Routine 'End_2'-------
     for (const thisComponent of End_2Components) {
       if (typeof thisComponent.setAutoDraw === 'function') {
         thisComponent.setAutoDraw(false);
       }
     }
     var end_exp = timer_exp.getTime();
     var time_exp = (end_exp - beginning_exp2);
     console.log(time_exp);
     psychoJS.experiment.addData("totaltime_exp", time_exp);
     return Scheduler.Event.NEXT;
   };
 }
 
 
 function endLoopIteration(scheduler, snapshot) {
   // ------Prepare for next entry------
   return function () {
     if (typeof snapshot !== 'undefined') {
       // ------Check if user ended loop early------
       if (snapshot.finished) {
         // Check for and save orphaned data
         if (psychoJS.experiment.isEntryEmpty()) {
           psychoJS.experiment.nextEntry(snapshot);
         }
         scheduler.stop();
       } else {
         const thisTrial = snapshot.getCurrentTrial();
         if (typeof thisTrial === 'undefined' || !('isTrials' in thisTrial) || thisTrial.isTrials) {
           psychoJS.experiment.nextEntry(snapshot);
         }
       }
     return Scheduler.Event.NEXT;
     }
   };
 }
 
 
 function importConditions(currentLoop) {
   return function () {
     psychoJS.importAttributes(currentLoop.getCurrentTrial());
     return Scheduler.Event.NEXT;
     };
 }
 
 
 function quitPsychoJS(message, isCompleted) {
   // Check for and save orphaned data
   if (psychoJS.experiment.isEntryEmpty()) {
     psychoJS.experiment.nextEntry();
   }
   
   
   psychoJS.window.close();
   psychoJS.quit({message: message, isCompleted: isCompleted});
   
   return Scheduler.Event.QUIT;
 }